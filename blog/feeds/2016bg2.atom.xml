<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>機械設計專題 (虎尾科大MDE)</title><link href="http://project.mde.tw/blog/" rel="alternate"></link><link href="http://project.mde.tw/blog/feeds/2016bg2.atom.xml" rel="self"></link><id>http://project.mde.tw/blog/</id><updated>2017-12-03T21:00:00+08:00</updated><entry><title>Pyslvs 開發進度 - 12/03</title><link href="http://project.mde.tw/blog/pyslvs-kai-fa-jin-du-1203.html" rel="alternate"></link><published>2017-12-03T21:00:00+08:00</published><updated>2017-12-03T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-12-03:blog/pyslvs-kai-fa-jin-du-1203.html</id><summary type="html">&lt;p&gt;Pyslvs v0.9 大更新進度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PMKS 轉換式更新&lt;/li&gt;
&lt;li&gt;機構範例&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;PMKS 轉換式更新&lt;/h1&gt;
&lt;p&gt;完成滑動接頭 P 與 RP 的轉換式，已經可以支援這兩種接頭的輸入。&lt;/p&gt;
&lt;p&gt;另外改進了三點共線和共點在 Solvespace 輸入的錯誤。&lt;/p&gt;
&lt;h1&gt;機構範例&lt;/h1&gt;
&lt;p&gt;增加了兩個範例，用作測試上述程式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;曲柄滑塊&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_12_03_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;雙臂接球機構&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_12_03_02.png" /&gt;&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Pyslvs 開發進度 - 11/28</title><link href="http://project.mde.tw/blog/pyslvs-kai-fa-jin-du-1128.html" rel="alternate"></link><published>2017-11-28T21:00:00+08:00</published><updated>2017-11-28T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-11-28:blog/pyslvs-kai-fa-jin-du-1128.html</id><summary type="html">&lt;p&gt;Pyslvs v0.9 大更新進度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介面操作重大更新&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;介面操作重大更新&lt;/h1&gt;
&lt;p&gt;今天改寫了一下畫布介面。&lt;/p&gt;
&lt;p&gt;將拍照到剪貼簿的按鈕移到右上角的版本標籤旁；表格頁籤旁改成「全部選擇」按鈕。&lt;/p&gt;
&lt;p&gt;新增兩個功能的快捷鍵：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全選點 (Select all point)：Ctrl + A&lt;/li&gt;
&lt;li&gt;自由移動模式切換 (Free move mode toggle)：Ctrl + F&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外有一個重大突破：矩形窗選功能。&lt;/p&gt;
&lt;p&gt;在非自由移動模式下可靠滑鼠拖拉矩形線框，選取畫布上的點。&lt;/p&gt;
&lt;p&gt;自由移動模式下拖拉將會移動並修改選擇的點座標。&lt;/p&gt;
&lt;iframe width="854" height="480" src="https://www.youtube.com/embed/-pdUPiUBOfA" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen&gt;&lt;/iframe&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Pyslvs 開發進度 - 11/14</title><link href="http://project.mde.tw/blog/pyslvs-kai-fa-jin-du-1114.html" rel="alternate"></link><published>2017-11-14T21:00:00+08:00</published><updated>2017-11-14T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-11-14:blog/pyslvs-kai-fa-jin-du-1114.html</id><summary type="html">&lt;p&gt;Pyslvs v0.9 大更新進度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;版次管理功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分支&lt;/li&gt;
&lt;li&gt;資料庫連結機制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;預設範例&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;版次管理功能&lt;/h1&gt;
&lt;p&gt;今天完成並通過剩下的功能測試。&lt;/p&gt;
&lt;h2&gt;分支&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_11_14.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;上方的文字方塊顯示當前的分支名稱，名稱必須符合 Python 字串的 &lt;code&gt;.isidentifier()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;建立新分支時撞名，將會將此提交拉到對應的分支底下，注意是否會覆蓋舊有變更。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;「Checkout」按鈕可以載入選定分支的最新提交。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;「Delete」按鈕可以刪除選定分支的所有提交，但是不能刪除當前分支的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;資料庫連結機制&lt;/h2&gt;
&lt;p&gt;實體檔案資料庫將在必要時才會進行連接。所以檔案&lt;strong&gt;並不會鎖定&lt;/strong&gt;防止中途修改，因為 Python 要達成跨平台檔案鎖定功能必須額外使用平台模組。&lt;/p&gt;
&lt;p&gt;資料庫將在下列時機連接：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;儲存提交&lt;/li&gt;
&lt;li&gt;讀取、匯入&lt;/li&gt;
&lt;li&gt;刪除分支&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他執行序修改或刪除資料庫的狀況可能得設法應對。&lt;/p&gt;
&lt;h1&gt;預設範例&lt;/h1&gt;
&lt;p&gt;使用 dict 類型儲存範例名稱和表示式，可以透過 File 選單和 QInputDialog 載入了。之後將表示式和名稱存入 dict 物件即可。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Pyslvs 開發進度 - 11/12</title><link href="http://project.mde.tw/blog/pyslvs-kai-fa-jin-du-1112.html" rel="alternate"></link><published>2017-11-12T21:00:00+08:00</published><updated>2017-11-12T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-11-12:blog/pyslvs-kai-fa-jin-du-1112.html</id><summary type="html">&lt;p&gt;Pyslvs v0.9 大更新進度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;版次管理功能雛形&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;版次管理功能雛形&lt;/h1&gt;
&lt;p&gt;花了許久時間做出版次管理的介面，目前只有基本框架，分支功能還沒做好。&lt;/p&gt;
&lt;p&gt;Pyslvs 的檔案格式為副檔名為「.pyslvs」的 SQL 資料庫。&lt;/p&gt;
&lt;p&gt;下圖的 commit #1 只有增加主動桿，commit #2 完成四連桿。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_11_12.png" /&gt;&lt;/p&gt;
&lt;p&gt;在每次使用「Save」功能時，會視為一次「commit」，此時便會將&lt;strong&gt;機構狀態&lt;/strong&gt;、&lt;strong&gt;路徑數據&lt;/strong&gt;、&lt;strong&gt;尺寸合成結果&lt;/strong&gt;三筆資料轉為字串，透過壓縮成 byte 格式後存入資料庫的一行欄位中，三筆資料都經過測試可以回歸上一個版本。&lt;/p&gt;
&lt;p&gt;壓縮功能是透過 zlib 模組達成，使用 peewee 的 BlobField 格式，可以用來處理資料庫中的 list、dict：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
import zlib
compress = lambda obj: zlib.compress(bytes(repr(obj), encoding="utf8"), 5)
decompress = lambda obj: eval(zlib.decompress(obj).decode())
&lt;/pre&gt;

&lt;p&gt;每個 commit 還包含兩個外來鍵標註屬性，分別為「Author」和「Branch」標示作者和所屬分支。而 commit 的從屬關聯是參照「Previous」自我參照的外來鍵決定。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;畫面中最上方的表格為所有提交的清單，可以透過上方的搜尋列過濾「Description」和「Author」欄位的內容，取消搜尋只要清空搜尋列即可。&lt;/li&gt;
&lt;li&gt;若要載入過去的提交紀錄，可以按下表格左側的按鈕，不過需要注意是否有變更尚未儲存。&lt;/li&gt;
&lt;li&gt;進行提交時，必須輸入作者名稱（預設為 Anonymous）、說明文字，若是忘記輸入會彈出 QInputDialog 詢問。&lt;/li&gt;
&lt;li&gt;使用「Save」功能或「Commit」按鈕儲存；亦可使用「New Branch」按鈕將編輯的內容儲存到新分支中。&lt;/li&gt;
&lt;li&gt;使用「Stash」按鈕可以捨棄目前所有變更，相當於載入上次最新的提交。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前的基本功能載入都滿快的，除了連接到新資料庫的時候 peewee 會頓一下。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Double Ball Lifter 機構分析</title><link href="http://project.mde.tw/blog/double-ball-lifter-ji-gou-fen-xi.html" rel="alternate"></link><published>2017-11-04T21:00:00+08:00</published><updated>2017-11-04T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-11-04:blog/double-ball-lifter-ji-gou-fen-xi.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;分析接球機構&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;三角形法套入一般化鍊的要求&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;分析接球機構&lt;/h1&gt;
&lt;p&gt;Linkage 模擬影片：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://youtu.be/qwd55Ha8Kmk"&gt;Youtube&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;實體展示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://youtu.be/rShllGfOrqM"&gt;Youtube&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此機構是由兩個史蒂芬生 (Stephenson) 機構組成。&lt;/p&gt;
&lt;p&gt;獨立部分共為 6 個連桿、7 個接頭，4 個雙接頭連桿、2 個三接頭連桿。&lt;/p&gt;
&lt;p&gt;合體後變為 10 個連桿、13 個接頭，6 個雙接頭連桿、3 個三接頭連桿、1 個五接頭連桿。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_11_04.png" /&gt;&lt;/p&gt;
&lt;h1&gt;三角形法套入一般化鍊的要求&lt;/h1&gt;
&lt;p&gt;為使程式能夠藉由拓樸表示套入驗證函式，一般化鍊指定 ground 角色後，需要滿足一些條件。&lt;/p&gt;
&lt;p&gt;使用 PLAP、PLLP 三角形法的套入一般化鍊的要求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;已知 ground 桿件的所有接頭座標。&lt;/li&gt;
&lt;li&gt;已知所有連桿尺寸。&lt;/li&gt;
&lt;li&gt;已知輸入角與輸入接頭。&lt;/li&gt;
&lt;li&gt;輸入接頭必須在 ground 上。&lt;/li&gt;
&lt;li&gt;機構中只能有 JR 與 JP 接頭。&lt;/li&gt;
&lt;/ol&gt;</summary><category term="創意性機構設計"></category></entry><entry><title>創意性機構設計課堂筆記 - 10/23</title><link href="http://project.mde.tw/blog/chuang-yi-xing-ji-gou-she-ji-ke-tang-bi-ji-1023.html" rel="alternate"></link><published>2017-10-23T21:00:00+08:00</published><updated>2017-10-23T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-10-23:blog/chuang-yi-xing-ji-gou-she-ji-ke-tang-bi-ji-1023.html</id><summary type="html">&lt;p&gt;每星期創意性機構設計課程筆記整理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;機構分析&lt;/li&gt;
&lt;li&gt;數目合成&lt;/li&gt;
&lt;li&gt;類型合成&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;機構分析&lt;/h1&gt;
&lt;p&gt;找到了一個中國專利網站的平面連桿機構，進行一般化：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_10_23_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;連桿數為 9，有 7 個旋轉接頭與 4 個滑動接頭（這裡顏教授沒有使用 RP 接頭）。&lt;/p&gt;
&lt;p&gt;老師說這樣的數目很多組合，值得嘗試。&lt;/p&gt;
&lt;p&gt;今天想了一下拓樸構造，這方面的「同構」其實會移除所有接頭屬性，只看連桿連接構造。&lt;/p&gt;
&lt;h1&gt;數目合成&lt;/h1&gt;
&lt;p&gt;上次那個解題程式雖然比較有效率但是寫太死，因此不可能用在任意種類的機構。&lt;/p&gt;
&lt;p&gt;於是今天寫了個萬用的。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from itertools import product

class NumberSynthesis:
    def __init__(self, NL, NJ):
        self.NL = NL
        self.NJ = NJ

    @property
    def Mmax(self):
        if self.NL &lt;= self.NJ and self.NJ &lt;= (2*self.NL-3):
            return self.NJ - self.NL + 2
        elif (2*self.NL-3) &lt;= self.NJ and self.NJ &lt;= (self.NL*(self.NL-1)/2):
            return self.NL - 1
        else:
            raise ValueError("incorrect number.")

    @property
    def NLm(self):
        result = []
        correction = lambda l: sum((i+2)*l[i] for i in range(len(l))) == 2*self.NJ
        for symbols in product(range(self.NL+1), repeat=self.Mmax-2):
            NLMmax = self.NL - sum(symbols)
            answer = symbols+(NLMmax,)
            if correction(answer) and NLMmax&gt;=0:
                result.append(answer)
        return tuple(result)

if __name__=='__main__':
    a = NumberSynthesis(9, 11)
    print(a.NLm)
&lt;/pre&gt;

&lt;p&gt;找到的 Mmax 為 4，答案為：&lt;/p&gt;
&lt;pre&gt;
((5, 4, 0), (6, 2, 1), (7, 0, 2))
&lt;/pre&gt;

&lt;p&gt;使用的是 Python 內建迭代工具 itertools 模組的 product 函式，輸入「種類數」與「組合長度」，可以直接輸出一個 generator，用 tuple 回傳所有組合的結果。&lt;/p&gt;
&lt;p&gt;三個未知數可以先取前兩個未知數的組合，透過第一式找到第三個未知數的解。&lt;/p&gt;
&lt;div class="math"&gt;$$N_{L}(桿件數)=\sum_{m=2}^{m_{max}}N_{L_{m}}$$&lt;/div&gt;
&lt;p&gt;然後透過第二式與「第三個未知數為正數」驗正是否符合。&lt;/p&gt;
&lt;div class="math"&gt;$$2N_{J}(接頭數)=\sum_{m=2}^{m_{max}}mN_{L_{m}}$$&lt;/div&gt;
&lt;p&gt;輸出的結果即為符合連桿數與接頭數的條件下，雙接頭桿件、三接頭桿件、四接頭桿件分別的數量。&lt;/p&gt;
&lt;p&gt;再來是類型合成的部份。&lt;/p&gt;
&lt;h1&gt;類型合成&lt;/h1&gt;
&lt;p&gt;稍微為找到的機構畫了下樹狀圖：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_10_23_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;程式排列順序為左至右，接頭用完就換兄弟姊妹項；當此輩分用完時，才由最左的連桿繼續接。此種拓樸法理論上不會有先後問題。&lt;/p&gt;
&lt;p&gt;若不看數目合成的結果，此種數目其實只會辨認 5 個雙接頭與 4 個三接頭連桿。&lt;/p&gt;
&lt;p&gt;必須達成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;取光這 9 個連桿。&lt;/li&gt;
&lt;li&gt;接頭完全都有連接（遇到死點要自動作廢）。&lt;/li&gt;
&lt;li&gt;轉換成表示法判斷同構。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;拓樸可以使用主副 class 附加屬性達成，也會先寫一些小模型才會加入 Pyslvs。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每個數目合成的結果都可以做類型合成&lt;/strong&gt;，也是這裡最複雜，必須排除無用或重複的機構。&lt;/p&gt;
&lt;p&gt;然後圖譜目前找不到規律性，不知有何方法可以「畫」出來，不然現階段只能展示很難閱讀的樹狀結構。&lt;/p&gt;
&lt;p&gt;最後特殊化的部份就可能要人工手動或 AI 介入了，因為必須賦予連桿功能，例如迴歸輪系不可以在三角形迴路上。&lt;/p&gt;
&lt;p&gt;上次寫的拓樸法先拿掉，準備重寫。數目合成小模型加入 Pyslvs 的成效：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_10_23_03.png" /&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="創意性機構設計"></category></entry><entry><title>Pyslvs 開發進度 - 10/22</title><link href="http://project.mde.tw/blog/pyslvs-kai-fa-jin-du-1022.html" rel="alternate"></link><published>2017-10-22T21:00:00+08:00</published><updated>2017-10-22T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-10-22:blog/pyslvs-kai-fa-jin-du-1022.html</id><summary type="html">&lt;p&gt;Pyslvs v0.9 大更新進度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;機構分析功能&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;機構分析功能&lt;/h1&gt;
&lt;p&gt;新的「數目與類型合成」介面，會和「尺寸合成」一起載入了，雖然記憶體使用量有明顯提升，但是之前開關面板的方式很不人性化且容易出錯，所以就改掉了。&lt;/p&gt;
&lt;p&gt;將機構分解成一般化樣式，以利之後排列組合用。&lt;/p&gt;
&lt;p&gt;會先初步排除沒有作用的節點（如下圖的 Point2）。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_10_22.png" /&gt;&lt;/p&gt;
&lt;p&gt;上面兩行是表示式，不過發現使用 lark 模組取值不是那麼容易，反倒直接執行函式比較簡單。&lt;/p&gt;
&lt;p&gt;表示式運用的範圍可能要稍稍規劃一下，比如程式之間的轉出轉入；不然內部解析使用 class 會比較方便。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Pyslvs 開發進度 - 10/20</title><link href="http://project.mde.tw/blog/pyslvs-kai-fa-jin-du-1020.html" rel="alternate"></link><published>2017-10-20T21:00:00+08:00</published><updated>2017-10-20T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-10-20:blog/pyslvs-kai-fa-jin-du-1020.html</id><summary type="html">&lt;p&gt;Pyslvs v0.9 大更新進度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lark 基本用法&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;參考連結：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/erezsh/lark/blob/master/docs/json_tutorial.md"&gt;lark tutorial&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;lark 基本用法&lt;/h1&gt;
&lt;p&gt;利用 &lt;a href="https://github.com/erezsh/lark"&gt;lark&lt;/a&gt; 創造表示式語法。&lt;/p&gt;
&lt;p&gt;定義文法的結構是使用擴展巴科斯範式 (Extended Backus–Naur Form, EBNF)，巴科斯範式 (BNF) 即為 Qt 的輸入遮罩 (Mask) 所用的語法。&lt;/p&gt;
&lt;p&gt;lark 有提供基本的類型判斷，例如 NUMBER、WORD 等等，用 &lt;code&gt;%import&lt;/code&gt; 語法匯入即可。&lt;/p&gt;
&lt;p&gt;接著，使用冒號 &lt;code&gt;:&lt;/code&gt; 定義類似 class 的角色，使用 pip 符號 &lt;code&gt;|&lt;/code&gt; 可以同時聯集允許項目。這些類型只要名稱不衝突即可。&lt;/p&gt;
&lt;p&gt;若想讓該項目可以函式化，使用箭號 &lt;code&gt;-&amp;gt;&lt;/code&gt; 給定新名稱。&lt;/p&gt;
&lt;p&gt;以下是一個簡單表示 PMKS 機構的文法：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from lark import Lark

parser = Lark(
    '''
    type  : "R" | "P" | "PR"
    name  : WORD
    num   : NUMBER  -&gt; number
          | "-" num -&gt; neg

    joint    : "J[" [type "," point "," link ("," num)?] "]"
    link     : "L[" [name ("," name)*] "]"
    point    : "P[" [num  "," num] "]"
    mechanism: "M[" [joint ("," joint)*] "]"

    %import common.NUMBER
    %import common.WORD
    %import common.WS
    %ignore WS
    ''', start='mechanism'
)

expr = "M[J[R,P[0.0,0.0],L[ground,i]]]"
print(parser.parse(expr))
print(parser.parse(expr).pretty())
&lt;/pre&gt;

&lt;p&gt;上面 &lt;code&gt;%import common.WS&lt;/code&gt; 是匯入空白字元，&lt;code&gt;%ignore WS&lt;/code&gt; 代表解析上會忽略空白字元，斷句部分想加多少空白都可以。&lt;/p&gt;
&lt;p&gt;一個需要小心的地方是 &lt;code&gt;%import common.ESCAPED_STRING&lt;/code&gt; 代表 &lt;code&gt;"AAA"&lt;/code&gt;；&lt;code&gt;%import common.WORD&lt;/code&gt; 代表 &lt;code&gt;AAA&lt;/code&gt;，使用上要注意。&lt;/p&gt;
&lt;p&gt;另外 lark 無法解析時會 raise 錯誤，無論是文法還是輸入值，要注意不要導致程式出錯。&lt;/p&gt;
&lt;p&gt;使用 pretty 方法可印出：&lt;/p&gt;
&lt;pre&gt;
mechanism
  joint
    type
    point
      number    0.0
      number    0.0
    link
      name      ground
      name      i
&lt;/pre&gt;

&lt;p&gt;最後可以透過 InlineTransformer 類型來執行解析後函式化的指令。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Pyslvs 開發進度 - 10/19</title><link href="http://project.mde.tw/blog/pyslvs-kai-fa-jin-du-1019.html" rel="alternate"></link><published>2017-10-19T21:00:00+08:00</published><updated>2017-10-19T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-10-19:blog/pyslvs-kai-fa-jin-du-1019.html</id><summary type="html">&lt;p&gt;Pyslvs v0.9 大更新進度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;改換 peewee 讀寫檔案格式&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;參考連結：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://docs.peewee-orm.com/en/latest/peewee/transactions.html#transactions"&gt;peewee documentation: Transactions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;改換 peewee 讀寫檔案格式&lt;/h1&gt;
&lt;p&gt;後來發現 peewee 的操作還是比較「pythonic」 (笑)。&lt;/p&gt;
&lt;p&gt;改寫學弟的範例，進行讀寫、複製三種操作：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
import os
from datetime import date
from peewee import (
    SqliteDatabase,
    Model,
    CharField,
    DateField
)

fileName1 = "data.db"
db1 = SqliteDatabase(fileName1)
fileName2 = "data_copy.db"
db2 = SqliteDatabase(fileName2)

class BallBase(Model):
    name = CharField()
    date = DateField()
    speed = CharField()

class Ball1(BallBase):
    class Meta:
        database = db1

class Ball2(BallBase):
    class Meta:
        database = db2

if __name__=='__main__':
    fileExist = os.path.isfile(fileName1)
    db1.connect()
    db1.create_tables([Ball1], safe=True)
    if not fileExist:
        print("create")
        steven = Ball1(name="steven", date=date(2017, 9, 30), speed="3m/s")
        steven.save()
    else:
        print("read and copy")
        db2.connect()
        db2.create_tables([Ball2], safe=True)
        with db2.atomic():
            for ball in Ball1.select():
                try:
                    print(ball.name, ball.date, ball.speed)
                    steven = Ball2(name=ball.name, date=ball.date, speed=ball.speed)
                    steven.save()
                except:
                    db2.rollback()
        db2.close()
    db1.close()
&lt;/pre&gt;

&lt;p&gt;用繼承來改 connection 簡直方便多了。&lt;/p&gt;
&lt;p&gt;上面的程式執行時，若第一個資料庫 &lt;code&gt;data.db&lt;/code&gt; 不存在，會先建一個含有 &lt;code&gt;steven&lt;/code&gt; 名稱的資料。&lt;/p&gt;
&lt;p&gt;若已經存在，則會開啟第二個資料庫 &lt;code&gt;data_copy.db&lt;/code&gt;，將 &lt;code&gt;data.db&lt;/code&gt; 的 Ball1 類型選取後填入 Ball2 的類型中，存入 &lt;code&gt;data_copy.db&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;由於都繼承自 BallBase 類型，表單空位都相同。實際檢查，&lt;code&gt;data.db&lt;/code&gt; 和 &lt;code&gt;data_copy.db&lt;/code&gt; 的大小是一樣的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;with db2.atomic()&lt;/code&gt; 語句是建立一個 Transaction，類似 Qt Undo 功能的巨集，可以將多項改動儲存為一個檢查點，藉由 with 語句啟動 Transaction 紀錄，並在結束區塊時關閉它。使用 try 和 except 語句避免存入時發生錯誤，可用 rollback 方法退到上個檢查點。&lt;/p&gt;
&lt;p&gt;注意在配合 &lt;code&gt;with db2.atomic()&lt;/code&gt; 語句時，peewee 會自動開啟 Transaction、自動 commit 和自動在錯誤時啟動新的 Transaction，不用再使用 begin、commit 之類的 method；另外它也能寫成裝飾器 &lt;code&gt;@db2.atomic()&lt;/code&gt; 來自動處理 function 中的內容，而由於類似巨集的功能，&lt;strong&gt;這個語句是可以巢狀使用的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;另一個顯式 (Explicit) 的用法是直接使用 &lt;code&gt;with db.transaction()&lt;/code&gt; 語句：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
with db.transaction() as txn:
    User.create(username='whiskers')
    # Roll back changes, which removes "whiskers".
    txn.rollback()

    # Create a new row for "mr. whiskers" which will be implicitly committed
    # at the end of the `with` block.
    User.create(username='mr. whiskers')
&lt;/pre&gt;

&lt;p&gt;若怕中途出錯，可以開啟小的 Savepoints 來做紀錄：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
with db.transaction() as txn:
    with db.savepoint() as sp1:
        User.create(username='mickey')

    with db.savepoint() as sp2:
        User.create(username='zaizee')
        sp2.rollback()  # "zaizee" will not be saved, but "mickey" will be.
&lt;/pre&gt;

&lt;p&gt;傳統的方法是關掉自動 commit 模式：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
db.set_autocommit(False)
db.begin()
try:
    user.delete_instance(recursive=True)
except:
    db.rollback()
    raise
else:
    try:
        db.commit()
    except:
        db.rollback()
        raise
finally:
    db.set_autocommit(True)
&lt;/pre&gt;

&lt;p&gt;或是一開始就不使用：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
db = SqliteDatabase(':memory:', autocommit=False)

db.begin()
User.create(username='somebody')
db.commit()
&lt;/pre&gt;

&lt;p&gt;以上就是 peewee 手冊 Transactions 章節的全部內容，比起 Qt 還滿好理解的。&lt;/p&gt;
&lt;p&gt;當然 peewee 沒辦法靠 C++ 的 method 直接呈現為 QTableView 的欄位，不過將資料庫當作物件管理在開發上駕輕就熟，稍微寫下介面也不是什麼難事。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Pyslvs 開發進度 - 10/18</title><link href="http://project.mde.tw/blog/pyslvs-kai-fa-jin-du-1018.html" rel="alternate"></link><published>2017-10-18T21:00:00+08:00</published><updated>2017-10-18T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-10-18:blog/pyslvs-kai-fa-jin-du-1018.html</id><summary type="html">&lt;p&gt;Pyslvs v0.9 大更新進度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;測試使用 Qt 的 SQL Driver&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;測試使用 Qt 的 SQL Driver&lt;/h1&gt;
&lt;p&gt;摸索滿久的，幸好 Qt 幾乎所有 C++ 的指令都能直接拿來用。&lt;/p&gt;
&lt;p&gt;參考官方範例將 Database 儲存在記憶體（路徑位置為 &lt;code&gt;:memery:&lt;/code&gt;），並直接呈現在 QTableView 元件上：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://doc.qt.io/qt-5/qtsql-cachedtable-example.html"&gt;Qt Cached Table Example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;參考論壇問題將 Database 從記憶體複製到實體檔案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/9348659/how-to-copy-between-two-sqlite-memory-database"&gt;How to copy between two sqlite-memory-database?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;能將 Qt 範例提供的 Database 在啟動時顯示，並且複製到檔案中保存。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_10_18.png" /&gt;&lt;/p&gt;
&lt;p&gt;貌似 Qt 中支援直接使用 SQL 語法讀寫檔案或是用 method 定義，這過程中有學滿多指令的；還會繼續研究是否有較好的搭配法。&lt;/p&gt;
&lt;p&gt;明天會測試讀取部分。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Pyslvs 開發進度 - 10/15</title><link href="http://project.mde.tw/blog/pyslvs-kai-fa-jin-du-1015.html" rel="alternate"></link><published>2017-10-15T21:00:00+08:00</published><updated>2017-10-15T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-10-15:blog/pyslvs-kai-fa-jin-du-1015.html</id><summary type="html">&lt;p&gt;Pyslvs v0.9 大更新進度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自動旋轉介面修正&lt;/li&gt;
&lt;li&gt;路徑轉出 CSV 功能&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;自動旋轉介面修正&lt;/h1&gt;
&lt;p&gt;之前是用 QThread 驅動，佔用滿多資源的，而且會造成延遲。&lt;/p&gt;
&lt;p&gt;這次改用 QTimer 發信號驅動 QDial，由於是 C++ 的物件，時間還算準確（準度為 1 毫秒）。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_10_15_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;rpm 為 deg/s 的 1/6 倍，調整一下秒至毫秒即可。&lt;/p&gt;
&lt;p&gt;預設方向為順時針（負），旋轉時也可以調整。&lt;/p&gt;
&lt;h1&gt;路徑轉出 CSV 功能&lt;/h1&gt;
&lt;p&gt;在紀錄上用滑鼠雙擊，會顯示包含的點。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_10_15_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;用右鍵選單可以直接挑一個點的路徑，複製到剪貼簿。&lt;/p&gt;
&lt;p&gt;轉出後仍可以貼到演算法那裡當範本。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>PyQt5 完全入門</title><link href="http://project.mde.tw/blog/pyqt5-wan-quan-ru-men.html" rel="alternate"></link><published>2017-10-11T21:00:00+08:00</published><updated>2017-10-11T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-10-11:blog/pyqt5-wan-quan-ru-men.html</id><summary type="html">&lt;p&gt;快速熟悉 PyQt5 開發環境&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;入門：甚麼是 GUI？甚麼是跨平台？&lt;/li&gt;
&lt;li&gt;基礎概念：高階語言與低階語言&lt;/li&gt;
&lt;li&gt;架構：Qt 與 PyQt 與 PySide&lt;/li&gt;
&lt;li&gt;開發流程：Eric 6 IDE&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;入門：甚麼是 GUI？甚麼是跨平台？&lt;/h1&gt;
&lt;h2&gt;GUI&lt;/h2&gt;
&lt;p&gt;在電影裡才會出現、螢幕列滿密密麻麻符號的「文字模式」，似乎是某種不明覺厲、更為艱深的領域。&lt;/p&gt;
&lt;p&gt;如果您只是剛學習程式語言的開發者，或是僅使用電腦進行資料編排、文書處理、影音製作剪輯、偶爾打打遊戲的使用者，想必對現階段這個「&lt;strong&gt;移動滑鼠便可完成任務&lt;/strong&gt;」、「&lt;strong&gt;輕鬆收集一目瞭然的資訊&lt;/strong&gt;」的環境非常滿意。&lt;/p&gt;
&lt;p&gt;這個親切熟悉的溝通環境稱為&lt;strong&gt;圖形化使用者介面&lt;/strong&gt; (Graphical User Interface, GUI)，為任何以圖形方式下指令的廣泛稱呼，當然也包含自動提款機那種簡單的問答互動。&lt;/p&gt;
&lt;p&gt;儘管作業系統已經將任何處理程序包裝成圖形樣式，還是有方法透過文字命令傳達操作，稱為&lt;strong&gt;命令列介面&lt;/strong&gt; (Command-Line Interface, CLI)。&lt;/p&gt;
&lt;p&gt;這兩者並沒有直接的優劣（無論功能與性能），因為一切取決於該程式的設計者如何設計，而且&lt;strong&gt;這兩者是可以同時並存的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;當然也可以在命令提示字元用 Firefox 瀏覽器開兩個網站：&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
firefox www.mozilla.com developer.mozilla.org
&lt;/pre&gt;

&lt;h2&gt;跨平台&lt;/h2&gt;
&lt;p&gt;如果您是在 Windows 作業系統，簡單比較一下 Linux 的操作情況即會發現許多差異：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目錄使用反斜線 &lt;code&gt;\&lt;/code&gt; 而非斜線 &lt;code&gt;/&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;檔案名稱沒有分大小寫，而 Linux 有。&lt;/li&gt;
&lt;li&gt;使用登錄檔管理安裝程式，而非由套件庫集中提供。&lt;/li&gt;
&lt;li&gt;Linux 怎麼會一直需要權限？&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這些差異足以讓程式設計師傷腦筋了，當然也早有核心上的應對方法，使不同作業系統的程式跑起來功能不會差太多，這種模式即稱為跨平台 (Cross-platform)。&lt;/p&gt;
&lt;h1&gt;基礎概念：高階語言與低階語言&lt;/h1&gt;
&lt;p&gt;羅馬不是一天造成的，現在出現的資訊，也不是馬上就蹦出來的。&lt;/p&gt;
&lt;p&gt;這些「精巧」的電子零件，是透過輸入 010101，稱為「機器碼 (Machine code)」的指令才能運作的。電子裝置可以直接辨識與執行機器碼的指令，而且不同的裝置使用的機器碼語言是不一樣的。&lt;/p&gt;
&lt;p&gt;想當然爾，人類不可能一直查詢機器碼，再輸入給電子零件，因此才產生「程式 (Program)」。&lt;/p&gt;
&lt;p&gt;組合語言 (Combination language) 是一種用於可編成組件的程式語言，一種組合語言專用於某種電腦的系統結構。換句話說，組合語言僅次於機器碼，可以以較簡單的方式命令，而且開發人員可以輕易辨別位址與數值。&lt;/p&gt;
&lt;p&gt;大名鼎鼎的 C 語言主要用於不同平台的作業系統，根據不同平台的特性，C 語言透過「編譯 (Compile)」這個流程，將程式碼轉為機器碼執行。不同作業系統存在相應的「編譯器 (Compiler)」，對應到硬體的機器碼執行，而某些編譯器正是組合語言撰寫的。&lt;/p&gt;
&lt;p&gt;Python 語言是透過 C 語言編寫的直譯器進行轉譯與執行，因此不須經過編譯動作，甚至可以藉由伺服器在網路端執行，將結果回傳給客戶端。&lt;/p&gt;
&lt;p&gt;以上舉的範例，是不是看出了程式語言的相依性？其中接近硬體層面的程式語言稱為&lt;strong&gt;低階語言&lt;/strong&gt;；依靠越多「後台」處理的程式語言，稱為&lt;strong&gt;高階語言&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;注意，這兩個稱呼是&lt;strong&gt;相對性的&lt;/strong&gt;，並非絕對為哪種分類，如 C 語言相對於 Python 為低階語言；相對於組合語言為高階語言。&lt;/p&gt;
&lt;p&gt;而這兩個分類並沒有優劣之分，各自有優缺點。&lt;/p&gt;
&lt;p&gt;低階語言有以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;處理範圍廣，而且可以直接影響運作效能。&lt;/li&gt;
&lt;li&gt;較不易閱讀與開發，一件工作必須寫得較為詳細。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;高階語言則反之：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;處理範圍和運作效能端看基礎架構而定，大量運算時效能不如低階語言。&lt;/li&gt;
&lt;li&gt;簡單且優化過的內建命令，往往會有簡單的表示法與程式庫、模組。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;普遍初學程式語言由需求下手，如果從事學術運算的模型建立，可以從 Python 下手；從事 Arduino 控制器的開發，就會著重於 C 語言的函式庫。不同層級都會有對應的技術可以學習，學習資訊領域「多而不精」反而模糊了自己的立足點。&lt;/p&gt;
&lt;h1&gt;架構：Qt 與 PyQt 與 PySide&lt;/h1&gt;
&lt;h2&gt;Qt&lt;/h2&gt;
&lt;p&gt;大部分所見的圖形化介面程式語言都是由有物件導向的程式語言開發的，例如 C++、Java、C#、Python 等。&lt;/p&gt;
&lt;p&gt;直接使用 C++ 語言「寫出」圖形介面是一件滿費心的差事，因此有滿多圖形介面的函式庫 (library) 可以使用，例如 Qt、Tk、wxWidgets、GTK+ 等。使用簡單的函式 (function) 就可創造視窗介面，並且有很多函式庫盡力克服「跨平台」的障礙。由於可以包含的部件極多，稱得上圖形介面「框架 (framework)」一詞。&lt;/p&gt;
&lt;p&gt;其中 Qt 是由 Qt Project 開發。Qt 支援平台種類眾多，除了常見的 Windows、Linux、Mac 以外，還有非 X Window System 的作業系統。授權方面也十分自由，採用 GNU 較寬鬆通用公共許可證 (GNU Lesser General Public License, LGPL)、GNU 通用公共許可證 (GNU General Public License, GPL)、商業授權三種模式，可以讓開發者應需求選擇。&lt;/p&gt;
&lt;p&gt;Qt 程式庫中甚至支援開發圖形介面的「周邊」功能，如網路通訊、OpenGL、OpenVG、SQL 與 XML 直譯器、圖片格式轉檔、Linux 的輸入法開發、瀏覽器引擎（使用 Google Chromium）、各式圖表等。&lt;/p&gt;
&lt;p&gt;現在 Qt 的版本來到了第 5 版，而且每 6 個月仍再持續提出更新計畫，在自由軟體產業具有很高的影響力。&lt;/p&gt;
&lt;h2&gt;PyQt&lt;/h2&gt;
&lt;p&gt;由於 Qt 的功能極為強大，英國的 Riverbank Computing 公司率先為其撰寫 Python 語言的套件，甚至開發了 SIP 這套工具將 C 與 C++ 程式庫包裝為 Python 套件。&lt;/p&gt;
&lt;p&gt;PyQt 幾乎支援 Qt 大部分的功能，並且將較專門的功能另外分成 PyQt Chart（2D 圖表）、PyQt Data Visualization（3D 圖表）、PyQt Purchasing（應用程式購買功能）。&lt;/p&gt;
&lt;p&gt;另外 QScintilla 是一個將 Scintilla 連結至 PyQt 的套件（在 C++ 可以直接用 Qt 和 Scintilla 即可），用途是辨識文字中的程式語言，以亮顯 (highlight) 的方式呈現，可以用作程式語言的辨識功能。&lt;/p&gt;
&lt;p&gt;PyQt 的版本與 Qt 相同（除了小版號），採用 GPL 和商業授權。需要注意的是，若作為軟體釋出，沒有商業授權是需要&lt;strong&gt;公開原始碼&lt;/strong&gt;的。&lt;/p&gt;
&lt;h2&gt;PySide&lt;/h2&gt;
&lt;p&gt;繼 PyQt 釋出後， Qt 官方製作了 PySide 專案，目的是讓 Qt 到 Python 之間的套件使用 LGPL 來授權。&lt;/p&gt;
&lt;p&gt;然而 PySide 的開發跟不上 Qt 的開發（因為並非使用 SIP 工具），因此在 Qt 從第 4 版到第 5 版時，似乎就沒有提供支援了。&lt;/p&gt;
&lt;p&gt;後來 PySide 2 宣布開始開發，並且放棄 Qt 5 較前面的進度，選擇以 5.6 和一個最新版進行測試（因為 5.7 版是一個分水嶺，加入之前提到 QtChart 和 Data Visualization 的功能），安裝上仍有不便之處。&lt;/p&gt;
&lt;h1&gt;開發流程：Eric 6 IDE&lt;/h1&gt;
&lt;p&gt;Eric 做為一個專門以 PyQt 開發的環境，幾乎全部用到 Riverbank Computing 公司的產品。&lt;/p&gt;
&lt;p&gt;透過 QtDesigner 設計類似 XML 的 UI 檔案，轉換成 Python 腳本，可以直接以雙重繼承的方式獲得 Qt 的類型與 UI 的介面，使用上十分方便。&lt;/p&gt;
&lt;p&gt;圖片也是透過類似 XML 的資源檔案（QRC），轉換成二進位的字串，直接變成 QPixmap 的格式。&lt;/p&gt;
&lt;p&gt;Python 語言的 Qt 程式私人開發可以以 PyQt 為主，若是有商用需求，必須購買 PyQt 授權或是轉換成 PySide。&lt;/p&gt;</summary><category term="Python3"></category><category term="PyQt5"></category><category term="Tutorial Book"></category></entry><entry><title>Pyslvs 開發進度 - 10/10</title><link href="http://project.mde.tw/blog/pyslvs-kai-fa-jin-du-1010.html" rel="alternate"></link><published>2017-10-10T21:00:00+08:00</published><updated>2017-10-10T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-10-10:blog/pyslvs-kai-fa-jin-du-1010.html</id><summary type="html">&lt;p&gt;Pyslvs v0.9 大更新進度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Version 0.9 bata 1 released&lt;/li&gt;
&lt;li&gt;Bata 2 目標&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Version 0.9 bata 1 released&lt;/h1&gt;
&lt;p&gt;先釋出第一階段成果。&lt;/p&gt;
&lt;p&gt;功能測試版。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PMKS 表示式基本功能（只有旋轉接頭）。&lt;/li&gt;
&lt;li&gt;新的畫布選取模式。&lt;/li&gt;
&lt;li&gt;輸入面板功能。&lt;/li&gt;
&lt;li&gt;先前版本的尺寸合成面板功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前幾天的進度是將尺寸合成面板功能改進後連接到主視窗上。&lt;/p&gt;
&lt;p&gt;很多舊系統都砍掉改良了，Windows 平台測試版的大小為 35.3 MB，較上一版 v0.8.1 的 40.3 MB 縮小一些。&lt;/p&gt;
&lt;p&gt;Ubuntu 平台的 AppImage 則處於 180 MB 之間。&lt;/p&gt;
&lt;h1&gt;Bata 2 目標&lt;/h1&gt;
&lt;p&gt;預計跟進目標：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支援滑塊的兩個接頭 P、RP。&lt;/li&gt;
&lt;li&gt;範例翻新，以 PMKS 網址的方式儲存，彈出式視窗的方式匯入工作簿。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;現在指導學弟如何使用 peewee 建立資料庫了，如果上述兩項花時不多，可以規劃新的檔案格式。&lt;/p&gt;
&lt;p&gt;最近會寫一篇小的 PyQt 觀念教學網誌，看看可否幫助大一大二了解 PyQt 開發模式。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Pyslvs 開發進度 - 10/07</title><link href="http://project.mde.tw/blog/pyslvs-kai-fa-jin-du-1007.html" rel="alternate"></link><published>2017-10-07T21:00:00+08:00</published><updated>2017-10-07T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-10-07:blog/pyslvs-kai-fa-jin-du-1007.html</id><summary type="html">&lt;p&gt;Pyslvs v0.9 大更新進度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加回自動旋轉鈕&lt;/li&gt;
&lt;li&gt;自由移動支援多點&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;加回自動旋轉鈕&lt;/h1&gt;
&lt;p&gt;改良舊的 QThread，讓它掛在 main window 底下，不用因為面板關閉而刪除，執行上似乎有比以前順暢。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_10_07_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;途中遇到修改動作會自動中斷。&lt;/p&gt;
&lt;h1&gt;自由移動支援多點&lt;/h1&gt;
&lt;p&gt;支援框選多個點拖移。&lt;/p&gt;
&lt;p&gt;為避免此命令分散，造成復原功能困擾，包裝到一個巨集中。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_10_07_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;這邊重寫一下公式，看以後是否有 CAD 互動的需求。&lt;/p&gt;
&lt;p&gt;滑鼠滾輪平移檢視公式：&lt;/p&gt;
&lt;div class="math"&gt;$$x_{Origin (dragged)}=x_{Mouse (dragged)}-(x_{Mouse (pressed)}-x_{Origin (pressed)})$$&lt;/div&gt;
&lt;div class="math"&gt;$$y_{Origin (dragged)}=y_{Mouse (dragged)}-(y_{Mouse (pressed)}-y_{Origin (pressed)})$$&lt;/div&gt;
&lt;p&gt;&lt;em&gt;註：在 Widget 的座標系更改原點位置，以達成畫布平移。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;拉動&lt;strong&gt;滑鼠&lt;/strong&gt;同時拉動&lt;strong&gt;相對點&lt;/strong&gt;的座標：&lt;/p&gt;
&lt;div class="math"&gt;$$x_{point (dragged)}=\frac{(x_{Mouse (dragged)}-x_{Origin}-(x_{Mouse (pressed)}-x_{Origin})}{f_{zoom}}+x_{point (Origin)}$$&lt;/div&gt;
&lt;div class="math"&gt;$$y_{point (dragged)}=\frac{(y_{Mouse (dragged)}-y_{Origin}-(y_{Mouse (pressed)}-y_{Origin})}{f_{zoom}}+y_{point (Origin)}$$&lt;/div&gt;
&lt;p&gt;&lt;em&gt;註：取得滑鼠移動增量套用縮放係數，加上該點原始座標，以獲得新的點座標。&lt;/em&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Pyslvs 開發進度 - 10/06</title><link href="http://project.mde.tw/blog/pyslvs-kai-fa-jin-du-1006.html" rel="alternate"></link><published>2017-10-06T21:00:00+08:00</published><updated>2017-10-06T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-10-06:blog/pyslvs-kai-fa-jin-du-1006.html</id><summary type="html">&lt;p&gt;Pyslvs v0.9 大更新進度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路徑記錄功能&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;路徑記錄功能&lt;/h1&gt;
&lt;p&gt;這次的路徑紀錄功能類似 Solvespace 單純儲存移動路徑的概念。&lt;/p&gt;
&lt;p&gt;使用者可以修改尺寸後，檢查路徑是否滿足條件。&lt;/p&gt;
&lt;iframe width="854" height="480" src="https://www.youtube.com/embed/vlxy5DFCEE0" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;錄影時的功能還有點陽春，自動旋轉的那個鈕還沒做好。&lt;/p&gt;
&lt;p&gt;之後會加上輸出 csv、分開點檢視的功能。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Python 3 類型入門</title><link href="http://project.mde.tw/blog/python-3-lei-xing-ru-men.html" rel="alternate"></link><published>2017-10-05T21:00:00+08:00</published><updated>2017-10-05T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-10-05:blog/python-3-lei-xing-ru-men.html</id><summary type="html">&lt;p&gt;快速上手 Python 3 常用類型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Build-in Type 內建類型&lt;/li&gt;
&lt;li&gt;Numeric 數值&lt;/li&gt;
&lt;li&gt;String 字串&lt;/li&gt;
&lt;li&gt;Container 容器&lt;/li&gt;
&lt;li&gt;Function 函式&lt;/li&gt;
&lt;li&gt;Name 名稱&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Build-in Type 內建類型&lt;/h1&gt;
&lt;p&gt;本節講述如何在 Python 中呈現與處理您的資料格式。&lt;/p&gt;
&lt;p&gt;最常應用的類型為數值 (Numeric)、字串 (String) 與容器 (Container)。&lt;/p&gt;
&lt;p&gt;前兩者用於儲存您的資料；容器可以編排資料，以供檢索與比較。&lt;/p&gt;
&lt;p&gt;數據處理上，使用名稱 (Name) 與運算子 (Operator) 可以達成單一數據的處理。&lt;/p&gt;
&lt;p&gt;名稱可以在程式中代表數據的用途；運算子則是以簡單明瞭的形式做比較與運算。&lt;/p&gt;
&lt;p&gt;內建類型可以透過如下方式將相近類型轉換，有類似函式的功能。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
float(500)
tuple([0, 1, 2])
&lt;/pre&gt;

&lt;p&gt;另外，可以通過 &lt;a href="https://docs.python.org/3/library/functions.html#type"&gt;type()&lt;/a&gt; 函式來檢查值的類型。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
print(type(20)==int) #True
&lt;/pre&gt;

&lt;p&gt;Python 中，數值和字串有以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是不會改變的，僅僅是作為數據的呈現。&lt;/li&gt;
&lt;li&gt;相同的定值儲存在相同的記憶體位址。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Numeric 數值&lt;/h1&gt;
&lt;p&gt;數值可以透過算術運算子進行計算。&lt;/p&gt;
&lt;h2&gt;布林值 &lt;code&gt;bool&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;作為定義某件事的正確性，關鍵字 True 和 False 可以直接代表一個布林值。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
print(25 &gt; 20) #True
&lt;/pre&gt;

&lt;p&gt;另外 True 在數字運算中可以當成 1，False 可以當成 0。&lt;/p&gt;
&lt;h2&gt;整數 &lt;code&gt;int&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;定義整數數字，例如重複次數、清單長度等等。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
print(len([0, 1, 2, 3, 4])) #5
&lt;/pre&gt;

&lt;p&gt;若兩整數進行運算時（除法必須可以整除），會優先使用整數類型回傳結果。&lt;/p&gt;
&lt;p&gt;整數還有其他表示法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二進位 b&lt;/li&gt;
&lt;li&gt;八進位 o&lt;/li&gt;
&lt;li&gt;十六進位 x&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="brush: python"&gt;
print(0b101) #5
print(0o20) #16
print(0x20) #32
&lt;/pre&gt;

&lt;p&gt;即使使用其他種表示法，程式端還是以十進位為主，運算以二進位為主。&lt;/p&gt;
&lt;h2&gt;浮點數 &lt;code&gt;float&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;定義小數數字，準確值可達 16 位數。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
print(1/10) #0.1
&lt;/pre&gt;

&lt;p&gt;在運算中可以混用整數來與浮點數做運算，但是注意不要把浮點數用在整數的需求上，即使它的尾數為 0。&lt;/p&gt;
&lt;p&gt;透過兩種方法可以將浮點數轉換成整數：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 int 類型，會直接移除小數位。&lt;/li&gt;
&lt;li&gt;使用 &lt;a href="https://docs.python.org/3/library/functions.html#round"&gt;round()&lt;/a&gt; 函式，四捨五入到指定位數。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="brush: python"&gt;
print(int(20.52)) #20
print(round(20.52)) #21
print(round(20.52, 1)) #20.5
&lt;/pre&gt;

&lt;p&gt;浮點數還有其他種表示法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;科學記號 e&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="brush: python"&gt;
print(6.5e5) #650000.0
&lt;/pre&gt;

&lt;h2&gt;複數 &lt;code&gt;complex&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;定義虛數，同時還有包含實數位。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
print((20+6j)+(8-9j)) #(28-3j)
&lt;/pre&gt;

&lt;p&gt;複數沒辦法直接以套用類型的方式轉回 float、int 類型，可以改用以下方式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;取出實部。&lt;/li&gt;
&lt;li&gt;取出虛部。&lt;/li&gt;
&lt;li&gt;計算絕對值。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="brush: python"&gt;
print((4+3j).real) #4.0
print((4+3j).imag) #3.0
print(abs(4+3j)) #5.0
&lt;/pre&gt;

&lt;h1&gt;String 字串&lt;/h1&gt;
&lt;p&gt;字串用於儲存註記與符號，介於數值與容器之間，保有雙方某些特性。&lt;/p&gt;
&lt;p&gt;字串可視為多個符號串連在一起的容器，可供檢索與比較。&lt;/p&gt;
&lt;p&gt;但是事實上字串的「同一句話」是存於同個記憶體位址的，而且也只能「裝載」其他字串，這方面與數值無異。&lt;/p&gt;
&lt;p&gt;使用兩個雙括弧 &lt;code&gt;"&lt;/code&gt; 和 &lt;code&gt;'&lt;/code&gt; 單括弧可以將符號包成字串，使用上沒有分別，不過建議包含空白的字串使用雙括弧。&lt;/p&gt;
&lt;p&gt;使用 &lt;a href=""&gt;str()&lt;/a&gt; 類型函式可以將其他類型轉為字串。&lt;/p&gt;
&lt;p&gt;字串有以下幾個常用操作，注意常用的操作都會回傳新的字串。&lt;/p&gt;
&lt;h2&gt;大小寫轉換 &lt;code&gt;upper&lt;/code&gt; &lt;code&gt;lower&lt;/code&gt; &lt;code&gt;capitalize&lt;/code&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;全部小寫 upper&lt;/li&gt;
&lt;li&gt;全部小寫 lower&lt;/li&gt;
&lt;li&gt;字首大寫 capitalize&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="brush: python"&gt;
print("abc".upper()) #ABC
print("ABC".lower()) #abc
print("aBc".capitalize()) #Abc
&lt;/pre&gt;

&lt;h2&gt;結合與複製&lt;/h2&gt;
&lt;p&gt;使用一些易懂的運算子產生字串。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
print("-"*7) #-------
print('a' + 'b' + 'c') #abc
&lt;/pre&gt;

&lt;h2&gt;取代 &lt;code&gt;replace&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;將指定的字元取代成輸入字元。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
print("get changed".replace('ged', 'ce')) #get chance
&lt;/pre&gt;

&lt;h2&gt;分割 &lt;code&gt;split&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;使用輸入字元分割成 list 類型。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
print("a,b,c".split(',')) #['a', 'b', 'c']
&lt;/pre&gt;

&lt;h2&gt;格式操作 &lt;code&gt;format&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;透過轉換的方式填入非字串物件，可以參考&lt;a href="https://docs.python.org/3/library/string.html#formatstrings"&gt;格式語法&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;使用大括弧填入輸入的項目，若要使用大括弧符號，可以使用兩個代表（&lt;code&gt;{{}}&lt;/code&gt;）。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
print("{} %".format(50)) #50 %
&lt;/pre&gt;

&lt;p&gt;使用冒號可以規定代數以及格式。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
print("{percent:.02f} %".format(percent=50)) #50.00 %
&lt;/pre&gt;

&lt;p&gt;在 Python 3.6 之後的版本可以簡化成這樣：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
percent = 50
print(f"{percent:.02f} %") #50.00 %
&lt;/pre&gt;

&lt;p&gt;使用 &lt;a href="https://docs.python.org/3/library/stdtypes.html#str.format"&gt;format()&lt;/a&gt; 比直接使用 + 運算子節省記憶體空間，因為不用儲存零碎的字串片段。&lt;/p&gt;
&lt;h1&gt;Container 容器&lt;/h1&gt;
&lt;p&gt;容器專門供應記憶體位址，可以將上面提供的兩大數據類型儲存到裡面，並且根據不同容器能做不同需求的操作。&lt;/p&gt;
&lt;h2&gt;清單 &lt;code&gt;list&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;清單為&lt;strong&gt;有序&lt;/strong&gt;動態容器，使用序號檢索與存取，直接寫法是使用中括弧 &lt;code&gt;[]&lt;/code&gt;。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
L = ['A', 'b', 2, 3]
print(L[0]) #A
&lt;/pre&gt;

&lt;p&gt;加入至清單可以使用三種方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加到尾部 append()&lt;/li&gt;
&lt;li&gt;插入到指定位置 insert()&lt;/li&gt;
&lt;li&gt;算術運算子 +、* 和指派運算子 +=&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="brush: python"&gt;
L = [8, 9]
L.append(7) #L = [8, 9, 7]
L.insert(1, 'b') #L = [8, 'b', 9, 7]
L += [2, 5, 6] #L = [8, 'b', 9, 7, 2, 5, 6]
&lt;/pre&gt;

&lt;p&gt;移除有三種方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;移除尾部或指定序號並回傳 pop()&lt;/li&gt;
&lt;li&gt;尋找並移除 remove()（若找不到會發出錯誤）&lt;/li&gt;
&lt;li&gt;刪除關鍵字 &lt;code&gt;del&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="brush: python"&gt;
L = ['a', 'b', 'c', 'd']
L.pop(1) #L = ['a', 'c', 'd']
L.remove('c') #L = ['a', 'd']
del L[-1] #L = ['a']
&lt;/pre&gt;

&lt;p&gt;取得片段有序清單可以使用分割器 (Splitter)，這個動作將會複製一部分的清單內容，使其變成片段的副本。&lt;/p&gt;
&lt;p&gt;分割器與檢索符號類似，頭尾使用冒號 &lt;code&gt;:&lt;/code&gt; 判斷。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
L = ['a', 'b', 'c', 'd']
L1 = L[:2] #L1 = ['a', 'b']
L2 = L[:]
print(L2 is L) #False
&lt;/pre&gt;

&lt;h2&gt;元組 &lt;code&gt;tuple&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;元組為&lt;strong&gt;有序&lt;/strong&gt;靜態容器，僅供於檢索，直接寫法是使用小括弧 &lt;code&gt;()&lt;/code&gt;，只有一項時必須加上一個逗號 &lt;code&gt;,&lt;/code&gt;。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
T = ('A',)
print(T[0]) #A
&lt;/pre&gt;

&lt;p&gt;由於元組不可修改，因此結構會比 list 節省硬體資源。&lt;/p&gt;
&lt;p&gt;另外元組也能夠使用算術運算子 +、* 和分割器。&lt;/p&gt;
&lt;h2&gt;字典 &lt;code&gt;dict&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;字典為&lt;strong&gt;無序&lt;/strong&gt;動態容器，使用鍵值 (Key value) 檢索與存取，直接寫法是使用大括弧 &lt;code&gt;{}&lt;/code&gt;，並且使用冒號 &lt;code&gt;:&lt;/code&gt; 結合鍵值。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
D = {'a':0, 'b':3, 'c':6}
print(D['c']) #6
&lt;/pre&gt;

&lt;p&gt;字典可以透過指派運算子 = 來增加新值，用刪除關鍵字 &lt;code&gt;del&lt;/code&gt; 刪除一組鍵值。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
D = {'a':0, 'b':1, 'c':2}
D['d'] = 3 #D = {'a':0, 'b':1, 'c':2, 'd':3}
del D['b'] #D = {'a':0, 'c':2, 'd':3}
&lt;/pre&gt;

&lt;p&gt;可以用 keys()、values() 和 items() 方法來取得或轉換所有鍵值，不過取出來為記憶體位置的順序，可以使用 &lt;a href="https://docs.python.org/3/library/functions.html#sorted"&gt;sorted()&lt;/a&gt; 函式排序。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
D = {'a':0, 'b':1, 'c':2}
K = list(D.keys()) #K = ['a', 'b', 'c']
V = list(D.values()) #V = [0, 1, 2]
D = [(k, v) for k, v in D.items()] #D = [('a', 0), ('b', 1), ('c', 2)]
&lt;/pre&gt;

&lt;h2&gt;集合 &lt;code&gt;set&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;集合為&lt;strong&gt;無序&lt;/strong&gt;動態容器，無法檢索或是存取，但是不能包含重複項目，用於篩選內容。&lt;/p&gt;
&lt;p&gt;集合的直接寫法是使用大括弧 &lt;code&gt;{}&lt;/code&gt;，但是空集合是寫作 &lt;code&gt;set()&lt;/code&gt;，以免認為是字典。&lt;/p&gt;
&lt;p&gt;集合可以透過位元指派運算子操作：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
S = {1, 2, 3}
S |= {2, 3, 6} #S = {1, 2, 3, 6}
&lt;/pre&gt;

&lt;p&gt;透過排序值將集合轉為 list。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
S = {1, 4, 3}
S = sorted(S) #S = [1, 3, 4]
&lt;/pre&gt;

&lt;h1&gt;Function 函式&lt;/h1&gt;
&lt;p&gt;一般的函式也是物件，可以被傳遞或是儲存至容器。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def plus(x, y):
    return x + y

print(plus(10, 20)) #30
&lt;/pre&gt;

&lt;p&gt;若是只做簡單的計算，也能使用 lambda 關鍵字建立函式物件。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
plus = lambda x, y: x + y

print(plus(10, 20)) #30
&lt;/pre&gt;

&lt;h1&gt;Name 名稱&lt;/h1&gt;
&lt;p&gt;名稱 (Name) 是 Python 中的專有名詞，可視為&lt;strong&gt;代名詞&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;名稱相當於綽號，可以將數據取名字，以供 Python 檢索這個數據的記憶體位址。&lt;/p&gt;
&lt;p&gt;透過&lt;strong&gt;指派運算子&lt;/strong&gt;，可以將一個數據命上喜歡的名字。&lt;/p&gt;
&lt;p&gt;命名之後，名稱可以代表數據進行運算。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
a = 25
b = 20
c = a - b
print(c) #5
&lt;/pre&gt;

&lt;p&gt;命名規則如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;區分大小寫。&lt;/li&gt;
&lt;li&gt;不能包含空白。&lt;/li&gt;
&lt;li&gt;不能包含運算子。&lt;/li&gt;
&lt;li&gt;不能以數字為首。&lt;/li&gt;
&lt;li&gt;不要與關鍵字衝突。&lt;/li&gt;
&lt;li&gt;盡量避開內建類型函式的名稱。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;若名稱想使用多個單字命名，以下的命名法都是正確的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CNC&lt;/li&gt;
&lt;li&gt;RedApple&lt;/li&gt;
&lt;li&gt;removedLists&lt;/li&gt;
&lt;li&gt;count_down&lt;/li&gt;
&lt;li&gt;part1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Python 中可以覆蓋指派過的名稱，&lt;strong&gt;被覆蓋的數據不會刪除&lt;/strong&gt;。因此在覆蓋前若是想存取舊的數據，應該為它找一個新的名稱，或是放在&lt;strong&gt;可以檢索到的地方&lt;/strong&gt;，例如容器中。&lt;/p&gt;</summary><category term="Python3"></category><category term="Tutorial Book"></category></entry><entry><title>Pyslvs 開發進度 - 10/04</title><link href="http://project.mde.tw/blog/pyslvs-kai-fa-jin-du-1004.html" rel="alternate"></link><published>2017-10-04T21:00:00+08:00</published><updated>2017-10-04T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-10-04:blog/pyslvs-kai-fa-jin-du-1004.html</id><summary type="html">&lt;p&gt;Pyslvs v0.9 大更新進度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;批次刪除 / 鎖定點功能&lt;/li&gt;
&lt;li&gt;自由移動模式&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;批次刪除 / 鎖定點功能&lt;/h1&gt;
&lt;p&gt;選取多個點的時候可以一起删除了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_10_04_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;進行 Undo 時會依照選取的順序復原。&lt;/p&gt;
&lt;p&gt;鎖定功能也雷同，多選時若是固定狀態不一致，將會優先將所有點與 ground 連接。&lt;/p&gt;
&lt;p&gt;依賴於復原重做功能，所有的對話框都已移除。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;註：復原重做功能有加入復原上限的設定了，預設為 16 次。&lt;/em&gt;&lt;/p&gt;
&lt;h1&gt;自由移動模式&lt;/h1&gt;
&lt;p&gt;新的修改方式，可以更快對機構進行編輯。&lt;/p&gt;
&lt;p&gt;按下右下角的鎖頭啟動自由移動模式 (Free move mode)，畫布會出現紫色外框。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_10_04_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;接著可以&lt;strong&gt;直接&lt;/strong&gt;拖動畫布上的點進行修改，放開滑鼠即可完成編輯。&lt;/p&gt;
&lt;p&gt;舊的批次移動功能已移除。&lt;/p&gt;
&lt;p&gt;這個操作和 XY 軸畫布是參考自 PMKS 的。&lt;/p&gt;
&lt;p&gt;^_^&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Pyslvs 開發進度 - 10/03</title><link href="http://project.mde.tw/blog/pyslvs-kai-fa-jin-du-1003.html" rel="alternate"></link><published>2017-10-03T21:00:00+08:00</published><updated>2017-10-03T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-10-03:blog/pyslvs-kai-fa-jin-du-1003.html</id><summary type="html">&lt;p&gt;Pyslvs v0.9 大更新進度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Release ground / Constrain link 功能&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Release ground / Constrain link 功能&lt;/h1&gt;
&lt;p&gt;突發奇想製作轉換運動鍊 (Kinematic chain) 與機構的功能。&lt;/p&gt;
&lt;p&gt;該功能可以將固定桿 ground 釋放 (Release) 成桿件，或將其中一支桿件約束 (Constrain) 成固定桿。&lt;/p&gt;
&lt;p&gt;在 ground 上按下右鍵，選擇 Release。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_10_03_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;其他桿件則是有 Constrain 的選項。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_10_03_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;用一個簡單的瓦特六連桿轉換成瓦特一型 (Watt-I) 當作範例。&lt;/p&gt;
&lt;p&gt;選擇下圖的 link_1，轉換成機架。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_10_03_03.png" /&gt;&lt;/p&gt;
&lt;p&gt;底下的三接頭連桿變為固定邊。&lt;/p&gt;
&lt;p&gt;自由度由 4 變為 1。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_10_03_04.png" /&gt;&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>創意性機構設計課堂筆記 - 09/30</title><link href="http://project.mde.tw/blog/chuang-yi-xing-ji-gou-she-ji-ke-tang-bi-ji-0930.html" rel="alternate"></link><published>2017-10-01T21:00:00+08:00</published><updated>2017-10-01T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-10-01:blog/chuang-yi-xing-ji-gou-she-ji-ke-tang-bi-ji-0930.html</id><summary type="html">&lt;p&gt;每星期創意性機構設計課程筆記整理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;設計程序&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;設計程序&lt;/h1&gt;
&lt;p&gt;參照顏教授&lt;strong&gt;創意性設計方法&lt;/strong&gt; (Creative design methodology) 的流程，希望可以透過程式化將此流程由電腦協助完成。&lt;/p&gt;
&lt;p&gt;利用 PMKS 的表示法可以讓連桿拓樸判斷更順利。&lt;/p&gt;
&lt;p&gt;過程中一律忽略尺寸，目的是獲得新的機構類型。&lt;/p&gt;
&lt;h2&gt;一般化 (Gerneralization)&lt;/h2&gt;
&lt;p&gt;首先分析一個現有的機械裝置。&lt;/p&gt;
&lt;p&gt;將各桿件的連接關係以運動鍊 (Kinematic chain) 方式呈現，必須符合以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自由度不變&lt;/li&gt;
&lt;li&gt;桿件數不變&lt;/li&gt;
&lt;li&gt;全為迴轉對&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用&lt;strong&gt;拓樸構造特性&lt;/strong&gt;描述此機構，包含桿件與接頭功用，紀錄功用可以在排列組合時維持其本來目的。&lt;/p&gt;
&lt;h2&gt;數目合成 (Number synthesis)&lt;/h2&gt;
&lt;p&gt;取得全部桿件數與全部接頭數，進行桿件類型反推：&lt;/p&gt;
&lt;div class="math"&gt;$$N_{L}(桿件數)=\sum_{m=2}^{m_{max}}N_{L_{m}}$$&lt;/div&gt;
&lt;div class="math"&gt;$$2N_{J}(接頭數)=\sum_{m=2}^{m_{max}}mN_{L_{m}}$$&lt;/div&gt;
&lt;p&gt;其中，最大連桿數可以從這兩個條件求得（其餘為不合理）：&lt;/p&gt;
&lt;div class="math"&gt;$$
m_{max} = \begin{cases}
N_{J}-N_{L}+2 &amp;amp; (N_{L}\leq N_{J}\leq 2N_{L}-3);\\
N_{L}-1 &amp;amp; (2N_{L}-3\leq N_{J}\leq \frac{N_{L}(N_{L}-1)}{2})
\end{cases}
$$&lt;/div&gt;
&lt;p&gt;由最大接頭類型，列出每種連桿數和接頭的可能性，當桿件的接頭超過 2 和 3，會變成一種以上的組合。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{cases}
x+y+z=8;\\
2x+3y+4z=20;\\
x\geq 0,\quad y\geq 0,\quad z\geq 0
\end{cases}
$$&lt;/div&gt;
&lt;p&gt;寫了一個手算解題的小工具，不過用 Scipy 解題顯然更有效率一點。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
f1 = (1, 1, 1, 8) #x + y + z = 8
f2 = (2, 3, 4, 20) #2x + 3y + 4z = 20

q = f2[2]/f1[2] #消去 z.
f3 = tuple(f2[i]-f1[i]*q for i in range(len(f1)))
#(-2.0, -1.0, 0.0, -12.0)
#-2x + -y = -12
#x = -y/2 + 6

y = (1., 0.)
x = (y[0]/f3[0], f3[3]/f3[0])

#1(-t/2+6) + 1(t) + z = 8
#z = -1(-t/2+6) - 1(t) + 8
z = (
    (-x[0]*f1[0]-y[0]*f1[1])/f1[2],
    (-x[1]*f1[0]-y[1]*f1[1]+f1[3])/f1[2]
)

for name, s in zip(['x', 'y', 'z'], [x, y, z]):
    print("{} = {}t + {}".format(name, s[0], s[1]))

print('-'*7)

#使用係數 t
fx = lambda t: x[0]*t+x[1]
fy = lambda t: y[0]*t+y[1]
fz = lambda t: z[0]*t+z[1]

for t in range(10):
    a = (fx(t), fy(t), fz(t))
    for name, an in zip(['x', 'y', 'z'], a):
        print("{} = {}".format(name, an))
    for i, f in enumerate([f1, f2, f3]):
        print(f[0]*a[0]+f[1]*a[1]+f[2]*a[2]==f[-1])
    print('-'*7)
&lt;/pre&gt;

&lt;p&gt;接著進行不同接頭的排列組合，並排除同構 (isomorphic) 結果。&lt;/p&gt;
&lt;p&gt;排列後畫出圖譜，可以得知是否有新的結構產生。&lt;/p&gt;
&lt;p&gt;由於一般化後都為迴轉對，若出現 3 桿件的&lt;strong&gt;呆鍊&lt;/strong&gt;迴路，會導致此運動鍊的自由度減少，應以排除該結果。&lt;/p&gt;
&lt;h2&gt;特殊化 (Specialization)&lt;/h2&gt;
&lt;p&gt;這裡需注意&lt;strong&gt;設計需求&lt;/strong&gt; (design requirement) 與&lt;strong&gt;設計限制&lt;/strong&gt; (design constraint)，拿捏不當可能產生一些無用的解。&lt;/p&gt;
&lt;p&gt;此處為逆向產生原有的機構。&lt;/p&gt;
&lt;p&gt;首先把之前的&lt;strong&gt;拓樸構造特性&lt;/strong&gt;分析連桿的角色與要求，例如定義原本的固定桿、搖臂、減震器等。&lt;/p&gt;
&lt;p&gt;最後對圖譜結果排列組合，即可產生新的連桿類型。&lt;/p&gt;
&lt;p&gt;其中一組解應為原本現有的機構類型。&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="創意性機構設計"></category></entry><entry><title>Python-Solvespace 開發進度 - 09/30</title><link href="http://project.mde.tw/blog/python-solvespace-kai-fa-jin-du-0930.html" rel="alternate"></link><published>2017-09-30T21:00:00+08:00</published><updated>2017-09-30T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-09-30:blog/python-solvespace-kai-fa-jin-du-0930.html</id><summary type="html">&lt;p&gt;Python-Solvespace 更新&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;問題與回應&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;問題與回應&lt;/h1&gt;
&lt;p&gt;之前向官方提出關於 pull request 和檔案格式的問題：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/solvespace/solvespace/issues/292"&gt;https://github.com/solvespace/solvespace/issues/292&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;whitequark 今天回應說 solver 分支的存在是因為版權問題，若要以開發模式加入 Python bindings，則建議從 master 加入。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_09_30_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;我提出是否能將 Python-Solvespace 整合到 CMake 的編譯流程中。&lt;/p&gt;
&lt;p&gt;另外，詢問了一下關於檔案格式的問題。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_09_30_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;whitequark 的回應是必須簽署 CLA (Contributor License Agreement)，並會開始處理 CMake 流程和做測試。&lt;/p&gt;
&lt;p&gt;檔案格式的問題是因為事實上 solver 只能為一個 group 解題，而一個檔案含有多個，因此無法靠 solver 的延伸介面 (slvs.h) 操作檔案讀寫，似乎也沒解決方法。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_09_30_03.png" /&gt;&lt;/p&gt;
&lt;p&gt;鍥而不捨地提出有關達成外部自動組立的可能性。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_09_30_04.png" /&gt;&lt;/p&gt;
&lt;p&gt;不過現在似乎因為內部介面無法檢查定量而會造成記憶體外洩的問題，可能就無法處理了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_09_30_05.png" /&gt;&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Pyslvs 開發進度 - 09/29</title><link href="http://project.mde.tw/blog/pyslvs-kai-fa-jin-du-0929.html" rel="alternate"></link><published>2017-09-29T21:00:00+08:00</published><updated>2017-09-29T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-09-29:blog/pyslvs-kai-fa-jin-du-0929.html</id><summary type="html">&lt;p&gt;Pyslvs v0.9 大更新進度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PMKS 輸入&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;PMKS 輸入&lt;/h1&gt;
&lt;p&gt;藉由解析 PMKS 網址輸入表示式。&lt;/p&gt;
&lt;iframe width="854" height="480" src="https://www.youtube.com/embed/K_pkBiU5eLE" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;第一個 Bata 版會如影片中封起輸入輸出功能，主要是由 PMKS 匯入匯出符號式。&lt;/p&gt;
&lt;p&gt;上面影片中的輸入 (inputs) 功能已經將 Revolute joint 的輸入設計好了，剩下 Prismatic joint 還有許多要測試的地方。&lt;/p&gt;
&lt;p&gt;明天會將上述功能檢查完全。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Pyslvs 開發進度 - 09/26</title><link href="http://project.mde.tw/blog/pyslvs-kai-fa-jin-du-0926.html" rel="alternate"></link><published>2017-09-26T21:00:00+08:00</published><updated>2017-09-26T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-09-26:blog/pyslvs-kai-fa-jin-du-0926.html</id><summary type="html">&lt;p&gt;Pyslvs v0.9 大更新進度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;輸入 (Inputs) 介面&lt;/li&gt;
&lt;li&gt;Version 0.9 Bata 計畫&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;輸入 (Inputs) 介面&lt;/h1&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_09_26.png" /&gt;&lt;/p&gt;
&lt;p&gt;製作了藉由自由度輸入變數至機構的 GUI，介面盡量設計得直覺一些。&lt;/p&gt;
&lt;p&gt;Points 清單的更新模式是跟畫布 (Canvas) 同步的，無論是新增、刪除節點，還是選取、取消選取，Points 清單都會保持最新狀態，方便使用者設計時不再需要一直跳出視窗設定。&lt;/p&gt;
&lt;p&gt;首先由 Points 清單選擇節點，接著選擇基準桿件與驅動桿件，例如圖中 link_1 和機架 ground 做相對運動，按下「Add to variable list」鈕加入到下方的變數清單。&lt;/p&gt;
&lt;p&gt;由於自由度 (DOF) 的數學定義是能取決該機構節點位置的&lt;strong&gt;變數數量&lt;/strong&gt;，因此 Variables 清單的長度不可大於自由度。&lt;/p&gt;
&lt;p&gt;選取變數後，可以藉由右邊的轉盤增減量。&lt;/p&gt;
&lt;p&gt;由於還有幾個部份還沒確定，因此還未將控制添加給 Solvespace API。&lt;/p&gt;
&lt;h2&gt;待決定事項&lt;/h2&gt;
&lt;p&gt;關於輸入 (Inputs) 介面功能的未決定事項，想在這裡列出來，看看是否靈光一現，能有兩全其美的規劃。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;因為此介面是與機構 (Mechanism) 完全同步，是否改變機構外觀時就要更新變數的內容了呢？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;正在規劃錄製 (Records) 清單的角色定位，至少能達成 Solvespace 中紀錄並繪製點座標的功能，但也因上述問題，不知是否處理已錄製的數據。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;搭配下述新的版次管理，希望錄製 (Records) 清單能保存每個版本機構的路徑資料。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;Version 0.9 Bata 計畫&lt;/h1&gt;
&lt;p&gt;當新的 PMKS 表示法和輸入功能建立好後，會封鎖還未完成的功能（例如輸出輸入與舊範例），釋出這兩個新系統的 Bata 版本。&lt;/p&gt;
&lt;p&gt;而 Bata 版的推出是一系列的，釋出時將會標明測試哪部份的功能。&lt;/p&gt;
&lt;p&gt;預計將分批測試以下項目（順序可變）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PMKS 表示法和輸入功能&lt;/li&gt;
&lt;li&gt;具有版次紀錄的檔案格式&lt;/li&gt;
&lt;li&gt;大量機構範例&lt;/li&gt;
&lt;li&gt;外部格式輸出&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;具有版次紀錄的檔案格式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;新的檔案格式採用 SQL Database。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;僅會紀錄機構變更內容&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;設計一組符合 PMKS 表示法的&lt;strong&gt;索引值&lt;/strong&gt;，讓 Pyslvs 可以更快更動機構內容。&lt;/li&gt;
&lt;li&gt;「變更內容」搭配「索引值」，可以比較出機構差異，若要合併分支，需要設計差異疊加的判斷功能。&lt;/li&gt;
&lt;li&gt;Undo Redo 清單仍只會依順序重新建立機構，以免造成程式負擔。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;大量機構範例&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;這部份想學習顏鴻森教授的「一般化」，嘗試將不同組合的運動鍊轉換後導入。&lt;/li&gt;
&lt;li&gt;機構範例&lt;strong&gt;用 PMKS 網址參數就能紀錄了&lt;/strong&gt;，可以較以前省下更多資源空間。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;外部格式輸出&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;修正舊的 Solvespace 導出功能，會再向開發人員詢問問題。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;導出格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PMKS 網址（&lt;strong&gt;完成&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;截圖用 Qt 轉檔或複製到剪貼簿（&lt;strong&gt;完成&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;Pyslvs 格式&lt;/li&gt;
&lt;li&gt;Solvespace 格式&lt;/li&gt;
&lt;li&gt;DXF 平面格式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Python Slots Attribute</title><link href="http://project.mde.tw/blog/python-slots-attribute.html" rel="alternate"></link><published>2017-09-23T21:00:00+08:00</published><updated>2017-09-23T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-09-23:blog/python-slots-attribute.html</id><summary type="html">&lt;p&gt;用描述器 (Descriptor) 實作 Python 物件以節省記憶體資源&lt;/p&gt;


&lt;p&gt;參考資料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://book.pythontips.com/en/latest/__slots__magic.html"&gt;Python Tips&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://openhome.cc/Gossip/Python/Slots.html"&gt;openhome.cc - Slots&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://openhome.cc/Gossip/Python/Descriptor.html"&gt;openhome.cc - Descriptor&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Dictionary Attribute&lt;/h1&gt;
&lt;p&gt;一般的自訂 Class 如下：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
class A:
    pass

a = A()
a.c = 1
print(a.c) #1
&lt;/pre&gt;

&lt;p&gt;其實同於：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
a = A()
a.__dict__['c'] = 1
print(a.__dict__['c'])
&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;a.c&lt;/code&gt; 和 &lt;code&gt;a.__dict__['c']&lt;/code&gt; 的記憶體位置是一樣的。&lt;/p&gt;
&lt;p&gt;是因為透過存取 &lt;code&gt;__dict__&lt;/code&gt; 特性的方式，用字典類型將鍵值存在 a 物件中。&lt;/p&gt;
&lt;p&gt;這樣子可以透過外部疊加特性 (Attribute) 至 a 物件，甚至是 function 都可以在建立 a 物件後加上，不過只有 a 物件可以使用。&lt;/p&gt;
&lt;h1&gt;Slots Attribute&lt;/h1&gt;
&lt;p&gt;Python 提供另一種方式存取 Class 的特性：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
class A:
    __slots__ = ('b', 'c')

a = A()
a.b = 1 #Okay
a.c = 2 #Okay
print(a.c) #2
a.d = 3
'''
AttributeError: 'A' object has no attribute 'd'
'''
&lt;/pre&gt;

&lt;p&gt;使用 &lt;code&gt;__slots__&lt;/code&gt;特性時，會移除 &lt;code&gt;__dict__&lt;/code&gt; 特性，改用描述器 (Descriptor) 來存取其他特性。&lt;/p&gt;
&lt;p&gt;上述程式碼同下：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
a = A()
A.__dict__['b'].__set__(a, 1)
A.__dict__['c'].__set__(a, 2)
print(A.__dict__['c'].__get__(a, A))
&lt;/pre&gt;

&lt;p&gt;而 &lt;code&gt;A.__dict__&lt;/code&gt; 是屬於 mappingproxy 類型，並非一般的 dict 類型，因此無法動態加入新的成員，因此 a 物件就無法加入新特性。&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
&gt;&gt;&gt; A.__dict__
mappingproxy({'__module__': '__main__', 'b': &amp;lt;member 'b' of 'A' objects&gt;, '__doc__': None, 'c': &amp;lt;member 'c' of 'A' objects&gt;, '__slots__': ('b', 'c')})
&gt;&gt;&gt; a.__dict__
Traceback (innermost last):
  File "&amp;lt;stdin&gt;", line 1, in &amp;lt;module&gt;
AttributeError: 'A' object has no attribute '__dict__'
&lt;/pre&gt;

&lt;p&gt;使用 Descriptor 來操作類型的特性時，是使用固定記憶體位置，會比 dict 還節省資源。&lt;/p&gt;
&lt;p&gt;因此若是只有少數 attribute 物件時，使用 &lt;code&gt;__slots__&lt;/code&gt; 列舉，可以提昇較多效能。&lt;/p&gt;
&lt;p&gt;這種方法類似 C# 的結構 (Structure) 比類別 (Class) 省資源的原理。&lt;/p&gt;
&lt;h1&gt;繼承&lt;/h1&gt;
&lt;p&gt;在繼承類型時，要注意幾個問題：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;沒有定義 &lt;code&gt;__slots__&lt;/code&gt; 時，會自動產生 &lt;code&gt;__dict__&lt;/code&gt; 特性。&lt;/li&gt;
&lt;li&gt;當 &lt;code&gt;__dict__&lt;/code&gt; 和 &lt;code&gt;__slots__&lt;/code&gt; 特性共存時，就會失去 &lt;code&gt;__slots__&lt;/code&gt; 的意義了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由於子類型會接收父類型的特性，因此下面的情況都不盡理想：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#這樣會導致 B 類型無法使用 A 類型的特性。
class A:
    __slots__ = ('a',)

class B(A):
    __slots__ = ('b',)

#這樣會導致 B 類型產生 __dict__。
class A:
    __slots__ = ('a',)

class B(A):
    pass

#這樣會導致 B 類型繼承 A 類型的 __dict__。
class A:
    pass

class B(A):
    __slots__ = ('b',)
&lt;/pre&gt;

&lt;p&gt;可以使用這樣的方法解決：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
class A:
    __slots__ = ('a',)

class B(A):
    __slots__ = A.__slots__+('b',)

b = B()
b.a = 10
print(b.a) #10
&lt;/pre&gt;

&lt;p&gt;PyQt 的類型由於是 wrapper 製作的，已經有空的 &lt;code&gt;__dict__&lt;/code&gt; 特性，繼承後使用此方法就沒意義了。&lt;/p&gt;</summary><category term="Python3"></category></entry><entry><title>Pyslvs 開發進度 - 09/22</title><link href="http://project.mde.tw/blog/pyslvs-kai-fa-jin-du-0922.html" rel="alternate"></link><published>2017-09-22T21:00:00+08:00</published><updated>2017-09-22T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-09-22:blog/pyslvs-kai-fa-jin-du-0922.html</id><summary type="html">&lt;p&gt;Pyslvs v0.9 大更新進度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PMKS 的滑塊語法&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;PMKS 的滑塊語法&lt;/h1&gt;
&lt;p&gt;PMKS 的滑塊接頭有 P 和 RP 兩種，差別在於是否有滾動限制。&lt;/p&gt;
&lt;p&gt;Pyslvs 這裡的困難點就是要將此表示法輸入 Solvespace 中。&lt;/p&gt;
&lt;p&gt;由於是滑動的自由度，必須記錄和回傳兩個點座標，分別是接頭和滑槽的。&lt;/p&gt;
&lt;p&gt;如果是接地的，還容易設計，因為其中一端只需要 dragged 約束和水平線夾角即可，但是如果都在搖桿上，滑槽的夾角是相對於搖桿的，就不易解決了。&lt;/p&gt;
&lt;p&gt;先用 RP 接頭做測試，並模仿 PMKS 的拓樸法輸入。&lt;/p&gt;
&lt;h2&gt;語法&lt;/h2&gt;
&lt;p&gt;這次使用連桿數 3 的機構模擬：（&lt;a href="http://designengrlab.github.io/PMKS/pmks.html?mech=ground,i,R,0.000,0.000,0.000,ffft|c,i,RP,20.184,9.229,0.000,tfff|c,ground,R,32.896,0.000,0.000,tfff|"&gt;PMKS Server&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_09_22_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;當 Type of Joint 屬性為 RP 時，會根據 Links 屬性進行判別，&lt;strong&gt;第一個&lt;/strong&gt; Link 會當作滑槽所在的連桿，因此上圖的 c, i 表示滑槽在 c 連桿上，i 或之後的連桿則會通過銷連接在滑槽上。&lt;/p&gt;
&lt;p&gt;若相反，則會如下圖：（&lt;a href="http://designengrlab.github.io/PMKS/pmks.html?mech=ground,i,R,0.000,0.000,0.000,ffft|i,c,RP,20.184,9.229,0.000,tfff|c,ground,R,32.896,0.000,0.000,tfff|"&gt;PMKS Server&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_09_22_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;第一張圖的接頭在 Solvespace 中模擬如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_09_22_03.png" /&gt;&lt;/p&gt;
&lt;p&gt;接頭處，以一固定角度的直線取代滑槽的位置，角度為絕對角度和接頭位置計算得出 (15.71 度)。&lt;/p&gt;
&lt;p&gt;圖面上必須呈現滑動點和滑槽的位置，因此 Pyslvs 必須記錄不同桿件上的 Current position 數據。&lt;/p&gt;
&lt;p&gt;預計這幾天可以完成靜態的輸入。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>創意性機構設計課堂筆記 - 09/18</title><link href="http://project.mde.tw/blog/chuang-yi-xing-ji-gou-she-ji-ke-tang-bi-ji-0918.html" rel="alternate"></link><published>2017-09-18T21:00:00+08:00</published><updated>2017-09-18T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-09-18:blog/chuang-yi-xing-ji-gou-she-ji-ke-tang-bi-ji-0918.html</id><summary type="html">&lt;p&gt;每星期創意性機構設計課程筆記整理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;類型合成&lt;/li&gt;
&lt;li&gt;自由度&lt;/li&gt;
&lt;li&gt;心得&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;類型合成&lt;/h1&gt;
&lt;p&gt;類型合成 (Type Synthesis) 的合成對象是「機構類型」，機構類型可以透過如下參數定義：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Degree of Freedom 自由度 (Dof)&lt;/li&gt;
&lt;li&gt;Number of Link 桿件數 (NL)&lt;/li&gt;
&lt;li&gt;Type / Number of Joint 接頭種類 / 接頭數 (J)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中桿件數 (NL) 和接頭 (J) 可以求得自由度 (Dof)，這在下一小節會提到。&lt;/p&gt;
&lt;p&gt;機構類型並不包含接點位置或連桿長度等數據，僅僅是代表這種機構的特色，如輸入端、連桿與不同接頭的數量。&lt;/p&gt;
&lt;p&gt;舉例來說，曲柄搖桿是四連桿尺寸的一種，桿件數為 4，有 4 個旋轉接頭；平行四連桿、雙搖桿或雙曲柄也是如此，它們即為同一種機構類型。&lt;/p&gt;
&lt;p&gt;泰奧．揚森 (Theo Jansen) 的八連桿雖然作動上與四連桿相似，不過桿件數為 8，10 個旋轉接頭，並不屬於同一種連桿。&lt;/p&gt;
&lt;p&gt;類型合成的目的在於從現有的存在設計 (Exist Design) 跳脫成新設計 (New Design)，以取得新的專利 (patent)。&lt;/p&gt;
&lt;h1&gt;自由度&lt;/h1&gt;
&lt;p&gt;以數學模型的角度，自由度 (Degree of Freedom) 是連桿組的&lt;strong&gt;獨立變數的數量&lt;/strong&gt;。換而言之，當給定&lt;strong&gt;輸入端的數目&lt;/strong&gt;，可以得到此連桿組狀態的&lt;strong&gt;唯一解&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;連桿組一般稱為運動鍊 (Kinematic chain)，當其中一個桿件作為機架（主座標系）時，此連桿組可謂拘束化 (Constrained)，稱為機構。&lt;/p&gt;
&lt;h2&gt;平面系統&lt;/h2&gt;
&lt;p&gt;平面系統中，物體的全自由度為 3，為 x、y 座標的增量與 z 軸的旋轉量，當配合接頭後，會將各桿件的自由度減少。&lt;/p&gt;
&lt;div class="math"&gt;$$Dof=3(N_{L}-1)-2\times{J_{R}}-2\times{J_{P}}-1\times{J_{G}}-1\times{J_{RP}}$$&lt;/div&gt;
&lt;p&gt;首先將各桿件的全自由度相加，接著將各種接頭失去的自由度減去。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;R 為旋轉對，失去平移的自由度，因此扣 2。&lt;/li&gt;
&lt;li&gt;P 為滑動對，失去旋轉與單方向移動，因此扣 2。&lt;/li&gt;
&lt;li&gt;G 為齒輪對，&lt;strong&gt;為旋轉與滑動&lt;/strong&gt;，失去單方向移動，因此扣 1。&lt;/li&gt;
&lt;li&gt;PMKS 的 RP 為槽中銷，&lt;strong&gt;為旋轉與滑動&lt;/strong&gt;，失去單方向移動，因此扣 1。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;P 和 RP 的差異在於 P 多了一個滑塊，而滑塊屬於桿件，如圖所示：&lt;/p&gt;
&lt;p&gt;下圖的桿件數為 4，R 接頭為 3 個，P 接頭為 1 個。（&lt;a href="http://designengrlab.github.io/PMKS/pmks.html?mech=ground,i,R,0.000,0.000,0.000,tfft|i,c,R,3.844,5.482,0.000,tfff|ground,s,P,14.234,9.449,45.000,tfff|c,s,R,14.234,9.449,45.000,tfff|"&gt;PMKS Server&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_09_18_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;下圖的桿件數為 3，R 接頭為 2 個，RP 接頭為 1 個。（&lt;a href="http://designengrlab.github.io/PMKS/pmks.html?mech=ground,i,R,0.000,0.000,tfft|i,c,R,3.844,5.482,tfff|ground,c,RP,14.234,9.449,45.000,tfff|"&gt;PMKS Server&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_09_18_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;透過自由度可證，當自由度小於 1 時，會無法接收任何輸入。&lt;/p&gt;
&lt;p&gt;但是有些連桿雖然自由度低於 1，在某些情況下是可以使用的，例如平行搖桿：&lt;/p&gt;
&lt;p&gt;下圖的桿件數為 5，R 接頭為 6 個。（&lt;a href="http://designengrlab.github.io/PMKS/pmks.html?mech=ground,i1,R,0.000,0.000,ffft|i1,c,R,0.000,10.000,tfff|ground,i2,R,10.000,0.000,tfff|i2,c,R,10.000,10.000,tfff|ground,i3,R,20.000,0.000,tfff|i3,c,R,20.000,10.000,tfff|"&gt;PMKS Server&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Solvespace 這裡有時求的到解，有時會紅屏。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_09_18_03.png" /&gt;&lt;/p&gt;
&lt;h2&gt;空間系統&lt;/h2&gt;
&lt;p&gt;空間系統的全自由度為 6，為 x、y、z 軸的增量與旋轉。&lt;/p&gt;
&lt;div class="math"&gt;$$Dof=6(N_{L}-1)-5\times{J_{R}}-5\times{J_{P}}-3\times{J_{S}}$$&lt;/div&gt;
&lt;p&gt;原本的接頭繼承自平面機構，因此 R 和 P 接頭只釋出 1 個自由度，其他接頭也是同理。&lt;/p&gt;
&lt;p&gt;在空間系統中，還有更多樣的接頭：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;S 為球接頭 (Spherical)，只有旋轉的 3 個自由度。&lt;/li&gt;
&lt;li&gt;螺旋接頭，有兩種運動方式，但是彼此為相依關係 S(θ)，因此自由度為 1，同 P 接頭。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;當一桿件兩端皆為 S 接頭時，如 Delta 3D 列印機的連桿，會產生自轉，不過此自轉對整個系統是沒任何影響的，稱為贅餘 (Redundent) 自由度，計算時應當扣除。&lt;/p&gt;
&lt;p&gt;如下面的 6 對史都華連桿計算，桿件數為 14，P 接頭為 6 個，S 接頭為 12 個：&lt;/p&gt;
&lt;div class="math"&gt;$$Dof=6(14-1)-5\times{0}-5\times{6}-3\times{12}=6+6(自轉)$$&lt;/div&gt;
&lt;p&gt;輸入為 6 個 P 接頭。&lt;/p&gt;
&lt;h1&gt;心得&lt;/h1&gt;
&lt;p&gt;排除特殊連桿，希望 Pyslvs 可以根據自由度的數量，讓使用者選擇從指定的接頭輸入，而 Path track 功能則變為 Solvespace 單純紀錄路徑的功能。&lt;/p&gt;
&lt;p&gt;存下來的路徑，可以套用至以前的 demo 功能，類似錄製性的可以重新播放。&lt;/p&gt;
&lt;p&gt;接頭輸入系統即為之前的 Drive shaft，可能需要重新設計，P 和 RP 接頭若也要接收輸入，則需規劃一下。&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="創意性機構設計"></category></entry><entry><title>Pyslvs 開發進度 - 09/16</title><link href="http://project.mde.tw/blog/pyslvs-kai-fa-jin-du-0916.html" rel="alternate"></link><published>2017-09-16T21:00:00+08:00</published><updated>2017-09-16T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-09-16:blog/pyslvs-kai-fa-jin-du-0916.html</id><summary type="html">&lt;p&gt;Pyslvs v0.9 大更新進度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;AppImage&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;轉出 PMKS&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新 Drive shaft 計畫&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;AppImage&lt;/h1&gt;
&lt;p&gt;自之前沒時間理會 &lt;a href="https://github.com/KmolYuan/Pyslvs-PyQt5/issues/3"&gt;Symbian9 開的 issue&lt;/a&gt;，昨天利用空閒時間研究了一下 AppImage 的原理。&lt;/p&gt;
&lt;p&gt;AppImage 是將 Linux 程式所需的關聯函式庫包裝在一起，模擬出一個小 /usr/bin 環境，以達成 Linux 程式可以達成如 Windows 程式攜帶到相同作業系統中執行的效果，甚至可以「安裝」到家目錄，並且無論是可攜狀態執行還是想裝到硬碟，都不需要 sudo 權限。&lt;/p&gt;
&lt;p&gt;但是這種方式會造成檔案龐大，越多程式庫會需要放入越多內容。&lt;/p&gt;
&lt;p&gt;根據 probonopd 寫的一個 Python 2  GTK 3 hello world 範例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/probonopd/AppImages/blob/master/recipes/pythongtk3hello/Recipe"&gt;AppImages/recipes/pythongtk3hello/Recipe&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以發現其實只要一個 Bash 腳本，就可以將程式包裝起來，AppImage 的 functions.sh 工具是從網路下載導入的。&lt;/p&gt;
&lt;p&gt;操作方式跟 Makefile 或 Windows 的 Batch file 雷同，當然 Makefile 最大的優勢是可以跨平台，為邏輯尋找的方式執行；Bash 腳本則是可以自訂 function，以順序執行，跟程式語言很像。&lt;/p&gt;
&lt;h2&gt;包裝 AppImage&lt;/h2&gt;
&lt;p&gt;首先是建立兩層資料夾，第一層會隔離原始碼，用以編譯環境；第二層是 AppDir，相當於環境的根目錄。&lt;/p&gt;
&lt;p&gt;第一層目錄使用 ENV 代稱，這樣 git ignore 會當作 python 虛擬環境忽略此目錄。&lt;/p&gt;
&lt;p&gt;Bash 腳本的語法與終端機是一樣的，因此可以利用 cd 指令切換目錄（這點 Makefile 就得另外達成），只要注意所在目錄即可。&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
########################################################################
# Create the AppDir
########################################################################

APP=pyslvs
LOWERAPP=${APP,,}

mkdir -p ENV/$APP.AppDir/
cd ENV/$APP.AppDir/
&lt;/pre&gt;

&lt;p&gt;使用 Python 的 virtualenv 套件建立獨立 Python 環境，需指定 Python 3。&lt;/p&gt;
&lt;p&gt;加入 &lt;code&gt;--no-site-packages&lt;/code&gt; 參數會建立一個乾淨的模組環境，除了 pip 和一些內建程式庫，所有模組或套件都要重裝，以避免包入不需要的內容。&lt;/p&gt;
&lt;p&gt;使用 source activate 會套用類似 Windows 的環境變數，此時呼叫的 python 和 pip 即為指定的 Python 3，不用擔心 Python 2 混入。&lt;/p&gt;
&lt;p&gt;下達 deactivate 命令會還原設定，便可繼續使用系統的 python 工具。&lt;/p&gt;
&lt;p&gt;單純環境中，可以使用 PyQt 現成的 pip 包裝，這樣能大幅加快速度。&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
########################################################################
# Create a virtualenv inside the AppDir
########################################################################

mkdir -p usr
virtualenv --no-site-packages --python=python3 usr

source usr/bin/activate

# Source some helper functions
wget -q https://github.com/probonopd/AppImages/raw/master/functions.sh -O ./functions.sh
. ./functions.sh

mkdir -p usr/bin/

#Show python and pip versions
python --version
pip --version

# Install python dependencies into the virtualenv
pip install pyqt5 qscintilla pyqtchart
pip install -r ../../requirements.txt

deactivate
&lt;/pre&gt;

&lt;p&gt;接下來要利用 cp 指令「安裝（複製）」自己的程式進 AppDir 環境中，由於原本擁擠的 /usr/bin 只有 Python 工具，因此可以安心地將自己的原始碼展開在 /usr/bin 中。&lt;/p&gt;
&lt;p&gt;原來在 /usr/bin 中的程式只需提及名稱便可隨傳隨到，因此我們將它偽裝成一枚程式，使用 chmod a+x 將全體權限設定為可執行化。&lt;/p&gt;
&lt;p&gt;當腳本被設為可執行化時，必須要有預設開啟的程式，於是要在腳本第一行加上 &lt;code&gt;#!/usr/bin/env python&lt;/code&gt; 或 &lt;code&gt;#!/usr/bin/python&lt;/code&gt;，這邊使用 sed -i "1i\" 命令達成。&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
########################################################################
# "Install" app in the AppDir
########################################################################

cp ../../launch_pyslvs.py usr/bin/$LOWERAPP
sed -i "1i\#!/usr/bin/env python" usr/bin/$LOWERAPP
chmod a+x usr/bin/$LOWERAPP

cp ../../icons_rc.py usr/bin
cp ../../preview_rc.py usr/bin
cp -r ../../core usr/bin
&lt;/pre&gt;

&lt;p&gt;再來是打包 AppDir，根目錄下必須建立一個類似 Windows 捷徑的 desktop 檔案，在 Bash 中建立文字文件可以使用 cat 加上 EOF 標記達成。&lt;/p&gt;
&lt;p&gt;這邊會開始用到 functions.sh 的函式包裝。&lt;/p&gt;
&lt;p&gt;如果有填寫 Icon 那欄，可以將 png 檔命名放在旁邊，當成 AppImage 的圖示。&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
########################################################################
# Finalize the AppDir
########################################################################

get_apprun

cd ../..
VERSION=$(python3 -c "from core.info.info import VERSION; print(\"{}.{}.{}\".format(*VERSION))")
cd ENV/$APP.AppDir/

cat &gt; $LOWERAPP.desktop &amp;lt;&amp;lt;EOF
[Desktop Entry]
Version=$VERSION
Name=$APP
Exec=$LOWERAPP
Type=Application
Icon=$LOWERAPP
Comment=Open Source Planar Linkage Mechanism Simulation and Dimensional Synthesis System.
EOF

# Make the AppImage ask to "install" itself into the menu
get_desktopintegration $LOWERAPP
cp ../../icons/main_big.png $LOWERAPP.png
&lt;/pre&gt;

&lt;p&gt;最後是 functions.sh 的函式收尾，會在最外頭建立一個 out 資料夾，裡面放的就是執行檔。&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
########################################################################
# Bundle dependencies
########################################################################

copy_deps ; copy_deps ; copy_deps
delete_blacklisted
move_lib

########################################################################
# Package the AppDir as an AppImage
########################################################################

cd ..
generate_appimage
&lt;/pre&gt;

&lt;p&gt;測試時有稍微出點小錯，不過後來有發現並修正。&lt;/p&gt;
&lt;p&gt;如此流程在 Travis-ci 的虛擬機中編譯會更快速，而且有搬移到其他 Ubuntu 中測試成功。&lt;/p&gt;
&lt;p&gt;成功後，probonopd 就把 Pyslvs 加到 AppImage 的範例了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/AppImage/appimage.github.io/blob/master/data/Pyslvs"&gt;appimage.github.io/data/Pyslvs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OwO&lt;/p&gt;
&lt;h1&gt;轉出 PMKS&lt;/h1&gt;
&lt;p&gt;稍微看了一下 PMKS 在網址列的輸入方式後，便將 Qt 表格的資料編成 PMKS 的網址格式。&lt;/p&gt;
&lt;p&gt;輸入表格資料是使用 mech 參數，用 pipe 符號 &lt;code&gt;|&lt;/code&gt; 串聯所有點，後面的 t 和 f 是打勾顯示 P V A 的狀況，Pyslvs 是顯示 P 即可。&lt;/p&gt;
&lt;p&gt;透過按下按鈕，可以將當前專案載入到網頁中：&lt;/p&gt;
&lt;iframe width="854" height="480" src="https://www.youtube.com/embed/PrwQywzbrJ4" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;另外 PMKS 其實還有在畫布上繪製圖形的功能，像以下範例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://designengrlab.github.io/PMKS/pmks.html?ts=m-50 0 C -50 125 50 -125 50 0 S -50 -125 -50 0&amp;amp;mech=ground,input,R,0.000,0.000,tfft|input,R,25.000,0.000,tfff|"&gt;figure eight (move back to {-50,0} and draw to connected B-splines)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用的是 ts 參數，不過表示法採用 &lt;a href="https://msdn.microsoft.com/en-us/library/ms752293(v=vs.100).aspx"&gt;Path Markup Syntax&lt;/a&gt; 的方法，可能還需研究一下。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_09_16.png" /&gt;&lt;/p&gt;
&lt;p&gt;這個功能對應 Pyslvs 的 Path Solving 路徑顯示，之後有空再加上去。&lt;/p&gt;
&lt;p&gt;不過今天有發現 PMKS 有 Export Kinematic Data 的功能，會轉出 tab 分隔值的 txt 文件，似乎可以拿來利用的樣子？&lt;/p&gt;
&lt;h1&gt;更新 Drive shaft 計畫&lt;/h1&gt;
&lt;p&gt;接下來 Pyslvs 要開始忙動態呈現的部分，這部分就參照 Linkage 的「播放」功能和之前 Drive shaft 的轉盤。&lt;/p&gt;
&lt;p&gt;不過還要考慮路徑格式，讓算過的路徑結果能抓到起始點和終點，並重新調整角度和點座標之間的關係。&lt;/p&gt;
&lt;p&gt;上述兩者會花一段時間規劃資料結構，避免之前程式紊亂的情況發生。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Python-Solvespace 開發進度 - 09/12</title><link href="http://project.mde.tw/blog/python-solvespace-kai-fa-jin-du-0912.html" rel="alternate"></link><published>2017-09-12T21:00:00+08:00</published><updated>2017-09-12T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-09-12:blog/python-solvespace-kai-fa-jin-du-0912.html</id><summary type="html">&lt;p&gt;Python-Solvespace 更新&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;切換群組功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PyDemo.py&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Python-Solvespace 更新&lt;/h1&gt;
&lt;p&gt;最近突然臨時起意，想將 Python-Solvespace 更新後 pull request 給官方，是否有 Python 介面的需求。&lt;/p&gt;
&lt;p&gt;有以下特點：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;對 Python 友善的介面，且比 C 語言只能使用 slvs.h 方便。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;包含最新的 kernel，&lt;strong&gt;編譯無須 CMake&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不過使用過程中正克服一些障礙，讓功能與 C 語言版本一樣齊全，可以完勝 slvs.h 的 API。&lt;/p&gt;
&lt;h2&gt;切換群組功能&lt;/h2&gt;
&lt;p&gt;首先要翻製 CDemo 的範例內容，以讓相關人員可以更快瞭解操作。&lt;/p&gt;
&lt;p&gt;不過 CDemo 中分開了群組，因此&lt;strong&gt;自由度只會計算該群組的成員&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;原作者打算讓群組編號 Slvs_hGroup 和 Python int 對應 (mapping)，不過這個功能竟然沒做！&lt;/p&gt;
&lt;p&gt;直接使用 SWIG 對應可能導致類型混亂，因此我利用一個簡單的轉換式達成：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
//"src/slvs_python.hpp"

Slvs_hGroup groupNum(int input) { return (Slvs_hGroup) input; }
&lt;/pre&gt;

&lt;p&gt;SWIG 端口也很簡單，使用 inline 區塊可以不用寫兩行：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
//"src/slvs.i"

%inline %{
    extern Slvs_hGroup groupNum(int input);
%}
&lt;/pre&gt;

&lt;p&gt;不過隨後 Python 發出警告：&lt;/p&gt;
&lt;pre&gt;
swig/python detected a memory leak of type 'Slvs_hParam *', no destructor found.
&lt;/pre&gt;

&lt;p&gt;無法找到解構 (destructor) 函式，即 &lt;code&gt;__del__()&lt;/code&gt;或 C 語言的 &lt;code&gt;~some_class()&lt;/code&gt; 刪除函式。&lt;/p&gt;
&lt;p&gt;之前 Slvs_hParam 等類別是在程式庫中運作，並沒有「顯現」出來讓 Python 操作，首次進入 Python 的記憶體管理範圍中，卻發生沒辦法清除的情況。&lt;/p&gt;
&lt;p&gt;這樣會導致程式中止後佔用記憶體，只能靠作業系統清除。&lt;/p&gt;
&lt;p&gt;找了一下 Solvespace 的原始碼，這些類別是定義自 uint32_t 整數類別：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
//"include/slvs.h"

typedef uint32_t Slvs_hParam;
typedef uint32_t Slvs_hEntity;
typedef uint32_t Slvs_hConstraint;
typedef uint32_t Slvs_hGroup;
&lt;/pre&gt;

&lt;p&gt;而 uint32_t 整數類別是包含自 stdint.h。&lt;/p&gt;
&lt;p&gt;SWIG 有針對 C 語言的主要類別做轉換支援，因此在介面檔開頭加上：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
//"src/slvs.i"

//Let Python enable to delete Slvs_hParam, Slvs_hEntity, ... types.
%include "stdint.i"
&lt;/pre&gt;

&lt;p&gt;這樣就解決問題了！&lt;/p&gt;
&lt;p&gt;函式 groupNum 的使用方法很簡單，即利用一個整數來產生群組，切換群組後即可新增所需項目，最大的特點是可以分開解題（包含自由度）。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
sys = System()

#切換至群組 1
g1 = groupNum(1)
sys.default_group = g1

#切換至群組 2
g2 = groupNum(2)
sys.default_group = g2
&lt;/pre&gt;

&lt;p&gt;注意 groupNum 函式與一般 Slvs_hGroup 類別是回傳值，因此相同的輸入值會得到相同的結果，不用像其他實體或約束特意保留指標。&lt;/p&gt;
&lt;h2&gt;PyDemo.py&lt;/h2&gt;
&lt;p&gt;完全仿照 CDemo 製成的小腳本，主要展現 Python-Solvespace 應用程式界面精簡的特性。&lt;/p&gt;
&lt;p&gt;之前原作者有做 Python 2 版的單元測試腳本，不過還掛載沒用到的套件，因此今天花了一點時間重寫了一下。&lt;/p&gt;
&lt;p&gt;原先的註解都搬了過來。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
# -*- coding: utf-8 -*-
## Some sample code for slvs.dll. We draw some geometric entities, provide
## initial guesses for their positions, and then constrain them. The solver
## calculates their new positions, in order to satisfy the constraints.
##
## Copyright 2008-2013 Jonathan Westhues.
## Copyright 2016-2017 Yuan Chang [pyslvs@gmail.com] Python-Solvespace bundled.

from slvs import *

sys = System()

'''
An example of a constraint in 3d. We create a single group, with some
entities and constraints.
'''
def Example3d():
    #A point, initially at (x y z) = (10 10 10)
    p0 = sys.add_param(10)
    p1 = sys.add_param(10)
    p2 = sys.add_param(10)
    Point101 = Point3d(p0, p1, p2)

    #and a second point at (20 20 20)
    p3 = sys.add_param(20)
    p4 = sys.add_param(20)
    p5 = sys.add_param(20)
    Point102 = Point3d(p3, p4, p5)

    #and a line segment connecting them.
    LineSegment3d(Point101, Point102)

    #The distance between the points should be 30.0 units.
    Constraint.distance(30., Point101, Point102)

    #Let's tell the solver to keep the second point as close to constant
    #as possible, instead moving the first point.
    Constraint.dragged(Point102)

    #Now that we have written our system, we solve.
    result = sys.solve()
    if result == SLVS_RESULT_OKAY:
        print(
            "okay; now at ({:.3f} {:.3f} {:.3f})\n".format(sys.get_param(0).val, sys.get_param(1).val, sys.get_param(2).val)+
            "             ({:.3f} {:.3f} {:.3f})\n".format(sys.get_param(3).val, sys.get_param(4).val, sys.get_param(5).val)
        )
        print("{} DOF".format(sys.dof))
    else:
        print("solve failed")

'''
An example of a constraint in 2d. In our first group, we create a workplane
along the reference frame's xy plane. In a second group, we create some
entities in that group and dimension them.
'''
def Example2d():
    g1 = groupNum(1)
    sys.default_group = g1

    #First, we create our workplane. Its origin corresponds to the origin
    #of our base frame (x y z) = (0 0 0)
    p0 = sys.add_param(0)
    p1 = sys.add_param(0)
    p2 = sys.add_param(0)
    Point101 = Point3d(p0, p1, p2)

    #and it is parallel to the xy plane, so it has basis vectors (1 0 0)
    #and (0 1 0).
    qw, qx, qy, qz = Slvs_MakeQuaternion(*[1, 0, 0], *[0, 1, 0])
    p3 = sys.add_param(qw)
    p4 = sys.add_param(qx)
    p5 = sys.add_param(qy)
    p6 = sys.add_param(qz)
    Normal102 = Normal3d(p3, p4, p5, p6)

    Workplane200 = Workplane(Point101, Normal102)

    #Now create a second group. We'll solve group 2, while leaving group 1
    #constant; so the workplane that we've created will be locked down,
    #and the solver can't move it.
    g2 = groupNum(2)
    sys.default_group = g2

    #These points are represented by their coordinates (u v) within the
    #workplane, so they need only two parameters each.
    p7 = sys.add_param(10)
    p8 = sys.add_param(20)
    Point301 = Point2d(Workplane200, p7, p8)

    p9 = sys.add_param(20)
    p10 = sys.add_param(10)
    Point302 = Point2d(Workplane200, p9, p10)

    #And we create a line segment with those endpoints.
    Line400 = LineSegment2d(Workplane200, Point301, Point302)

    #Now three more points.
    p11 = sys.add_param(100)
    p12 = sys.add_param(120)
    Point303 = Point2d(Workplane200, p11, p12)

    p13 = sys.add_param(120)
    p14 = sys.add_param(110)
    Point304 = Point2d(Workplane200, p13, p14)

    p15 = sys.add_param(115)
    p16 = sys.add_param(115)
    Point305 = Point2d(Workplane200, p15, p16)

    #And arc, centered at point 303, starting at point 304, ending at
    #point 305.
    Arc401 = ArcOfCircle(Workplane200, Normal102, Point303, Point304, Point305)

    #Now one more point, and a distance
    p17 = sys.add_param(200)
    p18 = sys.add_param(200)
    Point306 = Point2d(Workplane200, p17, p18)

    p19 = sys.add_param(30)
    Distance0 = Distance(Workplane200, p19)

    #And a complete circle, centered at point 306 with radius equal to
    #distance 307. The normal is 102, the same as our workplane.
    Circle402 = Circle(Workplane200, Normal102, Point306, Distance0)

    #The length of our line segment is 30.0 units.
    Constraint.distance(30., Workplane200, Point301, Point302)

    #And the distance from our line segment to the origin is 10.0 units.
    Constraint.distance(10., Workplane200, Point101, Line400)

    #And the line segment is vertical.
    Constraint.vertical(Workplane200, Line400)

    #And the distance from one endpoint to the origin is 15.0 units.
    Constraint.distance(15., Workplane200, Point301, Point101)

    if 0:
        #And same for the other endpoint; so if you add this constraint then
        #the sketch is overconstrained and will signal an error.
        Constraint.distance(18., Workplane200, Point301, Point101)

    #The arc and the circle have equal radius.
    Constraint.equal_radius(Workplane200, Arc401, Circle402)

    #The arc has radius 17.0 units.
    Constraint.diameter(17.*2, Workplane200, Arc401)

    #If the solver fails, then ask it to report which constraints caused
    #the problem.
    sys.calculateFaileds = 1

    #And solve.
    result = sys.solve()
    if result == SLVS_RESULT_OKAY:
        print("solved okay")
        print("line from ({:.3f} {:.3f}) to ({:.3f} {:.3f})".format(
            sys.get_param(7).val, sys.get_param(8).val,
            sys.get_param(9).val, sys.get_param(10).val
        ))
        print("arc center ({:.3f} {:.3f}) start ({:.3f} {:.3f}) finish ({:.3f} {:.3f})".format(
            sys.get_param(11).val, sys.get_param(12).val,
            sys.get_param(13).val, sys.get_param(14).val,
            sys.get_param(15).val, sys.get_param(16).val
        ))
        print("circle center ({:.3f} {:.3f}) radius {:.3f}".format(
            sys.get_param(17).val, sys.get_param(18).val, sys.get_param(19).val
        ))
        print("{} DOF".format(sys.dof))
    else:
        print("solve failed: problematic constraints are:")
        for e in sys.faileds:
            print(e)
        if result == SLVS_RESULT_INCONSISTENT:
            print("system inconsistent")
        else:
            print("system nonconvergent")

if __name__=='__main__':
    #Example3d()
    Example2d()

'''
solved okay
line from (10.000 11.180) to (10.000 -18.820)
arc center (101.114 119.042) start (116.477 111.762) finish (117.409 114.197)
circle center (200.000 200.000) radius 17.000
6 DOF
'''
&lt;/pre&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Pyslvs 開發進度 - 09/02</title><link href="http://project.mde.tw/blog/pyslvs-kai-fa-jin-du-0902.html" rel="alternate"></link><published>2017-09-02T21:00:00+08:00</published><updated>2017-09-02T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-09-02:blog/pyslvs-kai-fa-jin-du-0902.html</id><summary type="html">&lt;p&gt;Pyslvs v0.9 大更新進度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用者介面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程式碼&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs v0.9 大更新進度&lt;/h1&gt;
&lt;p&gt;經過近一週的大幅度調整後，移除累贅的 module files，重寫了基本函式，大致上已經把底層表示式建好了，PMKS 的滑塊部份還未研究，因此先不加入。&lt;/p&gt;
&lt;p&gt;以下將說明當前程式部份的達成部份。&lt;/p&gt;
&lt;h2&gt;使用者介面&lt;/h2&gt;
&lt;p&gt;大改版之前有換過圖示，Points 使用軸承圖示；Links 使用曲柄表示，之前從 Solvespace 借用的圖示改為較直覺的樣式。&lt;/p&gt;
&lt;p&gt;介面更動後比較清爽了，只剩兩個表格操作：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_09_02_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;Link 的部份跟過去的原點一樣，預設有一個 ground，無法修改或刪除。&lt;/p&gt;
&lt;p&gt;以前的切換 Fix / Unfix 功能調整成會將 ground 加入此點。&lt;/p&gt;
&lt;p&gt;這兩個表格其實是相輔相成的，改動其中一邊會造成包含的內容同時修正，因此在設計時可以先建立空點或空連桿，再接著連起來即可。&lt;/p&gt;
&lt;p&gt;快速建法跟以前一樣使用拖拉模式，不過這部份要自動填入名稱，還未設計好。&lt;/p&gt;
&lt;p&gt;為此有別重寫 Qt 的 Undo Redo command。由於只有兩個表格，因此這次設計較為周全。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_09_02_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_09_02_03.png" /&gt;&lt;/p&gt;
&lt;p&gt;下方的包含清單是使用拖拉的方式加入和移除，Link 的名稱一樣是自訂，是通過 String 類型的 &lt;code&gt;isidentifier()&lt;/code&gt;方法辨認。&lt;/p&gt;
&lt;p&gt;這次改換了新的表示式，因此趁機會將資料格式一舉調整，節省使用空間。&lt;/p&gt;
&lt;p&gt;另外還順便拉了版本控制的說明介面：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_09_02_04.png" /&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;這次表示式的部份採用 PEP 484 的風格撰寫，因此 &lt;strong&gt;Python 必須升級到 3.5 版&lt;/strong&gt;或以上。&lt;/p&gt;
&lt;p&gt;重寫的部份，在邏輯方面加入了多行的程式註解，免得較細節的部份看不懂。&lt;/p&gt;
&lt;p&gt;由於中心部份直接刪除重做，連接處仍然需要維修，例如 Panels 跟畫布和表格互動的部份。&lt;/p&gt;
&lt;p&gt;PMKS 表示式的好處是更節省函式和物件的空間。&lt;/p&gt;
&lt;p&gt;這次基礎建設改動了 69 個檔案，首要目標是先將舊功能加回，規劃新檔案格式後，再將幾個重要的 Examples 補齊。&lt;/p&gt;
&lt;p&gt;看了相關資料後，發覺 fossil 格式包含的項目滿多的，可能要評估如何將 Points 表格的資料以何種方式存入 Database，fossil 的版次格式和 merge 方式也需要研究。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>PEP 484 Type Hints</title><link href="http://project.mde.tw/blog/pep-484-type-hints.html" rel="alternate"></link><published>2017-08-30T21:00:00+08:00</published><updated>2017-08-30T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-08-30:blog/pep-484-type-hints.html</id><summary type="html">&lt;p&gt;文章閱讀：Python 函式中的類型提示&lt;/p&gt;
&lt;p&gt;如何在 Python 函式中標示類型？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B"&gt;Duck Typing&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.python.org/dev/peps/pep-0484"&gt;PEP 484&lt;/a&gt; 簡讀&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;em&gt;詳情可參閱上方連結。&lt;/em&gt;&lt;/p&gt;
&lt;h1&gt;Duck Typing&lt;/h1&gt;
&lt;p&gt;作為一種動態程式語言，Python 採用「鴨子型別」的方式進行物件識別：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;「當看到一隻鳥走起來像鴨子、游泳起來像鴨子、叫起來也像鴨子，那麼這隻鳥就可以被稱為鴨子。」&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如以下的程式：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
class Duck:
    def quack(self):
        print("這鴨子在呱呱叫")
    def feathers(self):
        print("這鴨子擁有白色與灰色羽毛")
    def getMyFeathers(self):
        return ["白色羽毛", "灰色羽毛"]

class Person:
    def quack(self):
        print("這人正在模仿鴨子")
    def feathers(self): 
        print("這人在地上拿起1根羽毛然後給其他人看")
    def getMyFeathers(self):
        return "地上的羽毛"

def in_the_forest(duck):
    duck.quack()
    duck.feathers()

#Start the game.
donald = Duck()
john = Person()
in_the_forest(donald)
in_the_forest(john)
&lt;/pre&gt;

&lt;p&gt;以上程式碼顯示，不管你是 Duck 類型還是 Person 類型，一樣可以進入 &lt;code&gt;in_the_forest&lt;/code&gt; 函式。&lt;/p&gt;
&lt;p&gt;很明顯地，我們的 john 可以玩到直到「穿幫」為止。&lt;/p&gt;
&lt;p&gt;也呼應了 Python 的設計風格：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;We're all consenting adults here.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只要知道自己在做什麼，Python 可以讓寫作方式不會太過拘謹。&lt;/p&gt;
&lt;h1&gt;PEP 484 簡讀&lt;/h1&gt;
&lt;p&gt;不過 Python 中還是可以「提醒」工程師，function 中究竟該輸入什麼、會得到什麼。&lt;/p&gt;
&lt;p&gt;這裡使用「提醒」這個字，代表著仍然能不按照規定輸入輸出（因為我們是動態語言），當然也會抱著被拆穿的風險。&lt;/p&gt;
&lt;p&gt;使用 PEP 484 的規則設計，最大的好處是可以不須使用註解來標明，畢竟同一色系常常會打錯字或是會錯意。&lt;/p&gt;
&lt;p&gt;而且 Python 直譯器以及絕大多數的 IDE 都會幫你檢查是否為正確的類型。&lt;/p&gt;
&lt;p&gt;需要注意的是，typing 模組是在 Python 3.5 加入。&lt;/p&gt;
&lt;h2&gt;輸入&lt;/h2&gt;
&lt;p&gt;先來展示基本的寫法，提醒 john 不要進入 &lt;code&gt;in_the_forest&lt;/code&gt; 函式：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def in_the_forest(duck: Duck):
    duck.quack()
    duck.feathers()
    whiteFeather, grayFeather = duck.getMyFeathers()
&lt;/pre&gt;

&lt;p&gt;這裡使用冒號 &lt;code&gt;:&lt;/code&gt; 後加上類型物件可以標示這個輸入的類型。&lt;/p&gt;
&lt;p&gt;如果在其他檔案，懶得找到鴨子，也可以用字串表示有種生物叫鴨子。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def in_the_forest(duck: "Duck"):
&lt;/pre&gt;

&lt;p&gt;預設項目的用法也是以此類推，比如沒有 donald，自己找隻鴨子。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def in_the_forest(duck: Duck =Duck()):
&lt;/pre&gt;

&lt;p&gt;多個輸入也雷同，使用逗號隔開即可。若是很多項，則是建議換行。&lt;/p&gt;
&lt;p&gt;多個項目中可以選擇特定的標示，這些都不是硬性規定。&lt;/p&gt;
&lt;p&gt;下面的範例留了一個安全的位子給 john。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def in_the_forest(
    duck1: Duck =Duck(),
    duck2: Duck =Duck(),
    duck3: Duck =Duck(),
    person: Person =Person()
):
    Creatures = [duck1, duck2, duck3, person]
    for i, duck in enumerate(Creatures):
        duck.quack()
        duck.feathers()
        if i!=3:
            whiteFeather, grayFeather = duck.getMyFeathers()

in_the_forest(person=john)
&lt;/pre&gt;

&lt;p&gt;類型中的方法 (method) 也是一樣，不過因為第一個輸入 self 本來就是該類型，通常都不會標示。&lt;/p&gt;
&lt;p&gt;這樣是不是清楚很多呢？&lt;/p&gt;
&lt;h2&gt;輸出&lt;/h2&gt;
&lt;p&gt;我們注意到 donald 和 john 在 &lt;code&gt;getMyFeathers&lt;/code&gt; 函式中拿出的物件不一樣，為了瞭解類型的函式究竟會得到什麼，可以使用輸出表示的方法。&lt;/p&gt;
&lt;p&gt;輸出表示是一個箭號形狀擺在 function 尾端的冒號 &lt;code&gt;:&lt;/code&gt; 之前：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
class Person:
    def getMyFeathers(self) -&gt; str:
        return "地上的羽毛"
&lt;/pre&gt;

&lt;p&gt;當然只會做事的函式是回傳 None，可以視情況決定要不要寫：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
class Person:
    def quack(self) -&gt; None:
        print("這人正在模仿鴨子")
&lt;/pre&gt;

&lt;p&gt;若為多個，也是使用逗號分隔，這裡就不示範了。&lt;/p&gt;
&lt;h2&gt;容器物件&lt;/h2&gt;
&lt;p&gt;若是輸入或輸出的物件為容器 (container)，可以使用檢索符號 &lt;code&gt;[ ]&lt;/code&gt; 中括弧來標示。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from typing import List

class Duck:
    def getMyFeathers(self) -&gt; List[str, str]:
        return ["白色羽毛", "灰色羽毛"]
&lt;/pre&gt;

&lt;p&gt;從 typing 模組匯入的類型名稱字首為大寫，注意不要與一般類型混淆了。&lt;/p&gt;
&lt;h2&gt;可呼叫物件&lt;/h2&gt;
&lt;p&gt;可呼叫 (callable) 的 function 類型和常用的 lambda 如下表示：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from typing import Callable

def async_query(
    on_success: Callable[[int], None],
    on_error: Callable[[int, Exception], None]
):
&lt;/pre&gt;

&lt;p&gt;第一項為「輸入類型」，第二項為「輸出類型」。&lt;/p&gt;
&lt;p&gt;若是懶得管第一項，可以使用 &lt;a href="https://docs.python.org/3.6/library/constants.html#Ellipsis"&gt;Ellipsis&lt;/a&gt; 表示。&lt;/p&gt;
&lt;p&gt;一個簡單的 lambda 物件如下表示：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
lambda x, y: str(x+y)

Callable[[int, int], str]
Callable[..., str]
&lt;/pre&gt;

&lt;h2&gt;泛型物件&lt;/h2&gt;
&lt;p&gt;若有多重類型的物件可以適用，便可從 typing 模組匯入泛型物件。&lt;/p&gt;
&lt;p&gt;例如無序集合：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from typing import Mapping, Set

def notify_by_email(employees: Set[Employee], overrides: Mapping[str, str]):
&lt;/pre&gt;

&lt;p&gt;或是有序集合：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from typing import Sequence, TypeVar

T = TypeVar('T')

def first(l: Sequence[T]) -&gt; T:
    return l[0]
&lt;/pre&gt;

&lt;p&gt;或是任何字串：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from typing import TypeVar

AnyStr = TypeVar('AnyStr', str, bytes)

def concat(x: AnyStr, y: AnyStr) -&gt; AnyStr:
    return x + y
&lt;/pre&gt;

&lt;p&gt;上面的範例中，透過 TypeVar 函式可以將你的自訂類型正規化，讓直譯器不會出錯，是一個比字串更好的表達方式。&lt;/p&gt;
&lt;p&gt;還有更多使用方式，這裡就不細數了，更多內容可以參閱官方的說明。&lt;/p&gt;</summary><category term="Python3"></category></entry><entry><title>Pyslvs 開發進度 - 08/28</title><link href="http://project.mde.tw/blog/pyslvs-kai-fa-jin-du-0828.html" rel="alternate"></link><published>2017-08-28T21:00:00+08:00</published><updated>2017-08-28T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-08-28:blog/pyslvs-kai-fa-jin-du-0828.html</id><summary type="html">&lt;p&gt;Pyslvs v0.9 計劃&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;新的表示式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SQL Database 檔案格式&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs v0.9 計劃&lt;/h1&gt;
&lt;p&gt;在這次大改版中，預計會完成兩項目標：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;新的表示式，大幅縮減數據量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SQL Database 檔案格式，支援Git 版本控制。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這兩個內容在進行時也會同時紀錄和&lt;/p&gt;
&lt;p&gt;以下內容將闡述會需要製作的項目。&lt;/p&gt;
&lt;h2&gt;新的表示式&lt;/h2&gt;
&lt;p&gt;看了一些深度學習的文章後，了解到 PMKS 的表示式對於類神經演算法程式建模非常有幫助，因此決定將這個概念套用在 Pyslvs，並且藉由此表示法輸出成其他格式。&lt;/p&gt;
&lt;p&gt;Pyslvs 中會使用下列兩種類型：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;VPoint&lt;/code&gt; 節點&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Link: str -&amp;gt; tuple[str]&lt;/p&gt;
&lt;p&gt;表示節點所屬連桿名稱，由輸入 str 逗號分隔值轉為內含 str 的 tuple 類型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Type: VPoint.Type&lt;/p&gt;
&lt;p&gt;此節點的連接類型，關係其自由度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;color: str -&amp;gt; QColor&lt;/p&gt;
&lt;p&gt;此點顏色，由名稱回傳 Qt 的顏色值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;x, y: int, float&lt;/p&gt;
&lt;p&gt;直角座標系數值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cx, cy: int, float&lt;/p&gt;
&lt;p&gt;當前的直角座標系數值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;VLink&lt;/code&gt; 連桿&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;name: str&lt;/p&gt;
&lt;p&gt;連桿名稱，大小寫英數皆可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Points: str -&amp;gt; tuple[int]&lt;/p&gt;
&lt;p&gt;表示連桿中含有的節點號碼，由輸入 str 逗號分隔值轉為內含 int 的 tuple 類型。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其實只需要 VPoint 類型即可表示整個連桿機構，但是為了使 Solvespace 與使用者較好判讀，加入 VLink 以輔助建模。&lt;/p&gt;
&lt;p&gt;不過在資料處理上，VPoint 會從 VLink 同步數據，因此必須先建立 VLink 才能加入節點。&lt;/p&gt;
&lt;p&gt;而 Drive shaft 的部份則可以選擇輸入的節點（預設為第一個點）。&lt;/p&gt;
&lt;p&gt;必須完成目標：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;轉換拓樸法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;須將含有多點的連桿轉換成呆鍊。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;防止搜尋法放入 Solvespace 時發生錯誤。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;SQL Database 檔案格式&lt;/h2&gt;
&lt;p&gt;這個版本由於必須打掉檔案格式重做，因此萌生使用新檔案格式的念頭。&lt;/p&gt;
&lt;p&gt;任務是使用 peewee 套件規劃出紀錄整個檔案資訊的格式，並且套上 Git 版次管理的功能。&lt;/p&gt;
&lt;p&gt;是否結合倉儲系統與加入帳戶驗證機制還在考慮中，目前是當成&lt;strong&gt;具有 Git 版本控制的檔案格式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;由於可以開分支修改，已經拿掉之前參數的功能。&lt;/p&gt;
&lt;p&gt;而 Pyslvs 可以透過 GUI 進行 add、commit、tag、push 至近端資料庫的功能，亦可進行 rebase 比較及預覽。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Planar Mechanism Kinematic Simulator 拓樸法簡介</title><link href="http://project.mde.tw/blog/planar-mechanism-kinematic-simulator-tuo-pu-fa-jian-jie.html" rel="alternate"></link><published>2017-08-27T21:00:00+08:00</published><updated>2017-08-27T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-08-27:blog/planar-mechanism-kinematic-simulator-tuo-pu-fa-jian-jie.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;目前 &lt;a href="http://designengrlab.github.io/PMKS/pmks.html"&gt;PMKS&lt;/a&gt; 拓樸法簡介&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 如何利用及修改範圍討論&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Planar Mechanism Kinematic Simulator&lt;/h1&gt;
&lt;p&gt;為了學習 PMKS 的拓樸法，因此在 Windows 平台的 Demo 網頁中摸索。&lt;/p&gt;
&lt;p&gt;網頁版的 PMKS 仍只能使用 IE 瀏覽器或是 macOS 的 Safari 載入，新的 Edge 都不行用。&lt;/p&gt;
&lt;p&gt;由於是 Silverlight 的關係，操作上沒有右鍵選單，相較於單機軟體仍有不便之處。&lt;/p&gt;
&lt;h2&gt;Graph-grammar 表格&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_08_27_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;可以看到右上角有一個表格，即為輸入表示式的表格，雖然操作上有所不便，但是測試後還是能將結構表現出來。&lt;/p&gt;
&lt;p&gt;表格的欄位從左到右如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Input：選擇輸入端，PMKS 是由輸入端當作起點，開始找尋周圍的點（浮動點無效）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Links：連桿節點表示式，使用逗號分隔。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Type of Joint：節點類型，分別如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;R：銷接。&lt;/li&gt;
&lt;li&gt;P：滑塊。&lt;/li&gt;
&lt;li&gt;RP：銷接於滑槽中。&lt;/li&gt;
&lt;li&gt;G：齒輪牙。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;X Pos.：X 軸初始位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Y Pos.：Y 軸初始位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Angle：使用在擁有旋轉自由度的節點上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;P：顯示位置路徑（固定點無效）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;V：顯示速度大小與方向（固定點無效）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A：顯示加速度大小與方向（固定點無效）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要新增節點，只要點到底部的欄位就會自動新增一行，刪除只要按「Remove Row」鈕即可。&lt;/p&gt;
&lt;h2&gt;Grammar&lt;/h2&gt;
&lt;p&gt;表示式儲存於節點，代表此節點&lt;strong&gt;所在的連桿&lt;/strong&gt;，因此節點為兩連桿的交點時，表示式就會儲存兩個連桿的名稱，以此類推。&lt;/p&gt;
&lt;p&gt;預設有一個連桿名稱為「ground」，代表接地，因此擁有此名稱的節點無法移動。&lt;/p&gt;
&lt;p&gt;連桿名稱皆為&lt;strong&gt;自訂&lt;/strong&gt;，只接受&lt;strong&gt;小寫字母&lt;/strong&gt;與&lt;strong&gt;非字首的數字&lt;/strong&gt;，不過很遺憾的是，圖面不會告訴你連桿名稱，只以顏色表示。&lt;/p&gt;
&lt;p&gt;以普通六連桿為例，對照如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_08_27_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;若只有一個節點使用新的連桿名稱，如下圖的「o」，會出現淡色的圓圈，此時也會記入旋轉對的自由度計算。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_08_27_03.png" /&gt;&lt;/p&gt;
&lt;h2&gt;優缺點分析&lt;/h2&gt;
&lt;p&gt;PMKS 目前有許多值得學習及利用的地方，應該都能配合完成，只是資料結構必須配合更改。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;優點：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;優秀的拓樸法及求解方式。&lt;/li&gt;
&lt;li&gt;此結構可以與 Python-Solvespace 整合。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺點：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;網頁介面操作及規劃十分不理想。&lt;/li&gt;
&lt;li&gt;利用性較少，目前只有 C# 程式庫、Excel 巨集、Silverlight 網頁介面三種。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根據 PMKS 的 Graph-grammar，只需要修改 1 種類型－－不過我打算做成節點以及連桿 2 種表達，設定節點以及所屬連桿即可。&lt;/p&gt;
&lt;p&gt;稍微思考了一下，若是套用至 Pyslvs：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;大幅減少 Pyslvs 的資源使用，因為只需要&lt;strong&gt;兩個表格&lt;/strong&gt;即可呈現表示法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 可能得重新規劃資料格式以及檔案格式，並且會花較久的時間。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;關於模仿 Linkage 的部分，由於 PMKS 精簡的 grammar，因此可能目前 Pyslvs 的新增選取功能就夠用了。必要的話應也能做拖移節點的功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;先維持使用 Python-Solvespace 解題，因為 PMKS 拓樸法並不支援 1 個以上的輸入，但是 Pyslvs 這邊能轉給 Solvespace 解多重輸入的功能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由於 v0.9 目前更新量不大，因此若要加入 PMKS 的概念，就會在此版本發布。&lt;/p&gt;
&lt;p&gt;有了 1 年多的 Python 開發經驗，應該能在下學期中完成這個計畫。&lt;/p&gt;</summary><category term="PMKS"></category></entry><entry><title>Pyslvs 開發進度 - 08/25</title><link href="http://project.mde.tw/blog/pyslvs-kai-fa-jin-du-0825.html" rel="alternate"></link><published>2017-08-25T21:00:00+08:00</published><updated>2017-08-25T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-08-25:blog/pyslvs-kai-fa-jin-du-0825.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Functional trangle solver&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Functional trangle solver&lt;/h1&gt;
&lt;p&gt;由於要加入速度與加速度的計算，因此決定由三角形的 solver 下手，透過 SymPy 模組協助解題，獲得 x 和 y 軸的分量。&lt;/p&gt;
&lt;p&gt;編寫概念類似 PMKS 將方程式存起來，因此每個點都會先獲得一個位置函式，接收數值為角速度 ω 與時間 t：&lt;/p&gt;
&lt;div class="math"&gt;$$f_{x,y}(\omega,t)$$&lt;/div&gt;
&lt;p&gt;首先要定義幾個類型方便計算：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from sympy import pi, sqrt, cos, sin, acos, asin, diff, lambdify
from sympy.abc import w, t

class Coordinate:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    #兩座標距離
    def distance(self, p):
        '''
        Coordinate p
        '''
        return sqrt((p.x - self.x)**2 + (p.y - self.y)**2)

    #兩座標與水平軸夾角
    def m(self, p):
        '''
        Coordinate p
        '''
        return asin((p.y - self.y)/self.distance(p))

    #若分量為 SymPy 函式，將其 Lambda 化回傳
    @property
    def functions(self):
        return (
            lambdify((t, w), self.x),
            lambdify((t, w), self.y))

class FunctionBase:
    '''
    Input Coordinate should get from position function.
    '''

    #位置方程式
    @property
    def p(self):
        return Coordinate(self.pxFunc, self.pyFunc)

    #速度方程式：微分 1 次
    @property
    def v(self):
        return Coordinate(diff(self.pxFunc, t), diff(self.pyFunc, t))

    #加速度方程式：微分 2 次
    @property
    def a(self):
        return Coordinate(diff(self.pxFunc, t, 2), diff(self.pyFunc, t, 2))

    #急跳度方程式：微分 3 次
    @property
    def j(self):
        return Coordinate(diff(self.pxFunc, t, 3), diff(self.pyFunc, t, 3))
&lt;/pre&gt;

&lt;p&gt;用兩個固定點可以得到繞行旋轉軸的點座標，接著再構建出其他點的位置。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_08_25_01.png" /&gt;&lt;/p&gt;
&lt;h2&gt;PLAP&lt;/h2&gt;
&lt;p&gt;由於輸入項目由角度取代成代數，之前的 PLAP 函式改為 PL 函式，輸入連桿與軸端的座標即可。&lt;/p&gt;
&lt;p&gt;這裡採用的是圓周運動公式：&lt;/p&gt;
&lt;div class="math"&gt;$$\left | \vec{x} \right | = r\,  cos\, \theta$$&lt;/div&gt;
&lt;div class="math"&gt;$$\left | \vec{y} \right | = r\,  sin\, \theta$$&lt;/div&gt;
&lt;p&gt;Python 程式：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
class pl(FunctionBase):
    def __init__(self, A, L):
        self.pxFunc = A.x+L*cos(w*t)
        self.pyFunc = A.y+L*sin(w*t)
&lt;/pre&gt;

&lt;h2&gt;PLLP&lt;/h2&gt;
&lt;p&gt;使用底邊夾角與餘弦定理得到座標。&lt;/p&gt;
&lt;div class="math"&gt;$$\alpha = sin^{-1}(\frac{y_{B}-y_{A}}{\sqrt{(x_{B}-x_{A})^{2}+(y_{B}-y_{A})^{2}}})$$&lt;/div&gt;
&lt;div class="math"&gt;$$\beta = cos^{-1}(\frac{L^{2}+L_{b}^{2}-R^{2}}{2\times L\times L_{b}})$$&lt;/div&gt;
&lt;p&gt;正向：&lt;/p&gt;
&lt;div class="math"&gt;$$x = x_{A}+L\, cos(\alpha+\beta)$$&lt;/div&gt;
&lt;div class="math"&gt;$$y = y_{A}+L\, cos(\alpha+\beta)$$&lt;/div&gt;
&lt;p&gt;反向：&lt;/p&gt;
&lt;div class="math"&gt;$$x = x_{A}+L\, cos(\alpha-\beta)$$&lt;/div&gt;
&lt;div class="math"&gt;$$y = y_{A}+L\, cos(\alpha-\beta)$$&lt;/div&gt;
&lt;p&gt;Python 程式：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
class pllp(FunctionBase):
    def __init__(self, A, L, R, B, reverse=False):
        alpha = A.m(B)
        base = A.distance(B)
        beta = acos((L**2 + base**2 - R**2)/(2*L*base))
        if reverse:
            self.pxFunc = A.x+L*cos(alpha-beta)
            self.pyFunc = A.y+L*sin(alpha-beta)
        else:
            self.pxFunc = A.x+L*cos(alpha+beta)
            self.pyFunc = A.y+L*sin(alpha+beta)
&lt;/pre&gt;

&lt;h2&gt;套入四連桿範例&lt;/h2&gt;
&lt;p&gt;應用到標準曲柄搖桿範例後，可以繪出四者的曲線圖。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_08_25_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;通過 solver 這個函式輸入連桿參數：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def solver(mechanism, progress=False):
    results = []
    resultCount = len(mechanism)
    for i, e in enumerate(mechanism):
        if len(e)==2:
            foo = pl(*e)
            results.append(foo)
        else:
            e = list(e)
            if type(e[0])==int:
                e[0] = results[e[0]].p
            if type(e[3])==int:
                e[3] = results[e[3]].p
            foo = pllp(*e)
            results.append(foo)
        if progress:
            print("{} / {}".format(i+1, resultCount))
    return results
&lt;/pre&gt;

&lt;p&gt;最後會回傳一組函式物件，可以透過 FunctionBase 和 Coordinate 類型的方法取值。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
p0 = Coordinate(0, 0)
p1 = Coordinate(90, 0)
results = solver([
        (p0, 35.), #p2
        (0, 70., 70., p1), #p3
        (0, 40., 40., 1), #p4
], progress=True)

W = pi/180 #rad/s
for T in range(0, 360+1, 5):
    xfun, yfun = results[2].p.functions
    print("{}\t{}".format(xfun(T, W), yfun(T, W)))
&lt;/pre&gt;

&lt;p&gt;亦可使用 matplotlib 繪出資料。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
W = pi/180 #rad/s
plot = []
for T in range(0, 360+1, 5):
    plot.append((xfun(T, W), yfun(T, W)))
import matplotlib.pyplot as plt
plt.plot(plot)
plt.show()
&lt;/pre&gt;

&lt;p&gt;不過反覆測試之後，發現竟然沒辦法套用原本八連桿的配置。&lt;/p&gt;
&lt;p&gt;這方面還在解決中，看看是輸入方面還是解題方程式哪裡出了問題。&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Pyslvs 開發進度 - 08/22</title><link href="http://project.mde.tw/blog/pyslvs-kai-fa-jin-du-0822.html" rel="alternate"></link><published>2017-08-22T21:00:00+08:00</published><updated>2017-08-22T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-08-22:blog/pyslvs-kai-fa-jin-du-0822.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Version 0.9 目標&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Version 0.9 目標&lt;/h1&gt;
&lt;p&gt;將自改版後完成的項目列出來：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;重新設定 QTableWidget。&lt;/p&gt;
&lt;p&gt;手寫 QTableWidget 的功能，這意味著很多功能可以直接連結表格元件，資料格式應該轉為直接連動的方式，會更節省途中暫存的空間。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目標&lt;/strong&gt;：重新設計 QTableWidget 資料存取方式，已有初步規劃。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更直覺的畫布選取。&lt;/p&gt;
&lt;p&gt;由於上述 QTableWidget 的改寫，可以達成滑鼠與表格元件的選取狀態一致，甚至有觸發編輯的功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目標&lt;/strong&gt;：添加額外互動功能，視需求而定，目前可能無法作到 Solvespace 直接拖動的效果，但是對於還未有連結關係的點可以考慮。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重新整理部份函式&lt;/p&gt;
&lt;p&gt;以前寫的功能雜亂且不明確，沒符合 PEP 8 的格式。v0.8 發布時有大量修正，不過還有指標亂用的情況，目前只有小部份的整理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目標&lt;/strong&gt;：減少函式和轉送數據的用量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之後預計會加入演算法結果的速度、加速度分析功能，目前可以推導出四連桿的角度，不知道有沒有八連桿的相關資料？&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Qt Drag and Drop 教學</title><link href="http://project.mde.tw/blog/qt-drag-and-drop-jiao-xue.html" rel="alternate"></link><published>2017-08-21T21:00:00+08:00</published><updated>2017-08-21T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-08-21:blog/qt-drag-and-drop-jiao-xue.html</id><summary type="html">&lt;p&gt;Pyslvs v0.9 新功能測試及解說&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何在 Qt 框架中達成 Widgets 間的滑鼠資訊轉移&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Qt Drag and Drop&lt;/h1&gt;
&lt;p&gt;詳細說明可以參考這裡：&lt;a href="http://doc.qt.io/qt-5/dnd.html"&gt;http://doc.qt.io/qt-5/dnd.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Pyslvs v0.9 新功能影片：&lt;/p&gt;
&lt;iframe width="854" height="480" src="https://www.youtube.com/embed/54sy6nNWdV8" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;

&lt;h2&gt;動作解析&lt;/h2&gt;
&lt;p&gt;在不同的桌面系統中，滑鼠的拖放動作都已經透過 Qt 框架轉化成以下幾個動作：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;從 AWidget 到 BWidget。&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;抓起？（AWidget::&lt;code&gt;mousePressEvent&lt;/code&gt; / &lt;code&gt;mouseReleaseEvent&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;移出（AWidget::&lt;code&gt;mouseMoveEvent&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;移入（BWidget::&lt;code&gt;dragEnterEvent&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;橫越（BWidget::&lt;code&gt;dragMoveEvent&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;放下（BWidget::&lt;code&gt;dropEvent&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下來按照步驟配置所需的函式。&lt;/p&gt;
&lt;p&gt;第一步就是開啟拖放置功能，以允許丟東西在 QWidget 中：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
class BWidget(QWidget):
    def __init__(self, parent=None):
        super(BWidget, self).__init__(parent)
        self.setAcceptDrops(True)
&lt;/pre&gt;

&lt;p&gt;需要注意的是，上述的這些 QEvent 函式&lt;strong&gt;都是私有的&lt;/strong&gt;，意即無法（Python 其實可以強制設定，但是很難看）透過外部撰寫。&lt;/p&gt;
&lt;p&gt;上面這句話的意思是，&lt;strong&gt;不能用 QtDesigner 來佈置這些 Widget！&lt;/strong&gt;請按部就班繼承改寫新 Class，用指令插入 Layout 裡。&lt;/p&gt;
&lt;p&gt;這邊就不再介紹如何手動放這些 Widget 了，較不瞭解的初學者可以用 QtDesigner 拉出 QLayout 後用 &lt;code&gt;insertWidget&lt;/code&gt; 指令達成。&lt;/p&gt;
&lt;h2&gt;抓起？（AWidget::&lt;code&gt;mousePressEvent&lt;/code&gt; / &lt;code&gt;mouseReleaseEvent&lt;/code&gt;）&lt;/h2&gt;
&lt;p&gt;這個函式專門處理 AWidget 中任何按下滑鼠的動作，因此如果你的 AWidget 並非原始無瑕的 QWidget，那 Qt 早已設定過一些互動函式了。&lt;/p&gt;
&lt;p&gt;在 Python 中，子 Class 的新 method 若和任何父項 method 撞名，會造成覆蓋。為了不讓 Qt 的設定功能失效，請使用 super 函式讓 Qt 先做完應有的工作。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
class AWidget(QWidget):
    def mousePressEvent(self, event):
        super(AWidget, self).mousePressEvent(event)

    def mouseReleaseEvent(self, event):
        super(AWidget, self).mouseReleaseEvent(event)
&lt;/pre&gt;

&lt;p&gt;接下來的 QEvent 函式都是一樣，如果不小心蓋掉發生怪怪的狀況，例如 QTableWidget 無法再選起儲存格，那就加上 super 補上被忽略的工作。&lt;/p&gt;
&lt;p&gt;言歸正傳，由於「按下滑鼠」這個事件不一定是想抓東西來拖移，因此不能就這樣亂槍打鳥，要先偷偷紀錄其的行為。在這裡設定一個名稱「draged」紀錄滑鼠的動作，決定是否為滑鼠左鍵抓住的動作。&lt;/p&gt;
&lt;p&gt;放掉滑鼠的話就把這個值取消，表示使用者並沒有做出拖動的行為。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
class AWidget(QWidget):
    def __init__(self, parent=None):
        super(AWidget, self).__init__(parent)
        self.draged = False

    def mousePressEvent(self, event):
        super(AWidget, self).mousePressEvent(event)
        if event.button()==Qt.LeftButton:
            self.draged = True

    def mouseReleaseEvent(self, event):
        super(AWidget, self).mouseReleaseEvent(event)
        self.draged = False
&lt;/pre&gt;

&lt;h2&gt;移出（AWidget::&lt;code&gt;mouseMoveEvent&lt;/code&gt;）&lt;/h2&gt;
&lt;p&gt;這個函式專門處理 AWidget 中滑鼠移動的動作，也包括憑空移動，因此剛才設定的「draged」可以告訴我們，使用者正想要「拿著東西移動」。&lt;/p&gt;
&lt;p&gt;既然想拿東西，就必須把東西打包交給使用者，一般普遍為文字資訊，包裝後在 BWidget 解開，亦可以攜帶圖片、網址、HTML、顏色資訊。&lt;/p&gt;
&lt;p&gt;這裡介紹兩個新的 Qt Class：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;QMimeData：行李箱，將一堆雜亂的行李分裝後包起來。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;QDrag：送貨員，可以附上一張圖片以辨識該行李的內容，另外送貨員知道寄件者地址（AWidget）、滑鼠停駐點等資訊，也可以幫旅行中的滑鼠換外觀。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下來就來裝箱吧，根據 Pyslvs 的影片，我們可以推測出攜帶的資訊為 AWidget 的「被選擇行號」，因此透過一段小迴圈篩選出所有被選擇的行號。&lt;/p&gt;
&lt;p&gt;用 Python 的 set 集合型態可以將重複選取的內容排除掉，接著重新排序轉回 list 類型儲存。&lt;/p&gt;
&lt;p&gt;而 QTableWidget 的 mouseMoveEvent 其實有「按住連續選取」的功能，但是這樣會干擾我們拖移的行為，因此這邊不使用 super。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
class AWidget(QTableWidget):
    def selectedRows(self):
        a = list()
        for r in self.selectedRanges():
            a += [i for i in range(r.topRow(), r.bottomRow()+1)]
        return sorted(set(a))

    def mouseMoveEvent(self, event):
        if self.draged:
            selectedRows = self.selectedRows()
            selectedRowCount = len(selectedRows)
            if selectedRowCount==2 or selectedRowCount==3:
                drag = QDrag(self)
                mimeData = QMimeData()
                mimeData.setText(';'.join([str(e) for e in selectedRows]))
                drag.setMimeData(mimeData)
                drag.setPixmap(QPixmap(":/icons/tooltips/need{}bearings.png".format(selectedRowCount)).scaledToWidth(50))
                drag.exec_()
&lt;/pre&gt;

&lt;p&gt;由於下方的表格需要 2 或 3 個選取的行號，因此以外的選項我們一律不接受。&lt;/p&gt;
&lt;p&gt;行號資訊型態是 int，這邊轉換成字串後用分號 &lt;code&gt;;&lt;/code&gt; 包裝起來。而這裡還有設定 &lt;code&gt;need{}bearings.png&lt;/code&gt; 的圖片，表示拿了 2 個或 3 個「軸承」。&lt;/p&gt;
&lt;p&gt;最後下的 &lt;code&gt;drag.exec_()&lt;/code&gt; 方法為延遲函式，表示送貨員已出發，它會一直等到貨物到達或被丟棄時才會回傳，因此要注意不要讓執行序被阻塞。&lt;/p&gt;
&lt;h2&gt;移入（BWidget::&lt;code&gt;dragEnterEvent&lt;/code&gt;）&lt;/h2&gt;
&lt;p&gt;這個函式專門處理 BWidget 中滑鼠&lt;strong&gt;帶著資訊進入&lt;/strong&gt;的動作。這裡的 event 物件已經被 Qt 轉換成我們的送貨員，與剛才的 QDrag 物件有一定程度的相仿。要使用審核機制來判別這個送貨員是不是我們要接受的對象。&lt;/p&gt;
&lt;p&gt;要如何審核呢？有兩種結果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;code&gt;acceptProposedAction&lt;/code&gt; 方法接受這名送貨員進入 BWidget 的領域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用一般的 &lt;code&gt;ignore&lt;/code&gt; 方法無視這名送貨員，或是乾脆不理他，會造成滑鼠游標出現類似禁止的符號，依你的桌面系統而定。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;被允許的送貨員能在進入的時候，依你的桌面系統出現類似抓著資訊的樣式，這時可以選擇是否放開以丟下資訊，或是將資訊帶走（我只是路過），不一定會送達 BWidget。&lt;/p&gt;
&lt;p&gt;若是送貨員在此處被禁止投遞，卻仍然放開滑鼠，那他手中的資訊就會遺失，而且會無法重新取得（除非回到 AWidget 再打包）。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
class BWidget(QTableWidget):
    def dragEnterEvent(self, event):
        mimeData = event.mimeData()
        if mimeData.hasText():
            if len(mimeData.text().split(';'))==self.bearings:
                event.acceptProposedAction()
&lt;/pre&gt;

&lt;p&gt;這邊的程式中，&lt;code&gt;self.bearings&lt;/code&gt; 為允許的行號數，例如連桿表格為 2 個，當拆解用 &lt;code&gt;;&lt;/code&gt; 分號封裝的字串時，數量為 2 個，那此貨物就允許進入。&lt;/p&gt;
&lt;h2&gt;橫越（BWidget::&lt;code&gt;dragMoveEvent&lt;/code&gt;）&lt;/h2&gt;
&lt;p&gt;某些列表式的 QWidget，例如 QTableView、QListView、QTreeView，其實會內建清單拖移功能，讓使用者可以直接拖動儲存格，插到自己或是其他相同類型的 QWidget 中，而且不用自己寫 QEvent 函式，只是這些功能預設是關閉的。&lt;/p&gt;
&lt;p&gt;由於上述原因，我們得將自訂送貨員打扮成上面較特殊 QWidget 的送貨員，否則這些類型會不允許他送進資訊，即使在上一小節中已經允許。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
class BWidget(QTableWidget):
    def dragMoveEvent(self, event):
        event.setDropAction(Qt.MoveAction)
        event.accept()
&lt;/pre&gt;

&lt;p&gt;這些特殊 QWidget 的送貨員會攜帶「放置行為」，如「遷移」、「複製」等等，因此將我們的送貨員設定為常見的 &lt;code&gt;Qt.MoveAction&lt;/code&gt; 即可。&lt;/p&gt;
&lt;p&gt;若是其他沒有這種 items 的 QWidget，是不用設定此步驟的。&lt;/p&gt;
&lt;h2&gt;放下（BWidget::&lt;code&gt;dropEvent&lt;/code&gt;）&lt;/h2&gt;
&lt;p&gt;終於到最後一步了，送貨員最終決定在此投遞，因此必須在此拆包，執行相關的函式。&lt;/p&gt;
&lt;p&gt;為了方便，這裡與外界溝通的方式是使用信號槽將所有行號拆包發送出去，使用的是 &lt;code&gt;self.dragIn&lt;/code&gt; 這個信號。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
class BWidget(QTableWidget):
    def dropEvent(self, event):
        self.dragIn.emit(*[int(e) for e in event.mimeData().text().split(';')])
        event.acceptProposedAction()
&lt;/pre&gt;

&lt;p&gt;最後，還是要執行 &lt;code&gt;acceptProposedAction&lt;/code&gt; 方法，才會關閉此事件。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;之前介紹過如何接收外部拖入檔案，在程式中開啟的方法：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://project.mde.tw/blog/40323230ri-zhi-1060116.html"&gt;http://project.mde.tw/blog/40323230ri-zhi-1060116.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這次挑戰較複雜的，在 Qt Widget 中抓起資訊的方式。&lt;/p&gt;
&lt;p&gt;這三種 QTableWidget 的獨立原始碼提供在這裡，因為這其中的設定還透過繼承方式簡化函式，會較整齊些。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/dndExample.txt"&gt;https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/dndExample.txt&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以透過對照的方式看看自己寫的是否完整。&lt;/p&gt;</summary><category term="Pyslvs"></category><category term="PyQt5"></category></entry><entry><title>Pyslvs 開發進度 - 08/10</title><link href="http://project.mde.tw/blog/pyslvs-kai-fa-jin-du-0810.html" rel="alternate"></link><published>2017-08-10T21:00:00+08:00</published><updated>2017-08-10T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-08-10:blog/pyslvs-kai-fa-jin-du-0810.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Version 0.8 Release&lt;/li&gt;
&lt;li&gt;Version 0.8 後續更新&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Version 0.8 Release&lt;/h1&gt;
&lt;p&gt;由於之後還會做一些較大的改動，為了取代目前較不穩定的 v0.7，釋出 v0.8 將已經較成熟的演算法功能供倉儲展示。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_08_10_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;提供資源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Kubuntu debian 安裝包大小：78.3 MB&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python 3.5&lt;/li&gt;
&lt;li&gt;Qt 5.9.1&lt;/li&gt;
&lt;li&gt;PyQt 5.9&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Ubuntu 可能受因於支援 desktop 系統，有較多的 Python 相依套件，目前似乎只能給 KDE 環境使用。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;因此 Linux 建議還是使用原始碼編譯。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Windows 獨立可執行檔案：37.2 MB&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python 3.5&lt;/li&gt;
&lt;li&gt;Qt 5.9.1&lt;/li&gt;
&lt;li&gt;PyQt 5.9&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;新功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用者介面改進。&lt;/li&gt;
&lt;li&gt;演算法功能有了大幅的強化。&lt;/li&gt;
&lt;li&gt;演算法的簡單 TCP ZMQ 連線功能。&lt;/li&gt;
&lt;li&gt;新版 Python-Solvespace 核心，對應至 Solvespace 2.3。&lt;/li&gt;
&lt;li&gt;一個新的 Makefile 編譯流程，會包含兩個核心函式庫。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中新版 Python-Solvespace 核心受益於 Solvespace 近年來的優化，&lt;strong&gt;執行效率比 2013 年的版本更快&lt;/strong&gt;，而且特定角度解題失敗的情況也被改善了。&lt;/p&gt;
&lt;h1&gt;Version 0.8 後續更新&lt;/h1&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_08_10_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;釋出 v0.8.0 後，會再持續提供 v0.8 的更新，強化各項功能。&lt;/p&gt;
&lt;p&gt;介面稍微整理過，將 History 與 Panels 標籤放至左側，較好切換機構的數據與執行額外操作。&lt;/p&gt;
&lt;p&gt;接下來幾天會整理 Python-Solvespace kernel 的 API，預計是寫在之前網誌中英文版介紹 Python-Solvespace 的文章。&lt;/p&gt;
&lt;p&gt;而排版會打掉整理得更清晰，仿照 Qt 的 C++ 格式撰寫。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Python-Solvespace Update - Windows</title><link href="http://project.mde.tw/blog/python-solvespace-update-windows.html" rel="alternate"></link><published>2017-08-09T21:00:00+08:00</published><updated>2017-08-09T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-08-09:blog/python-solvespace-update-windows.html</id><summary type="html">&lt;p&gt;測試並改良 Python-Solvespace wrapper：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;端口更新相容至 Windows 平台&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;端口更新&lt;/h1&gt;
&lt;p&gt;在 Windows 平台由於使用 MinGW 編譯，因此不會用到 Visual studio 的工具。&lt;/p&gt;
&lt;p&gt;在編譯流程的測試上，也須要更多設定。&lt;/p&gt;
&lt;h2&gt;平台差異&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Define &lt;code&gt;WIN32&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;大部分 C++ 的 Windows 腳本要求都放在此定義中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Define &lt;code&gt;_USE_MATH_DEFINES&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;加入此值表示使用 &lt;code&gt;cmath&lt;/code&gt; 的內容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加入 &lt;code&gt;platform/platform.cpp&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;切換成 &lt;code&gt;platform/w32util.cpp&lt;/code&gt; 後，其中會用到 &lt;code&gt;platform/platform.cpp&lt;/code&gt; 的 &lt;code&gt;Platform::Narrow(wchar_t)&lt;/code&gt; 函式。&lt;/p&gt;
&lt;p&gt;因此會加入 &lt;code&gt;platform.o&lt;/code&gt; 的編譯需求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加入 &lt;code&gt;config.h&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;原先的 &lt;code&gt;config.h&lt;/code&gt; 有紀錄一些設定：Solvespace 版本、安裝位置、GL 函式庫版本，不過是透過 CMake 填入樣板 &lt;code&gt;config.h.in&lt;/code&gt; 產生的。&lt;/p&gt;
&lt;p&gt;顯然之後配置 CMake list 的時候沒有為獨立 solver 做切割。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;platform/platform.cpp&lt;/code&gt; 只是 &lt;code&gt;FindLocalResourceDir&lt;/code&gt; 函式需要用到 &lt;code&gt;UNIX_DATADIR&lt;/code&gt; 而載入，因此修改 CMake 的 template，有定義 &lt;code&gt;UNIX_DATADIR&lt;/code&gt; 即可，路徑亂給也不會用到。&lt;/p&gt;
&lt;p&gt;標頭檔不需要寫給編譯器看，只要放著即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;綜上述要求，Makefile 執行時會先做這些步驟：&lt;/p&gt;
&lt;pre class="brush: Makefile"&gt;
ifeq ($(OS), Windows_NT)
    CFLAGS += -DWIN32 -D_USE_MATH_DEFINES
    OFILES += $(OBJDIR)/w32util.o $(OBJDIR)/platform.o
else
    OFILES += $(OBJDIR)/unixutil.o
endif
&lt;/pre&gt;

&lt;p&gt;提醒一下，由於設定了 Makefile 的 VPATH 參數，相當於 Python 的 &lt;code&gt;sys.path&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;有紀錄 &lt;code&gt;src&lt;/code&gt; 和 &lt;code&gt;src/platform&lt;/code&gt;，可以用 &lt;code&gt;%&lt;/code&gt; 符號來在這些區域中搜尋原始碼，不過要注意撞名問題。&lt;/p&gt;
&lt;p&gt;因此可以從 &lt;code&gt;$(OBJDIR)/%.o: %.cpp $(OBJDIR)&lt;/code&gt; 這個 target 中抓到 &lt;code&gt;$(OBJDIR)/platform.o&lt;/code&gt; 的位置 &lt;code&gt;src/platform/platform.cpp&lt;/code&gt;。&lt;/p&gt;
&lt;pre class="brush: Makefile"&gt;
VPATH = src src/platform
&lt;/pre&gt;

&lt;p&gt;同理，若存在其他目錄的原始碼，想用 &lt;code&gt;%.cpp&lt;/code&gt; 轉 &lt;code&gt;%.o&lt;/code&gt; 的指令寫簡單一點，就必須把目錄加到 VPATH。&lt;/p&gt;
&lt;h2&gt;編譯測試&lt;/h2&gt;
&lt;p&gt;原本想讓 &lt;code&gt;platform/w32util.cpp&lt;/code&gt; 簡單一點，不使用 &lt;code&gt;platform/platform.cpp&lt;/code&gt;，於是切斷了 &lt;code&gt;InitPlatform&lt;/code&gt; 函式的連結，改成類 Unix 平台的方式回傳，沒想到編譯出來後，Python 載入動態函式庫會馬上卡死無法執行，而且也不會回報錯誤。&lt;/p&gt;
&lt;p&gt;因此只好連同編譯 &lt;code&gt;platform/platform.cpp&lt;/code&gt;，不過又遇到 &lt;code&gt;LoadResource&lt;/code&gt; 函式中使用的 &lt;code&gt;FindResourceW&lt;/code&gt; 函式有類型轉換問題。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
HRSRC hres = FindResourceW(NULL, Widen(name).c_str(), RT_RCDATA);
&lt;/pre&gt;

&lt;pre&gt;
cannot convert 'LPSTR {aka char*}' to 'LPCWSTR {aka const wchar_t*}' for argument '3' to
'HRSRC__* FindResourceW(HMODULE, LPCWSTR, LPCWSTR)'
&lt;/pre&gt;

&lt;p&gt;指的是第 3 個參數 &lt;code&gt;RT_RCDATA&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;據測應該是 &lt;code&gt;Windows.h&lt;/code&gt; 的函式，因此上網查詢此函式的接收值。&lt;/p&gt;
&lt;p&gt;其中為 &lt;code&gt;FindResource&lt;/code&gt;、&lt;code&gt;FindResourceW&lt;/code&gt;、&lt;code&gt;FindResourceA&lt;/code&gt; 的原型，只差在編碼不同，&lt;code&gt;FindResourceW&lt;/code&gt; 是 UTF 的形式。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
HRSRC WINAPI FindResource(
  _In_opt_ HMODULE hModule,
  _In_     LPCTSTR lpName,
  _In_     LPCTSTR lpType
);
&lt;/pre&gt;

&lt;p&gt;其中有列出 &lt;code&gt;lpType&lt;/code&gt; 第 3 個參數可以使用的對象，但是其中明明就有 &lt;code&gt;RT_RCDATA&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;出於無奈，搜尋使用此函式的原始碼，發現都不是 solver 的，加上 &lt;code&gt;#if !defined(LIBRARY)&lt;/code&gt; 的要求後，編譯 solver 就不會用到。&lt;/p&gt;
&lt;p&gt;最後終於編譯成功了，而且測試用的 Python script 可以正常執行。&lt;/p&gt;
&lt;p&gt;還在考慮如何收拾目錄中編譯後的檔案，讓程式庫不會跟暫存的檔案混在一起，整理之後應該就能整合進 Pyslvs 了。&lt;/p&gt;</summary><category term="Solvespace"></category></entry><entry><title>Python-Solvespace Update - Ubuntu</title><link href="http://project.mde.tw/blog/python-solvespace-update-ubuntu.html" rel="alternate"></link><published>2017-08-08T21:00:00+08:00</published><updated>2017-08-08T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-08-08:blog/python-solvespace-update-ubuntu.html</id><summary type="html">&lt;p&gt;測試並改良 Python-Solvespace wrapper：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;端口更新至 Solvespace 2.3 (Ubuntu only)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;em&gt;註：&lt;a href="https://github.com/solvespace/solvespace"&gt;官方&lt;/a&gt; 抑或 &lt;a href="https://github.com/whitequark/solvespace"&gt;whitequark&lt;/a&gt; 提供的原始碼中，並沒有再提供獨立編譯 solver 的流程，只有圖形化使用者介面 (GUI) 和命令列介面 (CLI) 的版本。&lt;/em&gt;&lt;/p&gt;
&lt;h1&gt;端口更新&lt;/h1&gt;
&lt;p&gt;已將 Solvespace 2.3 的 solver 原始碼更新至倉儲中。&lt;/p&gt;
&lt;p&gt;在 Ubuntu 平台測試編譯成功後，將此程式庫連結至 cdemo 編譯，測試無誤。&lt;/p&gt;
&lt;p&gt;至於 Windows 平台發現原始碼似乎沒有與介面分離得很徹底，可能要處理 &lt;code&gt;platform/w32util.cpp&lt;/code&gt; 的問題。&lt;/p&gt;
&lt;h2&gt;SWIG 端口測試&lt;/h2&gt;
&lt;p&gt;先嘗試將 &lt;code&gt;slvs_python.hpp&lt;/code&gt; 與 &lt;code&gt;slvs.i&lt;/code&gt; 移至目錄中，修改路徑後編譯測試。&lt;/p&gt;
&lt;p&gt;接著發現 Slvs_MakeConstraint 函式簡化了輸入的 argument。&lt;/p&gt;
&lt;pre class="brush: c++"&gt;
static Slvs_Constraint Slvs_MakeConstraint(Slvs_hConstraint h,
                                           Slvs_hGroup group,
                                           int type,
                                           Slvs_hEntity wrkpl,
                                           double valA,
                                           Slvs_hEntity ptA,
                                           Slvs_hEntity ptB,
                                           Slvs_hEntity entityA,
                                           Slvs_hEntity entityB,
                                           Slvs_hEntity entityC,
                                           Slvs_hEntity entityD,
                                           bool other,
                                           bool other2)
&lt;/pre&gt;

&lt;p&gt;將最後 4 個項目移除並展開指令：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
static inline Slvs_Constraint Slvs_MakeConstraint(Slvs_hConstraint h,
                                                  Slvs_hGroup group,
                                                  int type,
                                                  Slvs_hEntity wrkpl,
                                                  double valA,
                                                  Slvs_hEntity ptA,
                                                  Slvs_hEntity ptB,
                                                  Slvs_hEntity entityA,
                                                  Slvs_hEntity entityB)
&lt;/pre&gt;

&lt;p&gt;連同改正 &lt;code&gt;slvs_python.hpp&lt;/code&gt; 與 &lt;code&gt;slvs.i&lt;/code&gt; 的內容後，發現 &lt;code&gt;System::solve()&lt;/code&gt; 函式的 wrapper 發生無法轉換類型的情況。&lt;/p&gt;
&lt;pre&gt;
result = sys.solve()
...
return _slvs.System_solve(self, hg)
NotImplementedError: Wrong number or type of arguments for overloaded function 'System_solve'.
Possible C/C++ prototypes are:
    System::solve(Slvs_hGroup)
    System::solve()
&lt;/pre&gt;

&lt;p&gt;位於 System 類型的 solve 方法只是指定群組求解，沒有給定群組的話就使用預設群組。&lt;/p&gt;
&lt;p&gt;解決之道是分離成兩個函式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;System::solveFor(Slvs_hGroup)&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;指定群組求解，輸入群組數值（非指標）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;System::solve()&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;使用預設群組。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如此一來，新版的 Solvespace solver 已通過測試，需要再建立 Windows 編譯流程後才能完全更新倉儲和連動至 Pyslvs。&lt;/p&gt;
&lt;p&gt;不過 Windows 遭遇了一些平台問題，官方後來使用 Visual studio 為基礎寫的輔助函式，某些在 MinGW 中會出現一些錯誤。&lt;/p&gt;
&lt;p&gt;另外，稍微閱讀了一下以前 Python-Solvespace 作者的 &lt;code&gt;slvs_python.hpp&lt;/code&gt; 標頭檔，似乎還有很多供 Python 方便使用物件化的函式和方法，是否要為其製作 API 說明文件（例如簡單的 Github Wiki），供 Solvespace 官方或 whitequark 參考？&lt;/p&gt;</summary><category term="Solvespace"></category></entry><entry><title>Pyslvs 開發進度 - 08/04</title><link href="http://project.mde.tw/blog/pyslvs-kai-fa-jin-du-0804.html" rel="alternate"></link><published>2017-08-04T21:00:00+08:00</published><updated>2017-08-04T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-08-04:blog/pyslvs-kai-fa-jin-du-0804.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新版 Solvespace 獨立 solver 編譯成功&lt;/li&gt;
&lt;li&gt;長時演算模式&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Solvespace solver&lt;/h1&gt;
&lt;p&gt;根據新版 CMake list 任務，找到 solver 所需的 source code 與 header。&lt;/p&gt;
&lt;h2&gt;Sources&lt;/h2&gt;
&lt;p&gt;須注意要辨認平台選擇 platform 目錄中的檔案，否則會有找不到 &lt;code&gt;windows.h&lt;/code&gt; 之類的錯誤發生。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;constraint.cpp&lt;/li&gt;
&lt;li&gt;constrainteq.cpp&lt;/li&gt;
&lt;li&gt;entity.cpp&lt;/li&gt;
&lt;li&gt;expr.cpp&lt;/li&gt;
&lt;li&gt;lib.cpp&lt;/li&gt;
&lt;li&gt;system.cpp&lt;/li&gt;
&lt;li&gt;util.cpp&lt;/li&gt;
&lt;li&gt;platform/platform.cpp&lt;/li&gt;
&lt;li&gt;platform/w32util.cpp (Windows)&lt;/li&gt;
&lt;li&gt;platform/unixutil.cpp (Unix)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Headers&lt;/h2&gt;
&lt;p&gt;雖然只會用到 &lt;code&gt;solvespace.h&lt;/code&gt; 和 &lt;code&gt;platform.h&lt;/code&gt;，但是由於 &lt;code&gt;solvespace.h&lt;/code&gt; 會 include 其他標頭檔，所以還是得附在目錄中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dsc.h&lt;/li&gt;
&lt;li&gt;expr.h&lt;/li&gt;
&lt;li&gt;polygon.h&lt;/li&gt;
&lt;li&gt;resource.h&lt;/li&gt;
&lt;li&gt;sketch.h&lt;/li&gt;
&lt;li&gt;solvespace.h&lt;/li&gt;
&lt;li&gt;ttf.h&lt;/li&gt;
&lt;li&gt;ui.h&lt;/li&gt;
&lt;li&gt;platform/platform.h&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接著將所有 sources 編譯成 obj 檔，由於是較新版規則，在 g++ 中加入 &lt;code&gt;-std=c++11&lt;/code&gt; 的參數供辨認。&lt;/p&gt;
&lt;p&gt;最後包裝 obj 時加上 &lt;code&gt;-shared&lt;/code&gt; 編成共享函式庫。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_08_04_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;以上流程都為 C++ 編譯操作，往後可能會換成加入 SWIG 端口或 Cython 包裝。&lt;/p&gt;
&lt;h1&gt;長時演算模式&lt;/h1&gt;
&lt;p&gt;新增直到手動停止的模式，將代數改為 0 即可，這時 report 會變成每 10 代紀錄一次。&lt;/p&gt;
&lt;p&gt;此模式下會一直演化，直到手動中斷為止。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_08_04_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;這個模式只是用來測試用，若是在服務端，可以改成演化直到適應值小於某要求後停止，且加上評估演化效率後自動中止的機制。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Python-Solvespace 建議</title><link href="http://project.mde.tw/blog/python-solvespace-jian-yi.html" rel="alternate"></link><published>2017-08-03T12:00:00+08:00</published><updated>2017-08-03T12:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-08-03:blog/python-solvespace-jian-yi.html</id><summary type="html">&lt;p&gt;關於對 Python-Solvespace kernel 提出的建議：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/KmolYuan/python-solvespace/issues"&gt;Github issue&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;範圍約束&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://github.com/mauge123/mechanical-blender"&gt;mechanical-blender&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Related data and applications to allow blender be more CAD/CAE friendly.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;範圍約束&lt;/h1&gt;
&lt;p&gt;不久前 (8/1) Solvespace 應要求加入了範圍約束的功能，能在固定範圍內調整尺寸而不會產生錯誤。&lt;/p&gt;
&lt;p&gt;Symbian9 便在倉儲提出加入此功能的要求。&lt;/p&gt;
&lt;p&gt;或許此約束可以改良滑塊的呈現？&lt;/p&gt;
&lt;p&gt;不過目前原始碼較舊，會嘗試先不更新加入此功能，若成功則可以開始撰寫端口，若需要新的物件或函式，會嘗試是否能更新到新版。&lt;/p&gt;
&lt;p&gt;現在的原始碼含有不必要的 UI 和介面相關的程式，可能先大約測試後清理之。&lt;/p&gt;
&lt;h1&gt;mechanical-blender&lt;/h1&gt;
&lt;p&gt;另外 Symbian9 介紹一個 blender 專案，目標是製作符合機械設計需求的模擬與彩現軟體。&lt;/p&gt;
&lt;p&gt;目前 mechanical-blender 是由多人分工改寫，已經有在主畫面中建立模型的能力。&lt;/p&gt;
&lt;p&gt;Wishes 中提出：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;改善使用者座標空間&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;繪圖空間&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新的鎖點模式&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Python-Solvespace 是否可以在繪製方面以 Python plugin 的方式幫助建模？&lt;/p&gt;
&lt;p&gt;協助 mechanical-blender 功能開發似乎是個不錯的選擇。&lt;/p&gt;</summary><category term="Solvespace"></category></entry><entry><title>Pyslvs 演算法中斷機制 - (2)</title><link href="http://project.mde.tw/blog/pyslvs-yan-suan-fa-zhong-duan-ji-zhi-2.html" rel="alternate"></link><published>2017-07-30T21:00:00+08:00</published><updated>2017-07-30T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-07-30:blog/pyslvs-yan-suan-fa-zhong-duan-ji-zhi-2.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;演算法中斷機制 - 符號標示&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;演算法中斷機制 - 符號標示&lt;/h1&gt;
&lt;p&gt;新增三種圖示標示結果是否被中斷。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_07_30_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;並增加相關資訊至右側。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_07_30_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;目前平行運算的連線方式還不知道較佳的解法，可能會先推四連桿和八連桿的速度圖表，供演算法結果和三角迭代器計算。&lt;/p&gt;
&lt;p&gt;上述功能會放在預覽視窗或是新的按鈕中。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Pyslvs 演算法中斷機制</title><link href="http://project.mde.tw/blog/pyslvs-yan-suan-fa-zhong-duan-ji-zhi.html" rel="alternate"></link><published>2017-07-29T21:00:00+08:00</published><updated>2017-07-29T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-07-29:blog/pyslvs-yan-suan-fa-zhong-duan-ji-zhi.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;演算法中斷機制&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;演算法中斷機制&lt;/h1&gt;
&lt;p&gt;研究許久 Cython 的外部中斷迴圈，一直沒有找到較好的方式。&lt;/p&gt;
&lt;p&gt;大部分 github 的參考都是藉由 Python 的 threading 模組達成的，但是這樣可能又得改寫演算法模組的物件。&lt;/p&gt;
&lt;p&gt;因此後來運用運算進度條檢查 function object 的機制做出中斷的方法。&lt;/p&gt;
&lt;p&gt;傳入的 function object 被 call 時會回傳 QThread 的暫停狀態 &lt;code&gt;self.stoped&lt;/code&gt;，Cython 即可判斷是否終止，若為 True，會在當前代數停下，回傳本代最佳解。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_07_29_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;而對話方塊端新增了「Interrupt」鈕，按下此鈕時會中止運算，收下當前最佳解。&lt;/p&gt;
&lt;p&gt;而原本的「Cancel」鈕則會捨棄這次演算結果。&lt;/p&gt;
&lt;p&gt;不過目前還未增加中斷的資訊，接下來應該會增加標籤圖示，並且顯示中斷時的代數供參考。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_07_29_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;中斷結果的數據通常未必能成形，大多數都是非合法的連桿機構。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Pyslvs 演算法調整</title><link href="http://project.mde.tw/blog/pyslvs-yan-suan-fa-diao-zheng.html" rel="alternate"></link><published>2017-07-27T21:00:00+08:00</published><updated>2017-07-27T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-07-27:blog/pyslvs-yan-suan-fa-diao-zheng.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;運算進度條&lt;/li&gt;
&lt;li&gt;不同演算法參數調整&lt;/li&gt;
&lt;li&gt;tinycadlib 更新&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;運算進度條&lt;/h1&gt;
&lt;p&gt;透過論壇的小技巧製作出可以回傳 Cython 進度的方式（適用於所有 Python function）。&lt;/p&gt;
&lt;!-- HTML generated using hilite.me --&gt;

&lt;div style="background: #f8f8f8; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;pre style="margin: 0; line-height: 125%"&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre style="margin: 0; line-height: 125%"&gt;&lt;span style="color: #008000; font-weight: bold"&gt;cdef&lt;/span&gt; &lt;span style="color: #008000; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #0000FF"&gt;Genetic&lt;/span&gt;(&lt;span style="color: #008000"&gt;object&lt;/span&gt;):
    &lt;span style="color: #BA2121; font-style: italic"&gt;&amp;quot;&amp;quot;&amp;quot;宣告&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;cdef&lt;/span&gt; &lt;span style="color: #B00040"&gt;object&lt;/span&gt; &lt;span style="color: #0000FF"&gt;progress_fun&lt;/span&gt;

    &lt;span style="color: #008000; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #0000FF"&gt;__cinit__&lt;/span&gt;(&lt;span style="color: #008000"&gt;self&lt;/span&gt;, &lt;span style="color: #408080; font-style: italic"&gt;#其他參數&lt;/span&gt;
            &lt;span style="color: #008000"&gt;object&lt;/span&gt; progress_fun&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #008000"&gt;None&lt;/span&gt;):
        &lt;span style="color: #408080; font-style: italic"&gt;#將 progress_fun 放到 self 中&lt;/span&gt;
        &lt;span style="color: #008000"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;progress_fun &lt;span style="color: #666666"&gt;=&lt;/span&gt; progress_fun

    &lt;span style="color: #008000; font-weight: bold"&gt;cpdef&lt;/span&gt; &lt;span style="color: #0000FF"&gt;run&lt;/span&gt;(&lt;span style="color: #008000"&gt;self&lt;/span&gt;):
        &lt;span style="color: #408080; font-style: italic"&gt;#每代的迴圈&lt;/span&gt;
        &lt;span style="color: #008000; font-weight: bold"&gt;for&lt;/span&gt; &lt;span style="color: #008000"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;gen &lt;span style="color: #AA22FF; font-weight: bold"&gt;in&lt;/span&gt; &lt;span style="color: #008000"&gt;range&lt;/span&gt;(&lt;span style="color: #666666"&gt;1&lt;/span&gt;, &lt;span style="color: #008000"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;maxGen &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;1&lt;/span&gt;):
            &lt;span style="color: #BA2121; font-style: italic"&gt;&amp;quot;&amp;quot;&amp;quot;計算流程&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
            &lt;span style="color: #408080; font-style: italic"&gt;#計算後回傳當前代數&lt;/span&gt;
            &lt;span style="color: #008000; font-weight: bold"&gt;if&lt;/span&gt; &lt;span style="color: #008000"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;progress_fun &lt;span style="color: #AA22FF; font-weight: bold"&gt;is&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;not&lt;/span&gt; &lt;span style="color: #008000"&gt;None&lt;/span&gt;: &lt;span style="color: #008000"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;progress_fun(&lt;span style="color: #008000"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;gen)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;在 Python 端只要為 QThread 建立信號 &lt;code&gt;progress_update&lt;/code&gt;，並將信號的 &lt;code&gt;emit&lt;/code&gt; 方法傳入 Cython Object 即可。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
class WorkerThread(QThread):
    progress_update = pyqtSignal(int)
    def generateProcess(self):
        #選擇演算法並改名成 foo
        self.fun = foo(mechanismObj, progress_fun=self.progress_update.emit, **APs)
        time_and_fitness, fitnessParameter = self.fun.run()
&lt;/pre&gt;

&lt;p&gt;此信號在 GUI 中與 Progress bar 的 &lt;code&gt;setValue&lt;/code&gt; 信號槽連接即可。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
self.work.progress_update.connect(self.progressBar.setValue)
&lt;/pre&gt;

&lt;p&gt;接著就能看到當前運算的進度了，上述方法只須記得統一用 int 類型即可。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_07_27.png" /&gt;&lt;/p&gt;
&lt;h1&gt;不同演算法參數調整&lt;/h1&gt;
&lt;p&gt;後來發現，若是 Firefly 的代數與初始族群較大，將會比其他演算法花更久的時間，因此做了初始族群的調整。&lt;/p&gt;
&lt;p&gt;初始族群的數量只比學長預設的多 1 倍即可。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基因演算法由 250 提昇為 500。&lt;/li&gt;
&lt;li&gt;螢火蟲演算法由 40 提昇為 80。&lt;/li&gt;
&lt;li&gt;差分演化法由 190 提昇為 400。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;tinycadlib 更新&lt;/h1&gt;
&lt;p&gt;大致了解 Cython 語法後，為 tinycadlib 程式庫新增了三角形驗證函式 &lt;code&gt;legal_triangle&lt;/code&gt; 和 &lt;code&gt;PLPP&lt;/code&gt; 計算式。&lt;/p&gt;
&lt;p&gt;前者是因為之前的 &lt;code&gt;build_planar&lt;/code&gt; object function 似乎沒有邊長驗證機制，導致產出非三角形的連桿組；加入後還在觀察情況是否會改善。&lt;/p&gt;
&lt;!-- HTML generated using hilite.me --&gt;

&lt;div style="background: #f8f8f8; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;pre style="margin: 0; line-height: 125%"&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre style="margin: 0; line-height: 125%"&gt;&lt;span style="color: #008000; font-weight: bold"&gt;cpdef&lt;/span&gt; &lt;span style="color: #B00040"&gt;bool&lt;/span&gt; &lt;span style="color: #0000FF"&gt;legal_triangle&lt;/span&gt;(Coordinate A, Coordinate B, Coordinate C):
    &lt;span style="color: #408080; font-style: italic"&gt;#L0, L1, L2 is triangle&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;cdef&lt;/span&gt; &lt;span style="color: #B00040"&gt;double&lt;/span&gt; &lt;span style="color: #0000FF"&gt;L0&lt;/span&gt; &lt;span style="color: #666666"&gt;=&lt;/span&gt; A&lt;span style="color: #666666"&gt;.&lt;/span&gt;distance(B)
    &lt;span style="color: #008000; font-weight: bold"&gt;cdef&lt;/span&gt; &lt;span style="color: #B00040"&gt;double&lt;/span&gt; &lt;span style="color: #0000FF"&gt;L1&lt;/span&gt; &lt;span style="color: #666666"&gt;=&lt;/span&gt; B&lt;span style="color: #666666"&gt;.&lt;/span&gt;distance(C)
    &lt;span style="color: #008000; font-weight: bold"&gt;cdef&lt;/span&gt; &lt;span style="color: #B00040"&gt;double&lt;/span&gt; &lt;span style="color: #0000FF"&gt;L2&lt;/span&gt; &lt;span style="color: #666666"&gt;=&lt;/span&gt; A&lt;span style="color: #666666"&gt;.&lt;/span&gt;distance(C)
    &lt;span style="color: #008000; font-weight: bold"&gt;return&lt;/span&gt; L1&lt;span style="color: #666666"&gt;+&lt;/span&gt;L2&lt;span style="color: #666666"&gt;&amp;gt;&lt;/span&gt;L0 &lt;span style="color: #AA22FF; font-weight: bold"&gt;and&lt;/span&gt; L0&lt;span style="color: #666666"&gt;+&lt;/span&gt;L2&lt;span style="color: #666666"&gt;&amp;gt;&lt;/span&gt;L1 &lt;span style="color: #AA22FF; font-weight: bold"&gt;and&lt;/span&gt; L0&lt;span style="color: #666666"&gt;+&lt;/span&gt;L1&lt;span style="color: #666666"&gt;&amp;gt;&lt;/span&gt;L2
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;後者則是備用於滑塊演算法的需求。&lt;/p&gt;
&lt;!-- HTML generated using hilite.me --&gt;

&lt;div style="background: #f8f8f8; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;pre style="margin: 0; line-height: 125%"&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre style="margin: 0; line-height: 125%"&gt;&lt;span style="color: #008000; font-weight: bold"&gt;cpdef&lt;/span&gt; &lt;span style="color: #0000FF"&gt;PLPP&lt;/span&gt;(Coordinate A, double L0, Coordinate B, Coordinate C, double loop&lt;span style="color: #666666"&gt;=1&lt;/span&gt;):
    &lt;span style="color: #008000; font-weight: bold"&gt;cdef&lt;/span&gt; &lt;span style="color: #B00040"&gt;double&lt;/span&gt; &lt;span style="color: #0000FF"&gt;x1&lt;/span&gt; &lt;span style="color: #666666"&gt;=&lt;/span&gt; A&lt;span style="color: #666666"&gt;.&lt;/span&gt;x
    &lt;span style="color: #008000; font-weight: bold"&gt;cdef&lt;/span&gt; &lt;span style="color: #B00040"&gt;double&lt;/span&gt; &lt;span style="color: #0000FF"&gt;y1&lt;/span&gt; &lt;span style="color: #666666"&gt;=&lt;/span&gt; A&lt;span style="color: #666666"&gt;.&lt;/span&gt;y
    &lt;span style="color: #008000; font-weight: bold"&gt;cdef&lt;/span&gt; &lt;span style="color: #B00040"&gt;double&lt;/span&gt; &lt;span style="color: #0000FF"&gt;x2&lt;/span&gt; &lt;span style="color: #666666"&gt;=&lt;/span&gt; B&lt;span style="color: #666666"&gt;.&lt;/span&gt;x
    &lt;span style="color: #008000; font-weight: bold"&gt;cdef&lt;/span&gt; &lt;span style="color: #B00040"&gt;double&lt;/span&gt; &lt;span style="color: #0000FF"&gt;y2&lt;/span&gt; &lt;span style="color: #666666"&gt;=&lt;/span&gt; B&lt;span style="color: #666666"&gt;.&lt;/span&gt;y
    &lt;span style="color: #008000; font-weight: bold"&gt;cdef&lt;/span&gt; &lt;span style="color: #B00040"&gt;double&lt;/span&gt; &lt;span style="color: #0000FF"&gt;x3&lt;/span&gt; &lt;span style="color: #666666"&gt;=&lt;/span&gt; C&lt;span style="color: #666666"&gt;.&lt;/span&gt;x
    &lt;span style="color: #008000; font-weight: bold"&gt;cdef&lt;/span&gt; &lt;span style="color: #B00040"&gt;double&lt;/span&gt; &lt;span style="color: #0000FF"&gt;y3&lt;/span&gt; &lt;span style="color: #666666"&gt;=&lt;/span&gt; C&lt;span style="color: #666666"&gt;.&lt;/span&gt;y
    &lt;span style="color: #008000; font-weight: bold"&gt;if&lt;/span&gt; loop&lt;span style="color: #666666"&gt;&amp;gt;0&lt;/span&gt;:
        &lt;span style="color: #008000; font-weight: bold"&gt;return&lt;/span&gt; (
            ((x2&lt;span style="color: #666666"&gt;-&lt;/span&gt;x3)&lt;span style="color: #666666"&gt;*&lt;/span&gt;(x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2 &lt;span style="color: #666666"&gt;-&lt;/span&gt; x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; x2&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; (&lt;span style="color: #666666"&gt;-&lt;/span&gt;y2 &lt;span style="color: #666666"&gt;+&lt;/span&gt; y3)&lt;span style="color: #666666"&gt;*&lt;/span&gt;sqrt(L0&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;L0&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; L0&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;L0&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; L0&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; L0&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;-&lt;/span&gt; x1&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; x1&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2 &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;x3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; y1&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; y1&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;-&lt;/span&gt; x2&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; y2&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;**2&lt;/span&gt;)) &lt;span style="color: #666666"&gt;-&lt;/span&gt; (x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3)&lt;span style="color: #666666"&gt;*&lt;/span&gt;(x2&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; y2&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; x3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; y3&lt;span style="color: #666666"&gt;**2&lt;/span&gt;))&lt;span style="color: #666666"&gt;/&lt;/span&gt;((y2 &lt;span style="color: #666666"&gt;-&lt;/span&gt; y3)&lt;span style="color: #666666"&gt;*&lt;/span&gt;(x2&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; y2&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; x3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; y3&lt;span style="color: #666666"&gt;**2&lt;/span&gt;)),
            (x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2 &lt;span style="color: #666666"&gt;-&lt;/span&gt; x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; x2&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; (&lt;span style="color: #666666"&gt;-&lt;/span&gt;y2 &lt;span style="color: #666666"&gt;+&lt;/span&gt; y3)&lt;span style="color: #666666"&gt;*&lt;/span&gt;sqrt(L0&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;L0&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; L0&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;L0&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; L0&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; L0&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;-&lt;/span&gt; x1&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; x1&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2 &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;x3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; y1&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; y1&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;-&lt;/span&gt; x2&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; y2&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;**2&lt;/span&gt;))&lt;span style="color: #666666"&gt;/&lt;/span&gt;(x2&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; y2&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; x3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; y3&lt;span style="color: #666666"&gt;**2&lt;/span&gt;)
        )
    &lt;span style="color: #008000; font-weight: bold"&gt;else&lt;/span&gt;:
        &lt;span style="color: #008000; font-weight: bold"&gt;return&lt;/span&gt; (
            ((x2&lt;span style="color: #666666"&gt;-&lt;/span&gt;x3)&lt;span style="color: #666666"&gt;*&lt;/span&gt;(x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2 &lt;span style="color: #666666"&gt;-&lt;/span&gt; x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; x2&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; (y2 &lt;span style="color: #666666"&gt;-&lt;/span&gt; y3)&lt;span style="color: #666666"&gt;*&lt;/span&gt;sqrt(L0&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;L0&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; L0&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;L0&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; L0&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; L0&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;-&lt;/span&gt; x1&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; x1&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2 &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;x3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; y1&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; y1&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;-&lt;/span&gt; x2&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; y2&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;**2&lt;/span&gt;)) &lt;span style="color: #666666"&gt;-&lt;/span&gt; (x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3)&lt;span style="color: #666666"&gt;*&lt;/span&gt;(x2&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; y2&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; x3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; y3&lt;span style="color: #666666"&gt;**2&lt;/span&gt;))&lt;span style="color: #666666"&gt;/&lt;/span&gt;((y2 &lt;span style="color: #666666"&gt;-&lt;/span&gt; y3)&lt;span style="color: #666666"&gt;*&lt;/span&gt;(x2&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; y2&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; x3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; y3&lt;span style="color: #666666"&gt;**2&lt;/span&gt;)),
            (x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2 &lt;span style="color: #666666"&gt;-&lt;/span&gt; x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; x2&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; (y2 &lt;span style="color: #666666"&gt;-&lt;/span&gt; y3)&lt;span style="color: #666666"&gt;*&lt;/span&gt;sqrt(L0&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;L0&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; L0&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;L0&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; L0&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; L0&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;-&lt;/span&gt; x1&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; x1&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2 &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;x3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; y1&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; y1&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;y1&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;-&lt;/span&gt; x2&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;y3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;-&lt;/span&gt; y2&lt;span style="color: #666666"&gt;**2*&lt;/span&gt;x3&lt;span style="color: #666666"&gt;**2&lt;/span&gt;))&lt;span style="color: #666666"&gt;/&lt;/span&gt;(x2&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;x2&lt;span style="color: #666666"&gt;*&lt;/span&gt;x3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; y2&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;2*&lt;/span&gt;y2&lt;span style="color: #666666"&gt;*&lt;/span&gt;y3 &lt;span style="color: #666666"&gt;+&lt;/span&gt; x3&lt;span style="color: #666666"&gt;**2&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; y3&lt;span style="color: #666666"&gt;**2&lt;/span&gt;)
        )
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Pyslvs 演算法資訊</title><link href="http://project.mde.tw/blog/pyslvs-yan-suan-fa-zi-xun.html" rel="alternate"></link><published>2017-07-26T21:00:00+08:00</published><updated>2017-07-26T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-07-26:blog/pyslvs-yan-suan-fa-zi-xun.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新增演算法資訊&lt;/li&gt;
&lt;li&gt;Qt QSplitter 說明&lt;/li&gt;
&lt;li&gt;其他 Kernel 利用可能性&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;演算法資訊&lt;/h1&gt;
&lt;p&gt;陸續測試一些模組，最後採用 numpy 的 cpuinfo 模組取得硬體資訊。&lt;/p&gt;
&lt;p&gt;而這些資訊會顯示在預覽窗格的右側。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_07_26.png" /&gt;&lt;/p&gt;
&lt;h1&gt;Qt QSplitter&lt;/h1&gt;
&lt;p&gt;版面布局的部分，若是想利用水平或垂直分割佈局，不過又想讓使用者自訂大小，可以使用 QSplitter 達成。&lt;/p&gt;
&lt;p&gt;不過如果未設定 QSplitter 的 Properties，只會按照子 Widgets 的最大最小值做寬度調整。&lt;/p&gt;
&lt;p&gt;若要使用指令改變分割欄的位置，可以使用下面兩種方式：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
splitter.setSizes([800, 100])
&lt;/pre&gt;

&lt;p&gt;或是：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
splitter.setStretchFactor(0, 1) #Widget 0
splitter.setStretchFactor(1, 4) #Widget 1
&lt;/pre&gt;

&lt;p&gt;第一種方式為按順序（左至右、上至下）填入子 Widgets 的寬度，單位為像素，多餘的值則會被捨棄；若是為 0，Widget 將會被壓縮至消失。&lt;/p&gt;
&lt;p&gt;第二種方式則是透過 Widget 本身的伸展權數來調整，權數較大的項目將會獲得較大的寬度。&lt;/p&gt;
&lt;h1&gt;其他 Kernel 利用可能性&lt;/h1&gt;
&lt;p&gt;關於 Chrono 的幾何程式庫是否較 Solvespace kernel 更有優勢？&lt;/p&gt;
&lt;p&gt;若是利用 Chrono kernel 的力學系統，可以同時求出速度與基本反力，可能會比純粹幾何解題還好。&lt;/p&gt;
&lt;p&gt;另外參考 pyGear 的導出模式，納入 Python OCC 建模是否為更好的選擇？&lt;/p&gt;
&lt;p&gt;目前 Pyslvs &lt;strong&gt;尚未&lt;/strong&gt;能夠直接轉出 STL 或 IGS 格式的能力，納入後能直接銜接模擬軟體或建模軟體，搭配演算法是個不錯的選擇。不過目前還未測試加入後的大小。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Pyslvs 演算法圖表</title><link href="http://project.mde.tw/blog/pyslvs-yan-suan-fa-tu-biao.html" rel="alternate"></link><published>2017-07-24T21:00:00+08:00</published><updated>2017-07-24T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-07-24:blog/pyslvs-yan-suan-fa-tu-biao.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新增 fitness - time 圖表&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;時間收斂圖&lt;/h1&gt;
&lt;p&gt;新增了時間收斂圖，以時間為 x 軸分析結果，由於以前篩選資料時沒納入時間，所以稍微改了一下程式結構。&lt;/p&gt;
&lt;p&gt;不過可能是只取整數的關係，圖表呈現如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_07_24_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;經調整 Cython 中的時間值後，將 &lt;code&gt;int&lt;/code&gt; 改成 &lt;code&gt;double&lt;/code&gt; 以合理化。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_07_24_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;之後可能在增加代數 - 時間的圖表，以比較運算得出的時間差。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Pyslvs 的 ZMQ 防止連線中斷</title><link href="http://project.mde.tw/blog/pyslvs-de-zmq-fang-zhi-lian-xian-zhong-duan.html" rel="alternate"></link><published>2017-07-23T21:00:00+08:00</published><updated>2017-07-23T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-07-23:blog/pyslvs-de-zmq-fang-zhi-lian-xian-zhong-duan.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;改善 Server  突然關閉的狀況&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;ZMQ 防止連線中斷&lt;/h1&gt;
&lt;p&gt;使用 PyZMQ 提供的 Poll 類型檢測連線狀況：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Client&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="brush: python"&gt;
import zmq
context = zmq.Context()

socket_port = "tcp://localhost:8000"

socket = context.socket(zmq.REQ)
socket.bind(socket_port)
poll = zmq.Poller()
poll.register(self.socket, zmq.POLLIN)
while True:
    if socket.closed: #Reconnecting
        socket = context.socket(zmq.REQ)
        socket.bind(socket_port)
        poll.register(socket, zmq.POLLIN)
    socket.send_string("Hello!")
    while True:
        socks = dict(poll.poll(100))
        if socks.get(socket)==zmq.POLLIN:
            """Connected."""
            return socket.recv()
        else:
            """Connection interrupt."""
            socket.setsockopt(zmq.LINGER, 0)
            socket.close()
            poll.unregister(socket) #Socket will be deleted.
            return my_fun()
&lt;/pre&gt;

&lt;p&gt;上面的程式碼中，若是沒有關閉 socket 或是斷線沒有重新連接，ZMQ 皆會回傳 Exception。&lt;/p&gt;
&lt;p&gt;主要是解決 Server 中途斷線導致程式中斷，會自行運算彌補。&lt;/p&gt;
&lt;p&gt;不過如果全部 Server 離線，Client 端仍會繼續等待 Server 連進來，會想辦法解決。&lt;/p&gt;
&lt;p&gt;再來就是 Python 執行速度問題，Python 演算法要再改寫並優化，接下來會針對三種演算法加以改良。&lt;/p&gt;</summary><category term="Pyslvs"></category><category term="ZMQ"></category></entry><entry><title>Pyslvs 演算法結果預覽</title><link href="http://project.mde.tw/blog/pyslvs-yan-suan-fa-jie-guo-yu-lan.html" rel="alternate"></link><published>2017-07-22T21:00:00+08:00</published><updated>2017-07-22T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-07-22:blog/pyslvs-yan-suan-fa-jie-guo-yu-lan.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;演算法結果動態預覽&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;路徑模糊化&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;動態預覽&lt;/h1&gt;
&lt;p&gt;所有演算法的有效合成結果皆可在彈出視窗中預覽。&lt;/p&gt;
&lt;p&gt;滑鼠游標懸至結果上方可以呈現數據，點擊一下可以套用設定，點擊兩下可以在視窗中呈現動態預覽。&lt;/p&gt;
&lt;iframe width="854" height="480" src="https://www.youtube.com/embed/QeA_2BZYotA" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;

&lt;h1&gt;路徑模糊化&lt;/h1&gt;
&lt;p&gt;若在 Pyslvs 中有一現成路徑的點資料，可以透過剪貼簿將路徑追蹤的結果複製下來，貼到路徑解題的清單中。&lt;/p&gt;
&lt;p&gt;由於數據量較大，不利於演算法驗證，可以使用處理工具的「模糊化」將點數目減少。&lt;/p&gt;
&lt;iframe width="854" height="480" src="https://www.youtube.com/embed/gudE4DRbWVo" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Pyslvs 路徑處理</title><link href="http://project.mde.tw/blog/pyslvs-lu-jing-chu-li.html" rel="alternate"></link><published>2017-07-20T21:00:00+08:00</published><updated>2017-07-20T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-07-20:blog/pyslvs-lu-jing-chu-li.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;支援匯入與處理演算法路徑&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;簡單處理演算法路徑座標點功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;演算法名詞解釋&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模組授權整理&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;讀取方式&lt;/h1&gt;
&lt;p&gt;讀取的格式有 CSV 逗號分隔值與 Microsoft Office Excel 試算表，前者使用 Python 內建模組讀取，後者使用 openpyxl 模組讀取。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_07_20_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;所有讀入值只會取到小數 4 位，而其中若為非正確格式，會跳出警告視窗並取消讀入。&lt;/p&gt;
&lt;p&gt;另外若是有 Pyslvs 現成的路徑數據，可以複製到剪貼簿後直接用右鍵選單貼上。&lt;/p&gt;
&lt;h1&gt;路徑處理&lt;/h1&gt;
&lt;p&gt;路徑處理功能可以做簡單的座標點修正，目前有移動與指定點縮放功能。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_07_20_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;之後會加入以下功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;模糊化：協助減少點數目。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;旋轉：沿著參考點（或圖形中心）旋轉路徑。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;演算法名詞解釋&lt;/h1&gt;
&lt;p&gt;Pyslvs 之後會在設定介面中加入三種演算法名詞解釋，協助使用者變動參數。&lt;/p&gt;
&lt;h1&gt;模組授權整理&lt;/h1&gt;
&lt;p&gt;Made by [Qt5] and Python IDE &lt;a href="http://eric-ide.python-projects.org/"&gt;Eric 6&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Including Python module:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://riverbankcomputing.com/software/sip/download"&gt;SIP&lt;/a&gt; (GPLv2, GPLv3)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://riverbankcomputing.com/software/qscintilla/download"&gt;QScintilla2&lt;/a&gt; (GPLv3)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.riverbankcomputing.com/software/pyqt/download5"&gt;PyQt5&lt;/a&gt;, &lt;a href="https://www.riverbankcomputing.com/software/pyqtchart/download"&gt;PyQtChart&lt;/a&gt; (GPLv3)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://pypi.python.org/pypi/dxfwrite/"&gt;dxfwrite&lt;/a&gt; (MIT)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.numpy.org/"&gt;numpy&lt;/a&gt; (BSD 3-Clause)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://cython.org/"&gt;Cython&lt;/a&gt; (Apache 2.0)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://zeromq.org/bindings:python"&gt;PyZMQ&lt;/a&gt; (New BSD 3-Clause, LGPL, Apache)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://openpyxl.readthedocs.io/"&gt;openpyxl&lt;/a&gt; (MIT)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Pyslvs is under &lt;a href="https://github.com/KmolYuan/Pyslvs-PyQt5/blob/master/LICENSE"&gt;GNU Affero General Public License v3&lt;/a&gt;.&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Pyslvs 統一編譯流程</title><link href="http://project.mde.tw/blog/pyslvs-tong-yi-bian-yi-liu-cheng.html" rel="alternate"></link><published>2017-07-19T21:00:00+08:00</published><updated>2017-07-19T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-07-19:blog/pyslvs-tong-yi-bian-yi-liu-cheng.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;單一 Makefile 完成 kernel 編譯&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Makefile 整合語法&lt;/h1&gt;
&lt;p&gt;若要在 Makefile 中執行其他目錄的 Makefile 步驟，可以使用下面的語法：&lt;/p&gt;
&lt;pre class="brush: Makefile"&gt;
    $(MAKE) -C go/to/another/dir/ -f makefile_name build_or_clean_command
&lt;/pre&gt;

&lt;p&gt;其中，各部分介紹如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;$(MAKE)&lt;/code&gt; 變數為啟動此腳本的 Make 程式（不同環境不見得為 &lt;code&gt;make&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-C&lt;/code&gt; 標籤為 Make 程式的工作目錄，之後所有動作會先移至此目錄中執行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果檔案名稱不叫 Makefile，&lt;code&gt;-f&lt;/code&gt; 可以指定額外名稱。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最後，指定 build 或 clean 等其他腳本目標。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;針對指令的記號如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@&lt;/code&gt; 可以將此指令的下令訊息隱藏，如 echo 不想顯示命令時的標記，可以使用 &lt;code&gt;@echo "test text"&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-&lt;/code&gt; 可以在指令失敗時回傳提醒，並且會繼續執行之後的指令，如 &lt;code&gt;-mv exefile exe_file&lt;/code&gt; 可以防止重新命名失敗。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;Pyslvs 統一編譯流程&lt;/h1&gt;
&lt;p&gt;Pyslvs 已經將兩個 kernel 的原始碼納入，因此不再分辨系統版本。&lt;/p&gt;
&lt;p&gt;通過 Readme 的設定，Windows 安裝 SWIG 後將 Python 設定完成後便可完成編譯流程，Ubuntu 只需安裝 SWIG 和 python3-dev 開發包即可。&lt;/p&gt;
&lt;p&gt;已通過 Travis-Ci 服務測試 Python 3.4, 3.5, 3.6 編譯成功。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_07_19.png" /&gt;&lt;/p&gt;
&lt;p&gt;不過 3.6 目前尚未支援 PyInstaller，因此先使用其開發版本編譯。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>八連桿演算法</title><link href="http://project.mde.tw/blog/ba-lian-gan-yan-suan-fa.html" rel="alternate"></link><published>2017-07-11T21:00:00+08:00</published><updated>2017-07-11T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-07-11:blog/ba-lian-gan-yan-suan-fa.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;設定並測試八連桿演算法&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;八連桿演算法&lt;/h1&gt;
&lt;p&gt;稍微理解 Cython 程式碼後，透過原先的 Cython API，可以將四連桿的設定轉變為八連桿的設定。&lt;/p&gt;
&lt;p&gt;以下是兩者的比對：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
mechanismParams_4Bar = { #No 'targetPath'
    'Driving':'A',
    'Follower':'D',
    'Link':'L0,L1,L2,L3,L4',
    'Target':'E',
    'ExpressionName':'PLAP,PLLP,PLLP',
    'Expression':'A,L0,a0,D,B,B,L1,L2,D,C,B,L3,L4,C,E',
    'constraint':[{'driver':'L0', 'follower':'L2', 'connect':'L1'}],
    'formula':['PLAP','PLLP']}
mechanismParams_4Bar['VARS'] = len(set(mechanismParams_4Bar['Expression'].split(',')))-2
mechanismParams_8Bar = { #No 'targetPath'
    'Driving':'A',
    'Follower':'B',
    'Link':'L0,L1,L2,L3,L4,L5,L6,L7,L8,L9,L10',
    'Target':'H',
    'ExpressionName':'PLAP,PLLP,PLLP,PLLP,PLLP,PLLP',
    'Expression':'A,L0,a0,B,C,B,L2,L1,C,D,B,L4,L3,D,E,C,L5,L6,B,F,F,L8,L7,E,G,F,L9,L10,G,H',
    'constraint':[{'driver':'L0', 'follower':'L2', 'connect':'L1'}],
    'formula':['PLAP','PLLP']}
mechanismParams_8Bar['VARS'] = len(set(mechanismParams_8Bar['Expression'].split(',')))-2
&lt;/pre&gt;

&lt;p&gt;其中一些項目可由部份內容得知，如 VARS 為不包含「求解值」與「角度」的所有代號，便可由 Expression 使用 set type 解析出現的代號，並扣除得知。&lt;/p&gt;
&lt;p&gt;再來是演算法須得知的參數：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
mechanismParams = self.mechanismParams_4Bar if self.FourBar.isChecked() else self.mechanismParams_8Bar
link_q = mechanismParams['VARS']-7
upper = [self.Settings['AxMax'], self.Settings['AyMax'], self.Settings['DxMax'], self.Settings['DyMax'],
    self.Settings['IMax'], self.Settings['LMax'], self.Settings['FMax']]+[self.Settings['LMax']]*link_q
lower = [self.Settings['AxMin'], self.Settings['AyMin'], self.Settings['DxMin'], self.Settings['DyMin'],
    self.Settings['IMin'], self.Settings['LMin'], self.Settings['FMin']]+[self.Settings['LMin']]*link_q
mechanismParams['targetPath'] = tuple((e['x'], e['y']) for e in self.path)
p = len(self.path)
GenerateData = {
    'nParm':p+mechanismParams['VARS'],
    'upper':upper+[self.Settings['AMax']]*p,
    'lower':lower+[self.Settings['AMin']]*p,
    'maxGen':self.Settings['maxGen'],
    'report':int(self.Settings['maxGen']*self.Settings['report']/100)}
&lt;/pre&gt;

&lt;p&gt;由 GUI 取得連桿類型後，經測試發現 upper 與 lower 的長度必須與 VARS 的數值相等，因此調整中間連桿的設定。&lt;/p&gt;
&lt;p&gt;上述的設定可以適應四連桿與八連桿的資料輸入，其他參數則是由 GUI 設定。&lt;/p&gt;
&lt;p&gt;合併結果的部份，由於還未寫辨識固定鍊的函式，所以目前機構皆用連桿連接。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_07_11_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;上圖為套用四連桿相從設定的結果（差分演化法），不過速度方面很意外的沒有落後太多，大約在 3 至 10 秒之間。&lt;/p&gt;
&lt;p&gt;推測可能是八連桿的路徑較多變，因此在幾代內稍微調整染色體即可符合，不過若是路徑點較多，也可能需要較久的時間。&lt;/p&gt;
&lt;p&gt;以下為一個八連桿演算法的範例（差分演化法，12 個路徑點，花費 10.5008 秒），之後會加入內建範例中。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_07_11_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;以下為此範例的適應值收斂圖。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_07_11_03.png" /&gt;&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>ZMQ 與 Cython 遇到的瓶頸</title><link href="http://project.mde.tw/blog/zmq-yu-cython-yu-dao-de-ping-jing.html" rel="alternate"></link><published>2017-07-10T21:00:00+08:00</published><updated>2017-07-10T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-07-10:blog/zmq-yu-cython-yu-dao-de-ping-jing.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;ZMQ 傳輸類型&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;ZMQ 傳輸類型&lt;/h1&gt;
&lt;p&gt;測試了 Python 演算法單機開多個程式分散計算適應值，但是比純 Python 慢 12 倍左右。&lt;/p&gt;
&lt;p&gt;透過 PyZMQ 的 socket 傳輸，看了官方的說明文件，似乎是 byte 類型較快，許多數字計算的範例則是先轉成文字解碼後才傳輸，而目前是用 Python Object，是最慢的一種，但是會保留所需的格式。&lt;/p&gt;
&lt;p&gt;計算適應值需要傳輸下列項目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;連桿類型（未來加入八連桿後）&lt;/li&gt;
&lt;li&gt;參數值（計算適應值）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是不知道演算法流程也改成 Cython 後，傳輸的部份是否仍有加速的空間。&lt;/p&gt;
&lt;p&gt;而改成 Cython 的方式還在研究中。&lt;/p&gt;</summary><category term="Pyslvs"></category><category term="ZMQ"></category></entry><entry><title>Travis CI 模擬編譯</title><link href="http://project.mde.tw/blog/travis-ci-mo-ni-bian-yi.html" rel="alternate"></link><published>2017-07-06T21:00:00+08:00</published><updated>2017-07-06T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-07-06:blog/travis-ci-mo-ni-bian-yi.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 Travis CI 服務在遠端虛擬機編譯測試&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs Build Status: &lt;a href="https://travis-ci.org/KmolYuan/Pyslvs-PyQt5"&gt;&lt;img alt="Build Status" src="https://travis-ci.org/KmolYuan/Pyslvs-PyQt5.svg" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Travis CI&lt;/h1&gt;
&lt;p&gt;Github 等較知名的倉儲管理系統或非營利組織 Pypi 成為各種程式的集散地，週邊衍生出一些提供第三方編譯認證的服務，讓個人電腦不用因為測試其他平台環境，而需要增加更多虛擬機檔案。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://travis-ci.org/"&gt;Travis CI&lt;/a&gt; 提供 Github 倉儲直接連接的功能，能針對帳戶內的倉儲的每個 branch 做&lt;strong&gt;編譯測試&lt;/strong&gt;與&lt;strong&gt;單元測試&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在欲使用測試服務的分支根目錄中新建一個 &lt;code&gt;.travis.yml&lt;/code&gt; 檔案，內容即為使用的虛擬機環境。&lt;/p&gt;
&lt;p&gt;目前為 Pyslvs 編寫的環境如下：&lt;/p&gt;
&lt;pre class="brush: yml"&gt;
dist: trusty
sudo: required
language: python

python:
- 3.4
- 3.5

before_install:
  #SIP
  - cd ..
  - curl -L -O "https://sourceforge.net/projects/pyqt/files/sip/sip-4.19.3/sip-4.19.3.tar.gz"
  - tar -xvf sip-4.19.3.tar.gz
  - cd sip-4.19.3
  - python configure.py
  - sudo make install
  #Qt5
  - sudo add-apt-repository -y "ppa:beineri/opt-qt59-trusty"
  - sudo apt-get update -qq
  - sudo apt-get install qt59-meta-full qt59charts-no-lgpl
  - QTDIR="/opt/qt59"
  - PATH="$QTDIR/bin:$PATH"
  - source /opt/qt59/bin/qt59-env.sh
  - qmake -v
  #PyQt5
  - cd ..
  - curl -L -O "https://sourceforge.net/projects/pyqt/files/PyQt5/PyQt-5.9/PyQt5_gpl-5.9.tar.gz"
  - tar -xvf PyQt5_gpl-5.9.tar.gz
  - cd PyQt5_gpl-5.9
  - python configure.py --confirm-license
  - sudo make install
  #QScintilla
  - cd ..
  - curl -L -O "https://sourceforge.net/projects/pyqt/files/QScintilla2/QScintilla-2.10.1/QScintilla_gpl-2.10.1.tar.gz"
  - tar -xvf QScintilla_gpl-2.10.1.tar.gz
  - cd QScintilla_gpl-2.10.1
  - cd Qt4Qt5
  - qmake qscintilla.pro
  - sudo make install
  - cd ../designer-Qt4Qt5
  - qmake designer.pro
  - sudo make install
  - cd ../Python
  - python configure.py --pyqt=PyQt5
  - sudo make install
  #PyQtChart
  - cd ../..
  - curl -L -O "https://sourceforge.net/projects/pyqt/files/PyQtChart/PyQtChart-5.9/PyQtChart_gpl-5.9.tar.gz"
  - tar -xvf PyQtChart_gpl-5.9.tar.gz
  - cd PyQtChart_gpl-5.9
  - python configure.py
  - sudo make install
  - cd $TRAVIS_BUILD_DIR

install:
  - pip install -r requirements.txt
  - pip install pyinstaller

script:
 - make

before_cache:
  - rm -rf $HOME/.cache/pip/log
cache:
  directories:
    - $HOME/.cache/pip
&lt;/pre&gt;

&lt;p&gt;在未註明作業系統的情況下，使用的是 linux，另外也有 OSX 與 Windows 的選擇，不過相關檔案和指令就必須增加辨識以調整之。&lt;/p&gt;
&lt;p&gt;當套件提供者使用 Trusty 時，會使用 Ubuntu 14.04 的作業系統執行，不過大部分的編譯工具都已內建，並且可以指定版本。&lt;/p&gt;
&lt;p&gt;若是沒有安裝（如 Qt 等函式庫），則可以使用 &lt;code&gt;install&lt;/code&gt; 指令集在虛擬機裝自己想要使用的套件，安裝套件必須將 sudo 選項啟用。&lt;/p&gt;
&lt;p&gt;Python 3 比較需要注意的是，雖然為 Ubuntu 14.04，但是調用 Python 選項後，整台電腦只會有一個 Python 版本，因此不用特別註明 pip3。&lt;/p&gt;
&lt;p&gt;由於上面的檔案中&lt;strong&gt;條列&lt;/strong&gt;了 Python，因此會建立 2 台虛擬機，分別上 Python 3.4 與 3.5（目前可以支援到最新的 3.7 測試版）。&lt;/p&gt;
&lt;p&gt;若是想針對各種混搭的環境測試，可以使用 &lt;code&gt;matrix&lt;/code&gt; 選項，建立更多不同種環境的虛擬機，更詳細的設定則可以參考&lt;a href="https://docs.travis-ci.com/"&gt;說明頁面&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;目前在這個服務中已經成功編譯 Solvespace 端口和 Pyslvs。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_07_06.png" /&gt;&lt;/p&gt;
&lt;p&gt;虛擬機在 &lt;code&gt;script&lt;/code&gt; 的指令都回傳 0 或是錯誤時會自動關機，留下 log 供參考。&lt;/p&gt;
&lt;p&gt;Travis CI 會在&lt;strong&gt;每次更新倉儲&lt;/strong&gt;時編譯，類似 gh-pages，不過因為要幫所有虛擬機開機，所以會過一段時間才會有結果。&lt;/p&gt;
&lt;p&gt;編譯後可以透過 commit 後的綠點圖示查看結果，或是使用 Shields.io 製作 Readme 的動態標籤。&lt;/p&gt;
&lt;h1&gt;Shields.io&lt;/h1&gt;
&lt;p&gt;&lt;a href="http://shields.io/"&gt;Shields.io&lt;/a&gt; 是 Javascript 寫成的 SVG 圖示服務，其中連結了各大倉儲網站，能夠蒐集並呈現不同的數據。&lt;/p&gt;
&lt;p&gt;透過修改網址的參數就能改變 badges 的設定，基本上可以直接參考網站上的範例就能添加 badges，追蹤倉儲的一些統計數據。&lt;/p&gt;</summary><category term="Pyslvs"></category><category term="Travis"></category></entry><entry><title>演算法設定介面</title><link href="http://project.mde.tw/blog/yan-suan-fa-she-ding-jie-mian.html" rel="alternate"></link><published>2017-07-05T21:00:00+08:00</published><updated>2017-07-05T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-07-05:blog/yan-suan-fa-she-ding-jie-mian.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;增加不同演算法的進階設定&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;八連桿模式預定&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;設定介面&lt;/h1&gt;
&lt;p&gt;由於多重分頁會帶來操作切換的困擾，因此將之前的三個部分合併到同個畫面中，試圖減少不需要留白的空間。&lt;/p&gt;
&lt;p&gt;新介面的選項部分能先指定演算法類型，接著按下「Advance」進入選項窗格調整細部參數。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_07_05_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;選項窗格為兩個分頁，第一頁目前為原本的結果範圍設定，第二頁則為不同演算法的設定。&lt;/p&gt;
&lt;p&gt;根據不同的選項設計參數，使用 Table Widget 設值和取值會更加方便。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_07_05_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;這部分之前給值都是散的，管理上比較不便，接下來會將第一頁的 Planar Linkage 也改成 Table Widget 的形式，以對應之後八連桿的演算法。&lt;/p&gt;
&lt;p&gt;再來此視窗會再加入網路設定的功能，整合 ZMQ 的設定，演算的服務則會分成「本機運算」和「分散運算」兩個鈕執行。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>平面連桿演算法使用參數</title><link href="http://project.mde.tw/blog/ping-mian-lian-gan-yan-suan-fa-shi-yong-can-shu.html" rel="alternate"></link><published>2017-07-04T21:00:00+08:00</published><updated>2017-07-04T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-07-04:blog/ping-mian-lian-gan-yan-suan-fa-shi-yong-can-shu.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;解析 &lt;code&gt;planarlinkage.pyx&lt;/code&gt; 輸入項目用途&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Version 0.8 開發方向&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;參數用途&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;planarlinkage.pyx&lt;/code&gt; 中的 &lt;code&gt;build_planar&lt;/code&gt; 為函式用途的物件類型，此函式接收參數時會針對平面連桿做數值的處理，並且&lt;strong&gt;會計算適應值&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;由於此函式物件原本是設計給四連桿，若是改為八連桿，勢必要做部份調整，以搭配演算法運算。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
mechanismParams = {
    'Driving':'A',
    'Follower':'D',
    'Link':'L0,L1,L2,L3,L4',
    'Target':'E',
    'ExpressionName':'PLAP,PLLP,PLLP',
    'Expression':'A,L0,a0,D,B,B,L1,L2,D,C,B,L3,L4,C,E',
    'targetPath':path,
    'constraint':[{'driver':'L0', 'follower':'L2', 'connect':'L1'}],
    'VARS':9,
    'formula':['PLAP','PLLP']}
mechanismObj = build_planar(mechanismParams)
&lt;/pre&gt;

&lt;p&gt;對應於下表：&lt;/p&gt;
&lt;style type="text/css"&gt;
.tg  {border-collapse:collapse;border-spacing:0;border-color:#ccc;}
.tg td{font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#ccc;color:#333;background-color:#fff;}
.tg th{font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#ccc;color:#333;background-color:#f0f0f0;}
.tg .tg-yw4l{vertical-align:top}
&lt;/style&gt;

&lt;table class="tg"&gt;
  &lt;tr&gt;
    &lt;th class="tg-yw4l"&gt;參數名稱&lt;/th&gt;
    &lt;th class="tg-yw4l"&gt;說明&lt;/th&gt;
    &lt;th class="tg-yw4l"&gt;輸入項目&lt;/th&gt;
    &lt;th class="tg-yw4l"&gt;Python 類別&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-yw4l"&gt;Driving&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;主動固定節點&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;節點代碼名稱&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;String&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-yw4l"&gt;Follower&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;從動固定節點&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;節點代碼名稱&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;String&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-yw4l"&gt;Link&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;連接桿&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;連桿代碼名稱，逗號分隔&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;String&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-yw4l"&gt;Target&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;目標節點&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;節點代碼名稱&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;String&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-yw4l"&gt;ExpressionName&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;堆疊機構的三角形&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;三角形表示式，逗號分隔&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;String&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-yw4l"&gt;Expression&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;參數排序&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;全部代碼名稱，逗號分隔&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;String&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-yw4l"&gt;targetPath&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;路徑&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;路徑點座標集&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;Tuple [Float]&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-yw4l"&gt;constraint&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;driver：主動桿&lt;br&gt;follower：從動桿&lt;br&gt;connect：連接桿&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;三組連桿代碼名稱&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;Dictionary [String]&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-yw4l"&gt;VARS&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;參數數目&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;四連桿變數共9個&lt;br&gt;（八連桿變數共18個）&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;Integer&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-yw4l"&gt;formula&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;方程式名稱&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;對應 tinycadlab 的定義&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;List [String]&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;其中，雖然有些部份針對四連桿做設計，但是透過修改 &lt;code&gt;'ExpressionName'&lt;/code&gt; 和 &lt;code&gt;'Expression'&lt;/code&gt; 就可以改變三角形堆疊的方式，也意味著可以透過 Pyslvs 的三角迭代器輸入三角形的樣式，將其他種類的連桿套用演算法合成尺寸。&lt;/p&gt;
&lt;p&gt;不過這個函式只有一個 Follower 的設定，若有其他從動的固定節點，得修改函式才能計算。&lt;/p&gt;
&lt;p&gt;而目前看來，要套用八連桿的演算法，修改給定的參數應該就能達成。&lt;/p&gt;
&lt;h1&gt;Version 0.8 目標&lt;/h1&gt;
&lt;p&gt;可能得處理一下 Cython 執行序的問題，當前除了動用系統強制砍掉程序，似乎沒有中止演算法的方式，是否要在 Cython 中增加檢查停止的機制？&lt;/p&gt;
&lt;p&gt;接下來 Version 0.8 的目標如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;改善演算法的設定介面，如手動設定族群或機率的功能。&lt;/li&gt;
&lt;li&gt;會融入 Qt 網路引擎和 PyZMQ 進行本機分散運算的測試。&lt;/li&gt;
&lt;/ol&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Pyslvs 手冊：安裝</title><link href="http://project.mde.tw/blog/pyslvs-shou-ce-an-zhuang.html" rel="alternate"></link><published>2017-07-02T21:00:00+08:00</published><updated>2017-07-02T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-07-02:blog/pyslvs-shou-ce-an-zhuang.html</id><summary type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;h1&gt;安裝&lt;/h1&gt;
&lt;p&gt;以下將介紹如何在不同作業系統中運行 Pyslvs 套件。&lt;/p&gt;
&lt;h2&gt;Windows 平台&lt;/h2&gt;
&lt;p&gt;Windows 平台的版本為可獨立執行檔案，下載後雙擊即可啟動 Pyslvs。&lt;/p&gt;
&lt;h2&gt;Ubuntu 平台&lt;/h2&gt;
&lt;p&gt;Ubuntu 平台上採用 Debian package 安裝。&lt;/p&gt;
&lt;p&gt;透過 dpkg 套件將安裝檔的內容複製到系統中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo dpkg -i pyslvs_vX.X_ubuntu_x64.deb
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接著透過指令啟動 Pyslvs。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pyslvs
&lt;/pre&gt;&lt;/div&gt;</summary><category term="pyslvs-manual-sphinx"></category></entry><entry><title>Pyslvs 手冊：介面</title><link href="http://project.mde.tw/blog/pyslvs-shou-ce-jie-mian.html" rel="alternate"></link><published>2017-07-02T21:00:00+08:00</published><updated>2017-07-02T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-07-02:blog/pyslvs-shou-ce-jie-mian.html</id><summary type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;h1&gt;介面&lt;/h1&gt;
&lt;p&gt;主畫面的上方為功能表列 (Menu bar)、右側為畫布 (Canvas)；左方則有各式功能的分頁欄 (Tab widgets)。&lt;/p&gt;
&lt;p&gt;功能表列涵蓋大部分的功能，然而一些有關各項目的細部操作，則必須在對應的分頁欄中選取或設定。以下小節將為主畫面中不同區域的功能名稱做簡單的介紹。&lt;/p&gt;
&lt;h2&gt;功能表列 (Menu bar)&lt;/h2&gt;
&lt;p&gt;功能表列中根據不同的功能分類，如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;檔案 (File)&lt;/p&gt;
&lt;p&gt;建立新的工作簿、開啟既有的工作簿、參考範例，或是不同檔案格式的匯入與匯出功能。&lt;/p&gt;
&lt;p&gt;另外還有調整視窗縮放的指令，而功能表列在全螢幕模式仍會顯示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;編輯 (Edit)&lt;/p&gt;
&lt;p&gt;復原與重做功能、一些輔助編輯機構節點的指令。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;繪製 (Draw)&lt;/p&gt;
&lt;p&gt;建立、編輯、刪除機構實體的功能，還有更新當前座標至原始座標的指令。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模擬 (Simulation)&lt;/p&gt;
&lt;p&gt;建立、編輯、刪除機構約束的功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;路徑 (Path)&lt;/p&gt;
&lt;p&gt;路徑追蹤功能的相關指令與顯示設定。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;選項 (Options)&lt;/p&gt;
&lt;p&gt;檢視方式調整以及工作簿相關資訊。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;說明 (Help)&lt;/p&gt;
&lt;p&gt;本套件的相關網站與套件資訊。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;功能表列中的功能都有對應的快捷鍵，參考如下：&lt;/p&gt;
&lt;style type="text/css"&gt;
.tg  {border-collapse:collapse;border-spacing:0;border-color:#ccc;}
.tg td{font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#ccc;color:#333;background-color:#fff;}
.tg th{font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#ccc;color:#333;background-color:#f0f0f0;}
.tg .tg-yw4l{vertical-align:top}
&lt;/style&gt;

&lt;table class="tg"&gt;
&lt;tr&gt;
&lt;th class="tg-yw4l"&gt;熱鍵&lt;/th&gt;
&lt;th class="tg-yw4l"&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tg-yw4l"&gt;F1&lt;/td&gt;
&lt;td class="tg-yw4l"&gt;關於 Pyslvs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tg-yw4l"&gt;F2&lt;/td&gt;
&lt;td class="tg-yw4l"&gt;新增 - 節點&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tg-yw4l"&gt;F3&lt;/td&gt;
&lt;td class="tg-yw4l"&gt;新增 - 連桿&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tg-yw4l"&gt;F4&lt;/td&gt;
&lt;td class="tg-yw4l"&gt;新增 - 固定鍊&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tg-yw4l"&gt;F5&lt;/td&gt;
&lt;td class="tg-yw4l"&gt;設置 - 驅動軸&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tg-yw4l"&gt;F6&lt;/td&gt;
&lt;td class="tg-yw4l"&gt;設置 - 滑塊&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tg-yw4l"&gt;F7&lt;/td&gt;
&lt;td class="tg-yw4l"&gt;設置 - 伸縮桿&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tg-yw4l"&gt;F10&lt;/td&gt;
&lt;td class="tg-yw4l"&gt;顯示 / 隱藏 - 節點標記&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tg-yw4l"&gt;F11&lt;/td&gt;
&lt;td class="tg-yw4l"&gt;顯示 / 隱藏 - 尺寸標註&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tg-yw4l"&gt;Shift + F1&lt;/td&gt;
&lt;td class="tg-yw4l"&gt;全螢幕&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tg-yw4l"&gt;Shift + F2&lt;/td&gt;
&lt;td class="tg-yw4l"&gt;還原視窗&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tg-yw4l"&gt;Space&lt;/td&gt;
&lt;td class="tg-yw4l"&gt;縮放畫布至合適大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tg-yw4l"&gt;Esc&lt;/td&gt;
&lt;td class="tg-yw4l"&gt;關閉所有面板&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tg-yw4l"&gt;Ctrl + N&lt;/td&gt;
&lt;td class="tg-yw4l"&gt;新建工作簿&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tg-yw4l"&gt;Ctrl + O&lt;/td&gt;
&lt;td class="tg-yw4l"&gt;載入工作簿&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tg-yw4l"&gt;Ctrl + S&lt;/td&gt;
&lt;td class="tg-yw4l"&gt;儲存工作簿&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tg-yw4l"&gt;Ctrl + Shift + S&lt;/td&gt;
&lt;td class="tg-yw4l"&gt;另存工作簿&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tg-yw4l"&gt;Ctrl + Q&lt;/td&gt;
&lt;td class="tg-yw4l"&gt;離開 Pyslvs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tg-yw4l"&gt;Ctrl + Z&lt;/td&gt;
&lt;td class="tg-yw4l"&gt;復原指令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tg-yw4l"&gt;Ctrl + Shift + Z&lt;/td&gt;
&lt;td class="tg-yw4l"&gt;重做指令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tg-yw4l"&gt;Ctrl + F&lt;/td&gt;
&lt;td class="tg-yw4l"&gt;節點關聯&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tg-yw4l"&gt;Ctrl + R&lt;/td&gt;
&lt;td class="tg-yw4l"&gt;取代節點&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tg-yw4l"&gt;Ctrl + B&lt;/td&gt;
&lt;td class="tg-yw4l"&gt;批次移動&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tg-yw4l"&gt;Ctrl + 3&lt;/td&gt;
&lt;td class="tg-yw4l"&gt;Solvespace 3D 模型格式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tg-yw4l"&gt;Ctrl + 2&lt;/td&gt;
&lt;td class="tg-yw4l"&gt;Solvespace 2D 草圖格式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tg-yw4l"&gt;Ctrl + D&lt;/td&gt;
&lt;td class="tg-yw4l"&gt;DXF 2D 模型格式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tg-yw4l"&gt;Ctrl + Shift + D&lt;/td&gt;
&lt;td class="tg-yw4l"&gt;DXF 2D 草圖格式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tg-yw4l"&gt;Ctrl + P&lt;/td&gt;
&lt;td class="tg-yw4l"&gt;圖片格式&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;h2&gt;畫布 (Canvas)&lt;/h2&gt;
&lt;p&gt;工作簿中的機構樣貌會呈現在畫布中。&lt;/p&gt;
&lt;p&gt;畫布下方為導覽列，提供瀏覽提示、縮放等級、縮放畫布至合適大小的功能，另外也會顯示工作簿的機構自由度。&lt;/p&gt;
&lt;p&gt;瀏覽提示圖示將會顯示進階的滑鼠操作，可以幫助您更快地調整檢視的視角：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Ctrl + 滑鼠雙擊：將畫布原點移動至滑鼠位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ctrl + 滑鼠按住（可拖動）：將畫布原點移動至滑鼠位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;滑鼠滾輪或中鍵拖曳：平移。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;滑鼠滾輪滾動：縮放大小。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Alt + 滑鼠雙擊：快速加入一個普通節點。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;滑鼠中鍵雙擊或 Space 鍵：縮放畫布至合適大小。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;畫布的滑鼠右鍵選單則可以快速加入普通節點和固定節點。&lt;/p&gt;</summary><category term="pyslvs-manual-sphinx"></category></entry><entry><title>Sphinx 樣板</title><link href="http://project.mde.tw/blog/sphinx-yang-ban.html" rel="alternate"></link><published>2017-06-28T21:00:00+08:00</published><updated>2017-06-28T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-06-28:blog/sphinx-yang-ban.html</id><summary type="html">&lt;p&gt;利用 Sphinx 模組建立 HTML 說明文件&lt;/p&gt;


&lt;h1&gt;Sphinx&lt;/h1&gt;
&lt;p&gt;透過 pip 安裝 Python 的 Sphinx 模組。&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
$sudo pip3 install sphinx -U
&lt;/pre&gt;

&lt;p&gt;接著建立一個預定存放文章的資料夾，並在此處用終端機建立 Sphinx 專案。&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
$sphinx-quickstart
&lt;/pre&gt;

&lt;p&gt;這時會開始做專案設定，中括號的選項為預設值，大略如下所示。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Root path for the documentation [.]:&lt;/p&gt;
&lt;p&gt;文件的根目錄。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Separate source and build directories (y/n) [n]: &lt;strong&gt;y&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是否分開原始碼和建置目錄，這裡做分開比較好查看內容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Name prefix for templates and static dir [_]:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;templates&lt;/code&gt; 和 &lt;code&gt;static&lt;/code&gt; 資料夾的前綴符號。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Author name(s): &lt;strong&gt;作者&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;設定作者名字。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Project version [] / Project release []:&lt;/p&gt;
&lt;p&gt;此專案的套件版本和發行版本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Project language [en]: &lt;strong&gt;zh_TW&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;專案語系，會影響網站中「目錄」、「本頁」、「快速搜尋」字樣的顯示語言。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Source file suffix [.rst]:&lt;/p&gt;
&lt;p&gt;支援原始碼的副檔名，在未安裝附加套件前，Sphinx 只會轉換 reStructuredText (rST) 的語法，之後可以增加 Markdown。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Name of your master document (without suffix) [index]:&lt;/p&gt;
&lt;p&gt;首頁的檔案名稱，不包含副檔名，預設轉換後對應「index.html」。如果上面的副檔名維持預設的 .rst，會比較好轉換。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Do you want to use the epub builder (y/n) [n]:&lt;/p&gt;
&lt;p&gt;增加 epub 電子書格式的支援。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Please indicate if you want to use one of the following Sphinx extensions:&lt;/p&gt;
&lt;p&gt;以下都是 Sphinx 擴充功能的開關，不過若是以後要啟用，也可以直接修改 &lt;code&gt;conf.py&lt;/code&gt; 文件變更設定。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;autodoc&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;doctest&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;intersphinx&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;todo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;coverage&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;imgmath / mathjax（擇一）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ifconfig&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;viewcode&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;githubpages&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create Makefile? (y/n) [y]:&lt;/p&gt;
&lt;p&gt;生成 Makefile 以便直接轉檔。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create Windows command file? (y/n) [y]: &lt;strong&gt;n&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;若 Windows 平台沒裝 GNU 工具，可以透過批次檔轉檔。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Makefile&lt;/h2&gt;
&lt;p&gt;接下來，修改專案根目錄中的 &lt;code&gt;Makefile&lt;/code&gt;，將 SPHINXBUILD 這個參數的值改成 sphinx-build，以解決在 Ubuntu 平台會呼叫成 Python 2 的問題。&lt;/p&gt;
&lt;p&gt;Makefile 中也能設定輸入輸出的目錄。&lt;/p&gt;
&lt;h2&gt;增加 Markdown 支援&lt;/h2&gt;
&lt;p&gt;上述提及 Sphinx 沒有 Markdown 語法的支援，因此必須額外增加一個模組幫忙解析。&lt;/p&gt;
&lt;p&gt;安裝另一個 Python 模組 recommonmark。&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
$sudo pip3 install recommonmark
&lt;/pre&gt;

&lt;p&gt;編輯 &lt;code&gt;source&lt;/code&gt; 目錄下的 &lt;code&gt;conf.py&lt;/code&gt; 文件，這裡是紀錄設定的腳本檔案。&lt;/p&gt;
&lt;p&gt;找到關於 source_suffix 的設定，改成如下：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
# The suffix(es) of source filenames.
# You can specify multiple suffix as a list of string:
#
# source_suffix = ['.rst', '.md']
from recommonmark.parser import CommonMarkParser
source_parsers = {
    '.md': CommonMarkParser,
}
source_suffix = ['.rst', '.md']
&lt;/pre&gt;

&lt;p&gt;這樣就同時支援 reStructuredText 和 Markdown 語法了。&lt;/p&gt;
&lt;h2&gt;index 目錄&lt;/h2&gt;
&lt;p&gt;預設的 index 目錄為 reStructuredText 語法，這邊注意如果大小標題的底線沒有超出標題文字長度（全形字元為 2 格），轉換時會發生 &lt;strong&gt;Title underline is short&lt;/strong&gt; 警告，甚至可能會跳過本章的標題，造成目錄空白。&lt;/p&gt;
&lt;p&gt;其中包含章節的結構樹如下：&lt;/p&gt;
&lt;pre class="brush: text"&gt;
.. toctree::
   :maxdepth: 2
   :caption: Contents:
&lt;/pre&gt;

&lt;p&gt;其中 maxdepth 為目錄顯示最多的層級數；caption 為目錄上方的文字顯示。&lt;/p&gt;
&lt;p&gt;可以添加文件名稱到底下，讓 Sphinx 排序不同檔案的章節順序，如下：&lt;/p&gt;
&lt;pre class="brush: text"&gt;
.. toctree::
   :maxdepth: 2
   :caption: 目錄:

   setup
   environment
&lt;/pre&gt;

&lt;p&gt;這裡添加檔名即可，只要是支援的副檔名即可。&lt;/p&gt;
&lt;h2&gt;編出 HTML&lt;/h2&gt;
&lt;p&gt;接下來，透過 Makefile 生成 HTML 文件，這部份也類似 Pandoc 的流程。&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
$make html
&lt;/pre&gt;

&lt;p&gt;接著進入 &lt;code&gt;build&lt;/code&gt; 資料夾，用網頁瀏覽器開啟 &lt;code&gt;index.html&lt;/code&gt; 檢視成果。&lt;/p&gt;</summary><category term="Sphinx"></category></entry><entry><title>Python-Solvespace 編譯整理</title><link href="http://project.mde.tw/blog/python-solvespace-bian-yi-zheng-li.html" rel="alternate"></link><published>2017-06-27T21:00:00+08:00</published><updated>2017-06-27T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-06-27:blog/python-solvespace-bian-yi-zheng-li.html</id><summary type="html">&lt;p&gt;整理 Python-Solvespace 端口的編譯流程&lt;/p&gt;


&lt;h1&gt;Python 位置提供&lt;/h1&gt;
&lt;p&gt;利用 Python 的 sysconfig 模組，可以取得 Python 相關路徑的位置，進而回傳至 Makefile 以供編譯參數使用。&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
$python3 -m sysconfig
&gt;python -m sysconfig
&lt;/pre&gt;

&lt;p&gt;以 Windows 平台的 Python 3.5 為例，得到數值如下：&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
Platform: "win-amd64"
Python version: "3.5"
Current installation scheme: "nt"

Paths:
        data = "C:\Users\...\Python35"
        include = "C:\Users\...\Python35\Include"
        platinclude = "C:\Users\...\Python35\Include"
        platlib = "C:\Users\...\Python35\Lib\site-packages"
        platstdlib = "C:\Users\...\Python35\Lib"
        purelib = "C:\Users\...\Python35\Lib\site-packages"
        scripts = "C:\Users\...\Python35\Scripts"
        stdlib = "C:\Users\...\Python35\Lib"

Variables:
        BINDIR = "C:\Users\...\Python35"
        BINLIBDEST = "C:\Users\...\Python35\Lib"
        ...
&lt;/pre&gt;

&lt;p&gt;其中不同平台得到的路徑會不太一樣，如 Ubuntu 得到的變數種類更多。&lt;/p&gt;
&lt;p&gt;這些變數可以透過下列 Python 程式得到。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from distutils import sysconfig
print(sysconfig.get_config_var('BINDIR'))
#C:\Users\...\Python35
&lt;/pre&gt;

&lt;p&gt;因此，在 Makefile 的指令中，可以以一行式得到路徑參數：&lt;/p&gt;
&lt;pre class="brush: Makefile"&gt;
    g++ -shared -o _slvs.pyd $^ -L. -l:libslvs.so \
-L$(shell python -c "from distutils import sysconfig;print(sysconfig.get_config_var('BINDIR'))")\libs \
-lPython$(shell python -c "from distutils import sysconfig;print(sysconfig.get_config_var('VERSION'))") \
-Wl,--output-def,libslvs.def,--out-implib,libslvs.lib

#同於：
    g++ -shared -o _slvs.pyd $^ -L. -l:libslvs.so \
-LC:\Users\...\Python35\libs \
-lPython35 \
-Wl,--output-def,libslvs.def,--out-implib,libslvs.lib
&lt;/pre&gt;

&lt;p&gt;藉此，可免去使用 Python 腳本產生 Makefile 不便的過程。&lt;/p&gt;
&lt;h1&gt;Windows 平台的 Python 設定&lt;/h1&gt;
&lt;p&gt;由於之前換過 Python 版本，導致 Windows 平台的原始碼和編譯器設定必須一起更動。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;libpython3x.a&lt;/code&gt; 沒有提供。&lt;/p&gt;
&lt;p&gt;這個問題在最近的 Python 3.5、3.6 中都已提供，不須要手動製作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;原始碼與編譯器&lt;/p&gt;
&lt;p&gt;必須修改 &lt;code&gt;include\pyconfig.h&lt;/code&gt; 和 &lt;code&gt;Lib\distutils\cygwinccompiler.py&lt;/code&gt;，否則會導致 SWIG 製作的端口會有錯誤。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;math.h&lt;/code&gt; 與 &lt;code&gt;pyconfig.h&lt;/code&gt; 衝突&lt;/p&gt;
&lt;p&gt;修改 &lt;code&gt;pyconfig.h&lt;/code&gt; 的 &lt;code&gt;#define hypot _hypot&lt;/code&gt;，只要改 GCC Compiler 的部分即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上述問題的解決方案都寫在 &lt;code&gt;exposed&lt;/code&gt; 資料夾的 &lt;code&gt;Readme.md&lt;/code&gt; 中，若是使用 Windows 平台新安裝的 Python，就必須注意調整。&lt;/p&gt;
&lt;p&gt;而 Ubuntu 平台則無需調整。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>PyZMQ Local testing</title><link href="http://project.mde.tw/blog/pyzmq-local-testing.html" rel="alternate"></link><published>2017-06-25T21:00:00+08:00</published><updated>2017-06-25T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-06-25:blog/pyzmq-local-testing.html</id><summary type="html">&lt;p&gt;ZeroMQ 本機程式測試&lt;/p&gt;


&lt;h1&gt;ZeroMQ&lt;/h1&gt;
&lt;p&gt;安裝 Python ZMQ 套件，安裝前必須先裝過 Cython 套件。&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
$sudo pip3 install pyzmq
&lt;/pre&gt;

&lt;p&gt;接著測試以下範例程式。&lt;/p&gt;
&lt;h1&gt;範例程式&lt;/h1&gt;
&lt;p&gt;參考來源：&lt;a href="http://blog.ez2learn.com/2011/12/31/transport-lib-of-new-era-zeromq/"&gt;http://blog.ez2learn.com/2011/12/31/transport-lib-of-new-era-zeromq/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;將以上來源的範例程式測試並由 Python 2 轉成 Python 3，目標為分配 9 組隨機的加法計算式給客戶端運算，並回傳結果至伺服端。&lt;/p&gt;
&lt;p&gt;客戶端（&lt;code&gt;rep.py&lt;/code&gt;）：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
import os
import zmq

context = zmq.Context()
socket = context.socket(zmq.REP)
socket.connect("tcp://localhost:7788")
print('Worker {} is running ...'.format(os.getpid()))

while True:
    # receive request
    a, b = socket.recv_multipart()
    a = int(a)
    b = int(b)
    print('Compute {} + {} and send response'.format(a, b))
    socket.send_string(str(a + b))
&lt;/pre&gt;

&lt;p&gt;伺服端（&lt;code&gt;req.py&lt;/code&gt;）：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
import zmq
import random
import time

context = zmq.Context()
socket = context.socket(zmq.REQ)
socket.bind("tcp://*:7788")

# wait all worker connected
time.sleep(1)

for i in range(9):
    a = random.randint(0, 100)
    b = random.randint(0, 100)
    print('Compute {} + {} ...'.format(a, b))

    # send request to peer
    socket.send_multipart([str(a).encode("utf-8"), str(b).encode("utf-8")])
    # receive response from peer
    rep = socket.recv().decode("utf-8")
    print(' = {}'.format(rep))
&lt;/pre&gt;

&lt;p&gt;此時先啟動 4 組客戶端程式，接著再啟動伺服端程式。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/pyslvs/17_06_25.png" /&gt;&lt;/p&gt;
&lt;p&gt;可以發現，每個客戶端程式接收了 2 組計算式（第一個接收 3 組），完成 9 組加法計算。&lt;/p&gt;</summary><category term="ZMQ"></category></entry><entry><title>Compiling V-rep 3.4</title><link href="http://project.mde.tw/blog/compiling-v-rep-34.html" rel="alternate"></link><published>2017-06-23T21:00:00+08:00</published><updated>2017-06-23T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-06-23:blog/compiling-v-rep-34.html</id><summary type="html">&lt;p&gt;編譯 V-rep 程式庫&lt;/p&gt;


&lt;h1&gt;編譯 V-rep 程式庫&lt;/h1&gt;
&lt;p&gt;本流程採用 Ubuntu 系統。&lt;/p&gt;
&lt;h2&gt;環境需求&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Boost C++ Library&lt;/li&gt;
&lt;li&gt;Lua 5.1（目前 V-rep 指定此版本）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;到&lt;a href="http://www.boost.org/"&gt;官方網站&lt;/a&gt;下載 Boost 並安裝。&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
$./bootstrap.sh
$sudo ./b2 install --build-type=complete --layout=versioned threading=multi --prefix="/usr/lib/boost-1.6"
&lt;/pre&gt;

&lt;p&gt;如 Qt 的環境變數，必須加入 Boost 的參照位置，如 &lt;code&gt;/usr/lib/boost-1.6/include/boost-1_64&lt;/code&gt;。&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
export C_INCLUDE_PATH=/usr/lib/boost-1.6/include/boost-1_64:$C_INCLUDE_PATH
export CPLUS_INCLUDE_PATH=/usr/lib/boost-1.6/include/boost-1_64:$CPLUS_INCLUDE_PATH
export LD_LIBRARY_PATH=/usr/lib/boost-1.6/lib:$LD_LIBRARY_PATH
export LIBRARY_PATH=/usr/lib/boost-1.6/lib:$LIBRARY_PATH
&lt;/pre&gt;

&lt;p&gt;Lua 使用 PPA 提供的來源：&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
$sudo apt install lua5.1 lua5.1-dev
&lt;/pre&gt;

&lt;h2&gt;編譯流程&lt;/h2&gt;
&lt;p&gt;建立一個資料夾，並將 V-REP source code 解壓縮至其中（其他附加元件可選），該名稱為 &lt;code&gt;v_rep&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;複製 V-REP PRO 中的 &lt;code&gt;programming&lt;/code&gt; 資料夾到新建的資料夾中。&lt;/p&gt;
&lt;p&gt;檔案結構如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.coppeliarobotics.com/helpFiles/en/images/folderStructure.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;首先進入 &lt;code&gt;v_rep&lt;/code&gt; 資料夾中啟動終端機。&lt;/p&gt;
&lt;p&gt;由於只要編譯程式庫，使用 &lt;code&gt;makefile_noGui_noGl&lt;/code&gt; 這個 Makefile 即可，不用使用 Qt。&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
$make -f makefile_noGui_noGl
&lt;/pre&gt;

&lt;p&gt;編譯完成後，可以在 &lt;code&gt;v_rep&lt;/code&gt;/&lt;code&gt;lib&lt;/code&gt; 資料夾底下獲得共享函式庫 &lt;code&gt;libv_rep.so&lt;/code&gt;，即為 V-rep 的核心程式庫。&lt;/p&gt;
&lt;p&gt;本次編譯後的大小為 9.9 MB，較官方提供的 12 MB 稍小些。&lt;/p&gt;</summary><category term="V-rep"></category></entry><entry><title>專題模板說明</title><link href="http://project.mde.tw/blog/zhuan-ti-mo-ban-shuo-ming.html" rel="alternate"></link><published>2017-06-02T21:00:00+08:00</published><updated>2017-06-02T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-06-02:blog/zhuan-ti-mo-ban-shuo-ming.html</id><summary type="html">&lt;p&gt;Leo Editor 專題模板&lt;/p&gt;
&lt;p&gt;倉儲：&lt;a href="https://github.com/KmolYuan/Leo-editor-report-template"&gt;https://github.com/KmolYuan/Leo-editor-report-template&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;協同規則&lt;/li&gt;
&lt;li&gt;設定&lt;/li&gt;
&lt;li&gt;預覽圖&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Leo Editor 專題模板&lt;/h1&gt;
&lt;p&gt;搭配 Pandoc 將 Markdown 文件轉為 PDF。&lt;/p&gt;
&lt;p&gt;將 template.tex 調整過後，把中英文字型分開，並將英文名稱轉為中文，可以生成接近 Word 格式排版的狀態。&lt;/p&gt;
&lt;p&gt;之後會盡快補完之前的 &lt;a href="http://project.mde.tw/blog/pandoc-markdown-ji-ben-yu-fa-jie-shao.html"&gt;Markdown 語法說明&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;環境準備：Windows 與 Ubuntu 雙平台的 &lt;a href="http://project.mde.tw/blog/pandoc-markdown-zhuan-pdf-ge-shi.html"&gt;Pandoc 安裝說明&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;這個倉儲會持續更新，要獲得更新後的設定，可以下載新版的 template.tex 即可。&lt;/p&gt;
&lt;p&gt;參考模板：&lt;a href="https://github.com/kmollee/nfu-thesis-template/blob/master/template.tex"&gt;https://github.com/kmollee/nfu-thesis-template/blob/master/template.tex&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;協同規則&lt;/h2&gt;
&lt;p&gt;所有 Leo 專案檔皆有所職，以 master 為主，負責控管封面、摘要、模板檔案。&lt;/p&gt;
&lt;p&gt;組員根據 contributor1.leo 的樣式創建負責的 Markdown 文件，命名規則為 paragraph 加上章節順序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最後 Pandoc 合併時會以 &lt;code&gt;master&lt;/code&gt;+&lt;code&gt;paragraph1&lt;/code&gt;+&lt;code&gt;paragraph2&lt;/code&gt; 的順序合併。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注意在 Windows 平台的 Pandoc 不支援星號輸入，必須將 &lt;code&gt;script.py&lt;/code&gt; 中的 &lt;code&gt;paragraph*.md&lt;/code&gt; 改成 &lt;code&gt;paragraph1.md&lt;/code&gt; &lt;code&gt;paragraph2.md&lt;/code&gt; ... 的方式輸入。&lt;/p&gt;
&lt;p&gt;Leo 專案中，直接點擊 report-pdf 按鈕即可開始轉檔。&lt;/p&gt;
&lt;h2&gt;設定&lt;/h2&gt;
&lt;p&gt;採用以下設定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;語系：中文（&lt;code&gt;-V lang=chinese&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;自動生成：目錄、表目錄、圖目錄（&lt;code&gt;--toc&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;自動分節（&lt;code&gt;-N&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;程式碼標示：Kate（&lt;code&gt;--highlight-style kate&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;整體設定（&lt;code&gt;-V documentclass=report&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;使用模組：圖片參照 pandoc-fignos（&lt;code&gt;--filter pandoc-fignos&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;自訂模板：template.tex（&lt;code&gt;--template=template.tex&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;中文字型：Windows 標楷體；Ubuntu 教育部標準楷書（&lt;code&gt;-V "CJKmainfont:標楷體"&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;內文字體大小：12 號（&lt;code&gt;-V fontsize=12pt&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;邊界設定：1 英吋（&lt;code&gt;-V geometry:margin=1in&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;英文字型：Times New Roman&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;預覽圖&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0315_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0315_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0315_03.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0315_04.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0315_05.png" /&gt;&lt;/p&gt;</summary><category term="Leo Editor"></category><category term="Pandoc"></category></entry><entry><title>G2書面內容</title><link href="http://project.mde.tw/blog/g2shu-mian-nei-rong.html" rel="alternate"></link><published>2017-05-24T14:00:00+08:00</published><updated>2017-05-24T14:00:00+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2017-05-24:blog/g2shu-mian-nei-rong.html</id><summary type="html">&lt;p&gt;以下為Paper部分內容
&lt;/p&gt;
&lt;p&gt;中文摘要 : &lt;/p&gt;
&lt;p&gt;本研究針對3D Printer在虛擬模擬列印上，在初期我們使用Solvespace研究八連桿機構，並透過3D Printer列印出零件來驗證，但過程中時常發生列印件有翹曲或者是堵料等狀況，小組討論時想到許多車、銑加工都可以透過CNC來模擬整個過程，而較少有研究完整模擬3D Printer列印狀況的軟體，我們就逐漸往這方面思考，最後發現一套名為 V-rep 的機器人模擬軟體，在看過這套軟體所製作出的成果影片後開始著手朝向模擬列印的目標研究。 
由於Solvespace早已於2013年7月份，公開解幾合約束的程式庫，所以大家也討論，若可以自己寫一套簡單的平面機構與尺寸合成的程式，就能輔助驗證連桿機構，所以衍生出Pyslvs這個套件的開發。
中文關鍵字：虛擬模擬列印、連桿機構、虛實整合
英文關鍵字：3D Printer, V-rep, Solvespace, Virtual Printer simulation&lt;/p&gt;
&lt;p&gt;英文摘要 : &lt;/p&gt;
&lt;p&gt;The research is against Virtual Printing Simulation on Delta 3D Printer. In the beginning, we researched eight-linkage mechanism by Solvespace. We used 3D Printer to print components, but it usually happened problems during the printing, like warping and blocking material. We thought that CNC can simulate the whole process, but it seldom researched 3D Printer simulation. And we gradually thought to there. Finally, we found an application of Robot simulation called V-rep. After viewing the achievements, we started to research the Print Simulation. 
Solvespace early opened a database of solving geometric constraints, therefore we discussed to program a simple application of plane mechanism and dimensional synthesis. It can assist to test the mechanism, so Pyslvs was derived.&lt;/p&gt;
&lt;p&gt;研究動機 :&lt;/p&gt;
&lt;p&gt;一開始我們透過Solvespace研究八連桿機構，並利用 3D Printer 印製零件組裝，但是在印製的過程時常出現問題，導致花費許多時間和材料。 &lt;/p&gt;
&lt;p&gt;經過討論想到如果有一套能夠模擬 3D 列印的軟體，先經過這套軟體的模擬可以降低錯誤的發生率，也可以提升印製的品質。&lt;/p&gt;
&lt;p&gt;結論 :&lt;/p&gt;
&lt;p&gt;當自己設計的機構能使用自己寫的程式來驗證，並能透過虛擬列印零件、組立完成加以模擬，完全不用消耗任何實體資源，能夠替我們省下許多修正錯誤的時間。 &lt;/p&gt;
&lt;p&gt;若在未來能持續往這方面發展，並將模擬驗證的誤差控制在範圍內時，大部分的機械式系統將會迅速的向上發展。&lt;/p&gt;</summary><category term="Paper"></category></entry><entry><title>40323230日誌 - 106/05/06</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060506.html" rel="alternate"></link><published>2017-05-06T21:00:00+08:00</published><updated>2017-05-06T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-05-06:blog/40323230ri-zhi-1060506.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;嵌入 Console 窗格&lt;/li&gt;
&lt;li&gt;顏色預覽&lt;/li&gt;
&lt;li&gt;載入後資訊提示&lt;/li&gt;
&lt;li&gt;XML 支援滑鼠拖入開啟&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;嵌入 Console 窗格&lt;/h2&gt;
&lt;p&gt;將原本顯示在終端機的 Log 資訊都搬到 GUI 中，這樣 Windows 包裝時可以選擇不要顯示文字提示（但是會失去 Help 功能）。&lt;/p&gt;
&lt;p&gt;不過主要目的是複製輸出文字會比較快速，不用切換到 Command line 或 Console。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0506_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;要在 Qt 中將 stdout、stderr 或 logging 輸出到 QTextBrowser 上，可以撰寫以下檔案：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
# -*- coding: utf-8 -*-
from PyQt5.QtCore import *
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
import sys, logging

class QtHandler(logging.Handler):
    def __init__(self):
        logging.Handler.__init__(self)
    def emit(self, record):
        record = self.format(record)
        if record: XStream.stdout().write('{}\n'.format(record))

logger = logging.getLogger(__name__)
handler = QtHandler()
handler.setFormatter(logging.Formatter("%(asctime)s | %(message)s"))
logger.addHandler(handler)

class XStream(QObject):
    _stdout = None
    _stderr = None
    messageWritten = pyqtSignal(str)
    def flush(self): pass
    def fileno(self): return -1
    def write(self, msg):
        if not self.signalsBlocked(): self.messageWritten.emit(msg)
    @staticmethod
    def stdout():
        if not XStream._stdout:
            XStream._stdout = XStream()
            sys.stdout = XStream._stdout
        return XStream._stdout
    @staticmethod
    def stderr():
        if not XStream._stderr:
            XStream._stderr = XStream()
            sys.stderr = XStream._stderr
        return XStream._stderr
&lt;/pre&gt;

&lt;p&gt;設一個方法讓 QTextBrowser 接收訊息並顯示，每次更新先捲到最尾端，插入文字後再捲到底一次。&lt;/p&gt;
&lt;p&gt;接著，在 QTextBrowser 的視窗中為其連接信號槽：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#In the window
XStream.stdout().messageWritten.connect(self.appendToConsole)
XStream.stderr().messageWritten.connect(self.appendToConsole)

@pyqtSlot(str)
def appendToConsole(self, log):
    self.consoleWidgetBrowser.moveCursor(QTextCursor.End)
    self.consoleWidgetBrowser.insertPlainText(log)
    self.consoleWidgetBrowser.moveCursor(QTextCursor.End)
&lt;/pre&gt;

&lt;h2&gt;顏色預覽&lt;/h2&gt;
&lt;p&gt;在 graphics.color 檔案中新增了新的字典，可以回傳一個 20x20 對應顏色的 QIcon 方塊，用於預覽正確顯示的色調。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def colorIcons():
    colors = colorlist()
    for name, color in colors.items():
        colorBlock = QPixmap(QSize(*([20]*2)))
        colorBlock.fill(color)
        colors.update({name:QIcon(colorBlock)})
    return colors
&lt;/pre&gt;

&lt;p&gt;在 Windows 顯示的效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0506_02.png" /&gt;&lt;/p&gt;
&lt;h2&gt;載入後資訊提示&lt;/h2&gt;
&lt;p&gt;由於演算法的解因為技術問題，先不做復原重作的選項。&lt;/p&gt;
&lt;p&gt;檔案資訊對話方塊會顯示演算法的解。&lt;/p&gt;
&lt;p&gt;另外以往錯誤訊息顯示在 log 裡，現在首次載入完畢後會顯示檔案狀態（之後編輯將不再顯示錯誤資訊）。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0506_03.png" /&gt;&lt;/p&gt;
&lt;h2&gt;XML 支援滑鼠拖入開啟&lt;/h2&gt;
&lt;p&gt;將過濾器增加 xml 的格式。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0506_04.png" /&gt;&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/05/05</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060505.html" rel="alternate"></link><published>2017-05-05T21:00:00+08:00</published><updated>2017-05-05T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-05-05:blog/40323230ri-zhi-1060505.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;XML 格式與演算法設定&lt;/li&gt;
&lt;li&gt;QChart 調整&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;XML 格式與演算法設定&lt;/h2&gt;
&lt;p&gt;修正之前測試不完全的分支清單，可以加入演算法的解（包含其設定）。&lt;/p&gt;
&lt;p&gt;新增與刪除結果也支援復原重做功能了。&lt;/p&gt;
&lt;p&gt;讀入檔案的演算法結果後，可以複製其設定來修改。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0505_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;設定中增加控制代數和回傳收斂百分比，並有重設為預設值的按鈕。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0505_03.png" /&gt;&lt;/p&gt;
&lt;h2&gt;QChart 調整&lt;/h2&gt;
&lt;p&gt;補強圖表的顯示方式，盡量讓不同子代和回傳數能在同個圖表有更完整的呈現方式。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0505_02.png" /&gt;&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/05/01</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060501.html" rel="alternate"></link><published>2017-05-01T21:00:00+08:00</published><updated>2017-05-01T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-05-01:blog/40323230ri-zhi-1060501.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;關於 Windows 平台的測試&lt;/li&gt;
&lt;li&gt;XML 格式 - &lt;strong&gt;計畫中&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;統整發展史&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;關於 Windows 平台的測試&lt;/h2&gt;
&lt;p&gt;目前在 Python 3.6.1（&lt;a href="https://www.python.org/downloads/"&gt;python.org&lt;/a&gt; 安裝版）、Qt 5.8.0、PyQt 5.8.2 進行 Windows 版的開發。&lt;/p&gt;
&lt;p&gt;上次修改合併模式後就沒遇到演算法閃退的錯誤，編譯執行檔後也沒遇到。&lt;/p&gt;
&lt;p&gt;目前遇到比較奇怪的問題是如果不更改演算法設定，直接再重跑一次，Windows 版&lt;strong&gt;會產生相同的結果&lt;/strong&gt;（連收斂方式都一樣），不知道是不是用 Visual Studio 的關係。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0501_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;上述問題在 Ubuntu 平台沒有遇到。&lt;/p&gt;
&lt;h2&gt;XML 格式&lt;/h2&gt;
&lt;p&gt;csv 在範例修改和識別上較困難，讀取方式較沒系統，因此最近應該會開發 XML 格式，首要新增的內容就是演算法參數和結果的紀錄。&lt;/p&gt;
&lt;h2&gt;統整發展史&lt;/h2&gt;
&lt;p&gt;這禮拜發表試著將 Pyslvs 近 10 個月來的演進歷程做成簡報（參考自網誌與 Github 紀錄），並簡要歸納使用技術、數學公式。&lt;/p&gt;
&lt;p&gt;較明確的時間點如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;編譯 Solvespace 對 Python API 成功，並成功用 matplotlib 繪製第一張四連桿的端點路徑。（2016 年 8 月中）&lt;/li&gt;
&lt;li&gt;PyQt 介面計畫開始。（2016 年 8 月底）&lt;/li&gt;
&lt;li&gt;第一個 Release 版本 v0.1。（2016 年 9 月 27 日）&lt;/li&gt;
&lt;li&gt;第四版 v0.4 加入了路徑解題的尺寸合成演算法系統。（2017 年 1 月 31 日）&lt;/li&gt;
&lt;li&gt;第五版 v0.5 加入了滑塊和參數系統、復原重做功能、DXF 與 slvs 格式的匯出功能。（2017 年 3 月 4 日）&lt;/li&gt;
&lt;li&gt;第六版 v0.6 開始進行大量錯誤修正與介面改善，並加入三角求解器。（2017 年 3 月 23 日~ 2017 年 4 月 29 日）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;近來開發的 v0.7 版會針對檔案格式和演算法做改善。&lt;/p&gt;
&lt;p&gt;使用技術：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SWIG：較熟悉 C 語言的開發者可以使用該套件製作 C 語言對高階語言的端口，以製作成程式庫利用。&lt;/li&gt;
&lt;li&gt;Cython：較熟悉 Python 語言的開發者可以使用該套件利用與 Python 相仿的語法製作 C++ 的程式庫，增加執行效率。&lt;/li&gt;
&lt;li&gt;Qt：使用 C++ 語言構成的圖形化介面框架，可以用模組化的形式快速設計圖形化程式，免費授權採用 GPL 3.0。&lt;/li&gt;
&lt;li&gt;PyQt：用 Python 搭接 Qt C++ API 做成的 Python API，能輕鬆使用 Python 調用 Qt 的功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;數學公式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三角形座標公式&lt;/li&gt;
&lt;li&gt;滑塊座標公式&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/04/30</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060430.html" rel="alternate"></link><published>2017-04-30T21:00:00+08:00</published><updated>2017-04-30T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-04-30:blog/40323230ri-zhi-1060430.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;移除點外觀設定&lt;/li&gt;
&lt;li&gt;驅動面板置頂&lt;/li&gt;
&lt;li&gt;關於 Solvespace kernel 的角度約束&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;移除點外觀設定&lt;/h2&gt;
&lt;p&gt;將點外觀繁瑣的相關設定都移除了，有修改檔案格式，只保留顏色設定。&lt;/p&gt;
&lt;p&gt;並且透過編輯點來套用設定。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0430_01.png" /&gt;&lt;/p&gt;
&lt;h2&gt;驅動面板至頂&lt;/h2&gt;
&lt;p&gt;將驅動面板置頂方便呼叫。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0430_02.png" /&gt;&lt;/p&gt;
&lt;h2&gt;關於 Solvespace kernel 的角度約束&lt;/h2&gt;
&lt;p&gt;角度約束再直接使用 kernel 時，常會發生旋轉不如預期的狀況。&lt;/p&gt;
&lt;p&gt;如圖在做路徑模擬時，在第 2 象限中途會發生反轉的現象。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0430_03.png" /&gt;&lt;/p&gt;
&lt;p&gt;在 Solvespace 中使用滑鼠拖曳或角度約束下值時都不會發生上述狀況。&lt;/p&gt;
&lt;p&gt;CDemo 的說明如下：&lt;/p&gt;
&lt;pre&gt;
SLVS_C_ANGLE*

    The angle between lines entityA and entityB is equal to valA, where
    valA is specified in degrees. This constraint equation is written
    in the form

        (A dot B)/(|A||B|) = cos(valA)

    where A and B are vectors in the directions of lines A and B. This
    equation does not specify the angle unambiguously; for example,
    note that valA = +/- 90 degrees will produce the same equation.

    If other is true, then the constraint is instead that

        (A dot B)/(|A||B|) = -cos(valA)
&lt;/pre&gt;

&lt;p&gt;這個函式使用 bool 調控 cos 的正負值，但是無論是否調整，若是沒有更新基礎座標，結果仍然不會改變。&lt;/p&gt;
&lt;p&gt;之後會針對這個問題盡快找到 Solvespace 另外在內部的解決辦法，並用 Python 模仿傳值給 kernel，應能盡快修正問題。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/04/29</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060429.html" rel="alternate"></link><published>2017-04-29T21:00:00+08:00</published><updated>2017-04-29T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-04-29:blog/40323230ri-zhi-1060429.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三角求解器的失敗解&lt;/li&gt;
&lt;li&gt;演算法收斂圖&lt;/li&gt;
&lt;li&gt;往後更新模式&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;三角求解器的失敗解&lt;/h2&gt;
&lt;p&gt;因為剛開始帶入 0 度角，若演算法產生的機構在 0 度角時為解決失敗的狀況，就會造成錯誤。&lt;/p&gt;
&lt;p&gt;或許其他行程有符合路徑，使用迴圈檢查機構正確性。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
answer = [False]
angle = -10.
#從 0 度開始，每 10 度進行一次約束正確性判斷
while False in answer:
    angle += 10.
    #若已經查全部行程，跳出迴圈
    if angle&gt;=360.: break
    s = solver([
        Direction(p1=(Result['Ax'], Result['Ay']), p2=(Result['Dx'], Result['Dy']), len1=Result['L0'], angle=angle, other=other), #B
        Direction(p1=0, p2=(Result['Dx'], Result['Dy']), len1=Result['L1'], len2=Result['L2'], other=other), #C
        Direction(p1=0, p2=1, len1=Result['L3'], len2=Result['L4'], other=other)]) #E
    answer = [(Result['Ax'], Result['Ay']), (Result['Dx'], Result['Dy'])]+s.answer()
if not (False in answer):
    #有（至少部份的）正常行程
    '''合併進畫布'''
else:
    #機構尺寸完全不正確
    '''跳出視窗警告'''
&lt;/pre&gt;

&lt;p&gt;生成時也是使用迴圈測試後合格的角度代入。&lt;/p&gt;
&lt;p&gt;目前反覆測試後在 Windows 平台還未遇到問題。&lt;/p&gt;
&lt;h2&gt;演算法收斂圖&lt;/h2&gt;
&lt;p&gt;已移除 matplotlib 改用 PyQtChart，解決包裝過於肥大的問題。&lt;/p&gt;
&lt;p&gt;測試並做了修正，可以一次比對當前演算結果的收斂速度。&lt;/p&gt;
&lt;p&gt;以下是 3 種演算法的比對：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0429_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;移除 Firefly 後的呈現結果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0429_02.png" /&gt;&lt;/p&gt;
&lt;h2&gt;往後更新模式&lt;/h2&gt;
&lt;p&gt;現在移轉到 Fossil 倉儲進行開發，而 Git 倉儲會暫時停止更新。&lt;/p&gt;
&lt;p&gt;移轉前已釋出 0.6.5 版（Windows 改採用 NSIS 3.01 作為 installer），之後會在 Fossil 倉儲開發，釋出之後的 0.6 版更新或是 0.7 版。&lt;/p&gt;
&lt;p&gt;只有在版本更新時才會 update 到 Github 進行 release。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/04/27</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060427.html" rel="alternate"></link><published>2017-04-27T21:00:00+08:00</published><updated>2017-04-27T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-04-27:blog/40323230ri-zhi-1060427.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;演算法收斂圖&lt;/li&gt;
&lt;li&gt;三角求解器的失敗解&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;演算法收斂圖&lt;/h2&gt;
&lt;p&gt;加入 matplotlib 繪出的收斂圖。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0427_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;其中因為用到了 matplotlib 的檔案，導致 Ubuntu 的 PyInstaller 會包到整個 Python 模組，甚至比 Windows 版大更多，考慮把 matplotlib 換成其他方式呈現，或是其他減少體積的解決辦法。&lt;/p&gt;
&lt;p&gt;目前首選應該是同為 Qt 附屬的 QChart，對應到套件 &lt;a href="https://www.riverbankcomputing.com/software/pyqtchart/download/" title="riverbankcomputing.com"&gt;PyQtChart 5.8&lt;/a&gt;，安裝這個 Python 的 bundle 後即可使用，雙平台皆可安裝（Linux 版仍要手動 build），體積相對不會太大，能製作更美觀的圖表。&lt;/p&gt;
&lt;p&gt;由於之後速度分析也要使用圖表，所以解決繪圖問題為當務之急。&lt;/p&gt;
&lt;p&gt;另外可能得改進 Path solving 面板空間需求的問題。&lt;/p&gt;
&lt;h1&gt;三角求解器的失敗解&lt;/h1&gt;
&lt;p&gt;有時會發生演算法回傳尺寸使三角求解器出錯，暫時先加上警告，之後會查看原因。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/04/26</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060426.html" rel="alternate"></link><published>2017-04-26T21:00:00+08:00</published><updated>2017-04-26T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-04-26:blog/40323230ri-zhi-1060426.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三角求解器格式&lt;/li&gt;
&lt;li&gt;偵測合併功能&lt;/li&gt;
&lt;li&gt;加入四連桿步幅範例&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;三角求解器格式&lt;/h2&gt;
&lt;p&gt;如上次更新的資料格式，求解器改用 class Direction 取代 dict 儲存資料。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
class Direction:
    ITEM = ['merge', 'p1', 'p2', 'p3', 'len1', 'len2', 'angle', 'other']
    def __init__(self, **Args):
        if not Args.get('Type', False) is False:
            self._type = Args['Type']
            del Args['Type']
        self.__dict__.update(Args)
    @property
    def Type(self): return self._type
    @Type.setter
    def Type(self, Type): self._type = Type

    def set(self, name, value):
        if name in self.ITEM: self.__dict__.update({name:value})
    def get(self, name, elseObject=None): return getattr(self, name) if hasattr(self, name) else elseObject
    def items(self): return {t:getattr(self, t) for t in self.ITEM if hasattr(self, t)}

    def __str__(self): return "{}".format(self.items())
&lt;/pre&gt;

&lt;p&gt;建立方法如下：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Direction(p1=(-60, 0), p2=(0, 0), len1=30, angle=50)
&lt;/pre&gt;

&lt;p&gt;相關視窗處理皆測試完畢。&lt;/p&gt;
&lt;h2&gt;偵測合併功能&lt;/h2&gt;
&lt;p&gt;連桿與呆鍊的自動合併功能已開發完畢，預設啟用該選項。&lt;/p&gt;
&lt;p&gt;新增或修改實體時會移除共用 2 點（連桿對連桿、連桿對呆鍊）或是共用 3 點（呆鍊對呆鍊）的實體。&lt;/p&gt;
&lt;h2&gt;加入四連桿步幅範例&lt;/h2&gt;
&lt;p&gt;新增以下範例：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0426_01.png" /&gt;&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/04/24</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060424.html" rel="alternate"></link><published>2017-04-24T21:00:00+08:00</published><updated>2017-04-24T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-04-24:blog/40323230ri-zhi-1060424.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;呆鍊偵測合併功能&lt;/li&gt;
&lt;li&gt;設立儲存用資料格式&lt;/li&gt;
&lt;li&gt;GUI 讀取偵錯輸出&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;呆鍊偵測合併功能&lt;/h2&gt;
&lt;p&gt;當建立呆鍊時，預設會啟用移除重複連桿的選項。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0424_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;此選項會在建立呆鍊前自動移除衝突的連桿，並且能良好配合 Undo Redo 功能。&lt;/p&gt;
&lt;p&gt;如果效果不錯，可以延用到建立連桿，自動將衝突項目解決。&lt;/p&gt;
&lt;h2&gt;設立儲存用資料格式&lt;/h2&gt;
&lt;p&gt;新的資料存取方式是為了取代 Python 的 dict，用自訂的 class 處理座標和約束儲存的工作。&lt;/p&gt;
&lt;p&gt;使用 decorator 的 &lt;code&gt;@property&lt;/code&gt; 防止錯誤的資料寫入。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
class VPoint:
    def __init__(self, x=0., y=0., fix=False):
        self.set(x, y, fix)
        self._cx = self._x
        self._cy = self._y
    @property
    def x(self): return self._x
    @property
    def y(self): return self._y
    @x.setter
    def x(self, x): self._x = x
    @y.setter
    def y(self, y): self._y = y
    @property
    def fix(self): return self._fix
    @property
    def cx(self): return self._cx
    @property
    def cy(self): return self._cy

    def set(self, x=0., y=0., fix=False):
        self._x = x
        self._y = y
        self._fix = fix

    def move(self, x=0., y=0.):
        self._cx = x
        self._cy = y

    def reset(self):
        self._x = self._cx
        self._y = self._cy

    def __str__(self): return "Point x={v.x} y={v.y} fix={v.fix} cx={v.cx} cy={v.cy}".format(v=self)

class VLine:
    def __init__(self, start=0, end=0, len=0.): self.set(start, end, len)
    @property
    def start(self): return self._start
    @property
    def end(self): return self._end
    @property
    def len(self): return self._len

    def set(self, start=VPoint(), end=VPoint(), len=0.):
        self._start = start
        self._end = end
        self._len = len

    def __contains__(self, point): return point==self._start or point==self._end
    def __str__(self): return "Line start={v.start} end={v.end} len={v.len}".format(v=self)

class VChain:
    def __init__(self, p1=VPoint(), p2=0, p3=0, p1p2=0., p2p3=0., p1p3=0.): self.set(p1, p2, p3, p1p2, p2p3, p1p3)
    @property
    def p1(self): return self._p1
    @property
    def p2(self): return self._p2
    @property
    def p3(self): return self._p3
    @property
    def p1p2(self): return self._p1p2
    @property
    def p2p3(self): return self._p2p3
    @property
    def p1p3(self): return self._p1p3

    def set(self, p1=0, p2=0, p3=0, p1p2=0., p2p3=0., p1p3=0.):
        self._p1 = p1
        self._p2 = p2
        self._p3 = p3
        self._p1p2 = p1p2
        self._p2p3 = p2p3
        self._p1p3 = p1p3

    def __contains__(self, point): return point==self._p1 or point==self._p2 or point==self._p3
    def __str__(self):
        return "Chain p1={v.p1} p2={v.p2} p3={v.p3} p1p2={v.p1p2} p2p3={v.p2p3} p1p3={v.p1p3}".format(v=self)

class VShaft:
    def __init__(self, cen=0, ref=0, start=0., end=360., demo=0., isParallelogram=False): self.set(cen, ref, start, end, demo, isParallelogram)
    @property
    def cen(self): return self._cen
    @property
    def ref(self): return self._ref
    @property
    def start(self): return self._start
    @property
    def end(self): return self._end
    @property
    def demo(self): return self._demo
    @demo.setter
    def demo(self, demo): self._demo = demo
    @property
    def isParallelogram(self): return self._isParallelogram

    def set(self, cen=0, ref=0, start=0., end=360., demo=0., isParallelogram=False):
        self._cen = cen
        self._ref = ref
        self._start = start
        self._end = end
        self._demo = demo
        self._isParallelogram = isParallelogram

    def drive(self, demo):
        if demo&gt;self._start and self._end&gt;demo: self._demo = demo

    def __contains__(self, point): return point==self._cen or point==self._ref
    def __str__(self):
        return "Shaft cen={v.cen} ref={v.ref} start={v.start}, end={v.end} demo={v.demo} isParallelogram={v.isParallelogram}".format(v=self)

class VSlider:
    def __init___(self, cen=0, start=0, end=0): self.set(cen, start, end)
    @property
    def cen(self): return self._cen
    @property
    def start(self): return self._start
    @property
    def end(self): return self._end

    def set(self, cen=0, start=0, end=0):
        self._cen = cen
        self._start = start
        self._end = end

    def __contains__(self, point): return point==self._cen or point==self._start or point==self._end
    def __str__(self):
        return "Slider cen={v.cen} start={v.start} end={v.end}".format(v=self)

class VRod(VSlider):
    def __init__(self, cen=0, start=0, end=0, pos=0.): self.set(cen, start, end, pos)
    @property
    def pos(self): return self._pos

    def set(self, cen=0, start=0, end=0, pos=0.):
        super(VRod, self).set(cen, start, end)
        self._pos = pos

    def __str__(self):
        return "Rod cen={v.cen} start={v.start} end={v.end} pos={v.pos}".format(v=self)
&lt;/pre&gt;

&lt;h2&gt;GUI 讀取偵錯輸出&lt;/h2&gt;
&lt;p&gt;在選項中可以偵測並開啟 &lt;code&gt;PyslvsLogFile.log&lt;/code&gt; 日誌檔案，並且將寫入方式改為 append，不會清除之前的紀錄。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0424_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;點選後可以開啟內容，若沒有檔案則會跳出提示。&lt;/p&gt;
&lt;p&gt;由尾端開始，最多顯示 1000 個字元。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0424_03.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;PMKS&lt;/p&gt;
&lt;p&gt;最近在讀 PMKS 符號式的部份，不過對照 C# 原始碼只能稍微理解大概，之後也需要釐清其中數學式的運算方法。&lt;/p&gt;
&lt;p&gt;其中的程式有整個模組可以計算牛頓力學的部份（包含輸出圖表），不過礙於不太能理解 C#，只能用 Visual Studio 慢慢找到需要的功能，不像 C++ 能快速理解其功能或註釋。&lt;/p&gt;
&lt;p&gt;這部份期望的是可以得到&lt;strong&gt;即時運算出路徑的能力&lt;/strong&gt;、&lt;strong&gt;以 GUI 套用 PMKS 改善部份網頁執行的不便&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Solvespace kernel&lt;/p&gt;
&lt;p&gt;今天重新看了一下舊的 Solvespace 原始碼，基礎系統 System 類型中並沒有移除實體或約束的功能，每次更改都需要重新計算，是滿可惜的地方，而且處理方面不像 PMKS 有效率，可能之後會將後者作為處理 calculation 的 kernel。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;演算法&lt;/p&gt;
&lt;p&gt;連接的原始碼倉儲已更新四連桿的 py 檔，如果可以六連桿的部份應該能放在一起。&lt;/p&gt;
&lt;p&gt;不過當前的 Cython kernel 沒有回傳運算進度的功能（如大廠分析軟體的方式顯示&lt;strong&gt;發散&lt;/strong&gt;和&lt;strong&gt;收斂&lt;/strong&gt;進度），雖然可能會造成執行效率降低。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程式&lt;/p&gt;
&lt;p&gt;會找個時間教一下學弟計算機概論和物件導向程式的部份（C++ 和 Python），盡量讓&lt;strong&gt;需要程式處理的組員&lt;/strong&gt;能夠連接 Python API 和讓 2、3 人以上有看懂 C++ 的能力。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Python Operator</title><link href="http://project.mde.tw/blog/python-operator.html" rel="alternate"></link><published>2017-04-22T21:00:00+08:00</published><updated>2017-04-22T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-04-22:blog/python-operator.html</id><summary type="html">&lt;p&gt;Python 運算子的自訂&lt;/p&gt;


&lt;h1&gt;Python Operator&lt;/h1&gt;
&lt;p&gt;參考資料：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.python.org/3/library/operator.html"&gt;https://docs.python.org/3/library/operator.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在 object 中，使用 Operator functions 可以定義或重新定義使用運算子的行為。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
class A:
    def __init__(self):
        self.c = 10
    def __add__(self, b): return self.c+b

a = A()
print(a+20)
#回傳 30
&lt;/pre&gt;

&lt;p&gt;因此可應用為：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
class Point:
    def __init__(self, x=0., y=0.):
        self.x = x
        self.y = y
    def __add__(self, b): return Point(self.x+b.x, self.y+b.y)
&lt;/pre&gt;

&lt;p&gt;兩點相加即為兩者 x 與 y 座標總和。&lt;/p&gt;
&lt;p&gt;一些可迭代物件的運算子對應如下：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def __add__(a, b): return a+b
def __sub__(a, b): return a-b
def __mul__(a, b): return a*b
def __truediv__(a, b): return a/b
def __mod__(a, b): return a%b
def __pow__(a, b): return a**b
def __invert__(obj): return ~obj
def __pos__(obj): return +obj
def __neg__(obj): return -obj
def __eq__(a, b): return a==b
def __ne__(a, b): return a!=b
def __contains__(a, b): return a in b
def __getitem__(a, b): return a[b]
&lt;/pre&gt;</summary><category term="Python3"></category></entry><entry><title>40323230日誌 - 106/04/21</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060421.html" rel="alternate"></link><published>2017-04-21T21:00:00+08:00</published><updated>2017-04-21T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-04-21:blog/40323230ri-zhi-1060421.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;偵錯輸出&lt;/li&gt;
&lt;li&gt;編譯自動偵測版本&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;偵錯輸出&lt;/h2&gt;
&lt;p&gt;由於編譯成執行檔後遇到錯誤會直接閃退，沒辦法在背後的 command line 留下錯誤紀錄，因此使用 Python 的 logging 模組功能，紀錄錯誤的訊息到 &lt;code&gt;PyslvsLogFile.log&lt;/code&gt; 中，與執行檔同目錄。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0421_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;程式碼如下：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
if e!=SystemExit:
    import logging
    logging.basicConfig(filename='PyslvsLogFile.log', filemode='w',
        format='%(asctime)s | %(message)s', level=logging.INFO)
    logging.exception("Exception Happened.")
    print('{}\n{}'.format(type(e), e))
    exit(1)
&lt;/pre&gt;

&lt;p&gt;舊有的紀錄檔會被複寫。&lt;/p&gt;
&lt;h2&gt;編譯自動偵測版本&lt;/h2&gt;
&lt;p&gt;使用 Makefile 的 shell 指令呼叫作業系統的 Python3，並回傳版本和平台資訊。&lt;/p&gt;
&lt;p&gt;要暫時在 target 中設定變數，可以使用 &lt;strong&gt;eval&lt;/strong&gt; 指令達成。&lt;/p&gt;
&lt;p&gt;使用 Eric 寫 code 時是使用 &lt;code&gt;kernel_getter.py&lt;/code&gt; 的 if 語句匯入 kernel，不過會造成 PyInstaller 包裝掩蓋函式庫名稱的問題。此問題只發生在 Ubuntu，最近才發現 PyInstaller 匯入任何「可能性」函式庫時會發生撞名問題，之前 Python 3.4 就是因為加入 3.5 的 kernel 後才發生無法編譯的情形。&lt;/p&gt;
&lt;p&gt;針對此方法採用 Makefile 自動修改檔名的方式解決。&lt;/p&gt;
&lt;p&gt;編譯時先將 py35.py 等檔案挑出相符的版本，改成 &lt;code&gt;kernel_getter.py&lt;/code&gt; 後就會單獨 import 對應版本的 kernel。&lt;/p&gt;
&lt;p&gt;以下是自動套用 Python 版號後的編譯流程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;project_site 已新增 Makefile script 的 brush&lt;/strong&gt;，來源：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://p--q.blogspot.tw/2015/05/linuxbean140423makefilesyntaxhighlighte.html"&gt;https://p--q.blogspot.tw/2015/05/linuxbean140423makefilesyntaxhighlighte.html&lt;/a&gt;&lt;/p&gt;
&lt;pre class="brush: Makefile"&gt;
build: launch_pyslvs.py
    @echo ---Pyslvs Build---
    @echo ---$(OS) Version---
ifeq ($(OS),Windows_NT)
    $(eval PYTHON = py$(shell python -c "import sys, platform;t='{v[0]}{v[1]}'.format(v=list(sys.version_info[:2]))+('w' if platform.system().lower()=='windows' else '');sys.stdout.write(t)"))
    @echo --Python Version $(PYTHON)--
    rename .\core\kernel\kernel_getter.py _kernel_getter.py
    rename .\core\kernel\$(PYTHON).py kernel_getter.py
    pyinstaller $&lt; -i ./icons/main_big.ico
    python setup.py build
    @echo ---Copying Folder and Files---
    $(eval PYTHOND = $(shell python -c "import sys, platform;t='{v[0]}.{v[1]}'.format(v=list(sys.version_info[:2]));sys.stdout.write(t)"))
    xcopy .\build\exe.win-amd64-$(PYTHOND)\core\kernel\$(PYTHON) .\dist\launch_pyslvs\core\kernel\$(PYTHON) /s /y /i
    xcopy .\build\exe.win-amd64-$(PYTHOND)\core\kernel\pyslvs_generate\$(PYTHON) .\dist\launch_pyslvs\core\kernel\pyslvs_generate\$(PYTHON) /s /y /i
    rename .\dist\launch_pyslvs Pyslvs
    rename .\core\kernel\kernel_getter.py $(PYTHON).py
    rename .\core\kernel\_kernel_getter.py kernel_getter.py
else
    $(eval PYTHON = py$(shell python3 -c "import sys, platform;t='{v[0]}{v[1]}'.format(v=list(sys.version_info[:2]))+('w' if platform.system().lower()=='windows' else '');sys.stdout.write(t)"))
    @echo --Python Version $(PYTHON)--
    mv core/kernel/kernel_getter.py core/kernel/_kernel_getter.py
    mv core/kernel/$(PYTHON).py core/kernel/kernel_getter.py
    pyinstaller $&lt;
    mv dist/launch_pyslvs dist/Pyslvs
    mv core/kernel/kernel_getter.py core/kernel/$(PYTHON).py
    mv core/kernel/_kernel_getter.py core/kernel/kernel_getter.py
endif
    @echo ---Done---
&lt;/pre&gt;

&lt;p&gt;上面的 Makefile 已成功在雙平台測試無誤。&lt;/p&gt;
&lt;p&gt;而效果也能應用到製作 Debian Package 的版號對應。&lt;/p&gt;
&lt;pre class="brush: Makefile"&gt;
DEBIANCONTROL = dist/temp/DEBIAN/control

deb: build dist/Pyslvs
ifeq ($(OS),Windows_NT)
    @echo ---Ubuntu only---
else
    mkdir dist/temp dist/temp/DEBIAN dist/temp/usr/ dist/temp/usr/bin dist/temp/usr/share/
    touch $(DEBIANCONTROL)
    echo 'Package: pyslvs' &gt;&gt; $(DEBIANCONTROL)
    $(eval PYSLVS = "Version: $(shell python3 -c "import sys;from core.info.info import VERSION;sys.stdout.write(VERSION[0])")")
    echo $(PYSLVS) &gt;&gt; $(DEBIANCONTROL)
    echo 'Architecture: all' &gt;&gt; $(DEBIANCONTROL)
    echo 'Description: Dimensional Synthesis of Planar Four-bar Linkages in PyQt5 GUI.' &gt;&gt; $(DEBIANCONTROL)
    echo 'Maintainer: Yuan Chang daan0014119@gmail.com' &gt;&gt; $(DEBIANCONTROL)
    mv dist/Pyslvs dist/temp/usr/share/
    ln -s /usr/share/Pyslvs/launch_pyslvs dist/temp/usr/bin/pyslvs
    mv dist/temp dist/Pyslvs
    dpkg -b dist/Pyslvs
endif
&lt;/pre&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Pyslvs v0.6 完整編譯流程</title><link href="http://project.mde.tw/blog/pyslvs-v06-wan-zheng-bian-yi-liu-cheng.html" rel="alternate"></link><published>2017-04-12T21:00:00+08:00</published><updated>2017-04-12T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-04-12:blog/pyslvs-v06-wan-zheng-bian-yi-liu-cheng.html</id><summary type="html">&lt;p&gt;Pyslvs v0.6 在兩個平台的編譯流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;環境與安裝套件&lt;ul&gt;
&lt;li&gt;Git&lt;/li&gt;
&lt;li&gt;Cython&lt;/li&gt;
&lt;li&gt;Windows 編譯工具&lt;/li&gt;
&lt;li&gt;SWIG&lt;/li&gt;
&lt;li&gt;PyQt&lt;/li&gt;
&lt;li&gt;Eric IDE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;編譯步驟&lt;ul&gt;
&lt;li&gt;演算法函式庫&lt;/li&gt;
&lt;li&gt;Solvespace 函式庫&lt;/li&gt;
&lt;li&gt;Pyslvs&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs v0.6 完整編譯流程&lt;/h1&gt;
&lt;p&gt;這裡說明 Pyslvs v0.6 在兩個平台的編譯流程，目標是從，若是單一平台的步驟會特別標示。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ubuntu 採用 Ubuntu 16.04 (64 Bit) Python 3.5 做示範。&lt;/li&gt;
&lt;li&gt;Windows 採用 Windows 8 (Build 9600 64 Bit) Python 3.6.1 做示範。&lt;/li&gt;
&lt;li&gt;Qt 與 PyQt 皆為 5.8.0。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前 Windows 的 PyQt 5.8 沒有支援 Anaconda，可能得日後更新才會解決問題。&lt;/p&gt;
&lt;p&gt;而且使用一般的 Python 編譯，Pyslvs 的體積可以減少很多（377MB &amp;gt; 88MB）&lt;/p&gt;
&lt;p&gt;以下是自行編譯分部程式庫與主程式可執行檔&lt;/p&gt;
&lt;h1&gt;環境與安裝套件&lt;/h1&gt;
&lt;p&gt;本篇介紹需要使用的工具與其安裝方法。&lt;/p&gt;
&lt;h2&gt;Git&lt;/h2&gt;
&lt;p&gt;進行遠端檔案版本控制的工具。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Ubuntu&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 apt 安裝。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$sudo apt install git&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Windows&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下載新版 Git。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://git-scm.com/download/win"&gt;https://git-scm.com/download/win&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Cython&lt;/h2&gt;
&lt;p&gt;將 Python 語言轉換成 C++ 以增進運算速度的套件。&lt;/p&gt;
&lt;p&gt;使用 pip 安裝 Cython。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$sudo pip3 install cython&lt;/p&gt;
&lt;p&gt;&gt;pip install cython&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Windows 編譯工具&lt;/h2&gt;
&lt;p&gt;使用 Windows 的必須安裝 GNU 工具包以使用 Make 功能。&lt;/p&gt;
&lt;p&gt;下載新版 MinGW（32 Bit）：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://sourceforge.net/projects/mingw-w64/files/latest/download?source=files"&gt;https://sourceforge.net/projects/mingw-w64/files/latest/download?source=files&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另外必須安裝 Microsoft Visual Studio 以編譯 64 位元的 Cython 程式碼。&lt;/p&gt;
&lt;p&gt;只需要安裝 Windows tool kit 就好。Python&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.visualstudio.com/downloads/"&gt;https://www.visualstudio.com/downloads/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;SWIG&lt;/h2&gt;
&lt;p&gt;將 C 或 C++ 配上自訂接口後，可以變成其他高階語言函式庫的套件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Ubuntu&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 apt 安裝。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$sudo apt install swig&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Windows&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下載新版 SWIG：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.swig.org/download.html"&gt;http://www.swig.org/download.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解壓縮到安裝位置，並將該資料夾加入環境變數。&lt;/p&gt;
&lt;p&gt;例如：&lt;code&gt;C:\swigwin-3.0.12&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;PyQt&lt;/h2&gt;
&lt;p&gt;由官方網站下載 Qt 的安裝檔：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.qt.io/download/"&gt;https://www.qt.io/download/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;選擇 PyQt 有對應的最新版本，否則會無法對應 API。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Ubuntu&lt;/strong&gt; 安裝後請將 Qt 函式庫位址加入 &lt;code&gt;~/.bashrc&lt;/code&gt; 環境變數。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;export QTDIR=/opt/Qt/5.8/gcc_64/&lt;/p&gt;
&lt;p&gt;export LD_LIBRARY_PATH=&lt;span QTDIR="QTDIR" class="math"&gt;\({LD_LIBRARY_PATH}:\)&lt;/span&gt;/lib/&lt;/p&gt;
&lt;p&gt;export PATH=&lt;span PATH="PATH" class="math"&gt;\({QTDIR}/bin:\)&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Windows&lt;/strong&gt; 安裝後請將 Qt 函式庫位址加入環境變數。&lt;/p&gt;
&lt;p&gt;例如：&lt;code&gt;C:\Qt\5.8\msvc2015_64\bin&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下來安裝 PyQt。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;Ubuntu&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;需先更新 SIP，這個部分無法用 pip 操作。&lt;/p&gt;
&lt;p&gt;確認並刪除 Python 套件安裝位置的 SIP 檔案，例如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$sudo rm -f /usr/lib/python3/dist-packages/sip*&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下載新版 SIP：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://riverbankcomputing.com/software/sip/download"&gt;https://riverbankcomputing.com/software/sip/download&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解壓縮後安裝：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$python3 configure.py&lt;/p&gt;
&lt;p&gt;$sudo make install&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;核對與 Python 內的版本：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$sip -V&lt;/p&gt;
&lt;p&gt;&gt;&amp;gt;import sip&lt;/p&gt;
&lt;p&gt;&gt;&amp;gt;print(sip.SIP_VERSION_STR)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下載新版 PyQt5：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://riverbankcomputing.com/software/pyqt/download5"&gt;https://riverbankcomputing.com/software/pyqt/download5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解壓縮後安裝：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$python3 configure.py&lt;/p&gt;
&lt;p&gt;$sudo make install&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下載新版的 QScintilla 2：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://riverbankcomputing.com/software/qscintilla/download"&gt;https://riverbankcomputing.com/software/qscintilla/download&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解壓縮後安裝 3 個部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;本體&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$cd Qt4Qt5&lt;/p&gt;
&lt;p&gt;$qmake qscintilla.pro&lt;/p&gt;
&lt;p&gt;$sudo make install&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Designer&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$cd designer-Qt4Qt5&lt;/p&gt;
&lt;p&gt;$qmake designer.pro&lt;/p&gt;
&lt;p&gt;$sudo make install&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Python bundings&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$cd Python&lt;/p&gt;
&lt;p&gt;$python3 configure.py --pyqt=PyQt5&lt;/p&gt;
&lt;p&gt;$sudo make install&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;Windows&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;使用 pip 安裝 PyQt5。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&gt;pip install pyqt5 -U&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用 pip 安裝 QScintilla 2。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&gt;pip install qscintilla&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Python 編譯工具&lt;/h2&gt;
&lt;p&gt;將 Python 程式碼編譯成可執行檔的工具。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;Ubuntu&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;使用 PyInstaller 即可。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$sudo pip3 install PyInstaller&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;&lt;strong&gt;Windows&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;使用 PyInstaller 編譯主體，再用 cxFreeze 包裝函式庫。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&gt;pip install cx_Freeze PyInstaller&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Windows 如果使用官方來源有編碼錯誤，可以用下面的倉儲：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&gt;pip install https://github.com/pyinstaller/pyinstaller/archive/develop.zip&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Eric IDE&lt;/h2&gt;
&lt;p&gt;若要進行程式協同，可以安裝這個 Python 編輯器。&lt;/p&gt;
&lt;p&gt;下載新版的 Eric IDE。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://eric-ide.python-projects.org/eric-download.html"&gt;http://eric-ide.python-projects.org/eric-download.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;執行其中的 &lt;code&gt;install.py&lt;/code&gt; 即可。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$sudo python3 install.py&lt;/p&gt;
&lt;p&gt;&gt;python install.py&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;編譯步驟&lt;/h1&gt;
&lt;p&gt;下載 Pyslvs 倉儲，並進行子倉儲更新：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;git clone https://github.com/KmolYuan/Pyslvs-PyQt5.git&lt;/p&gt;
&lt;p&gt;git submodule init&lt;/p&gt;
&lt;p&gt;git submodule update&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;安裝所需 Python 套件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;pip install -r requirements.txt&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;編譯好的函式庫複製到 &lt;code&gt;core/kernel/&lt;/code&gt; 對應的資料夾下。&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ubuntu 的 Python 3.5 命名為 &lt;code&gt;py35&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;Windows 的 Python 3.6 命名為 &lt;code&gt;py36w&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;並在 &lt;code&gt;core/calculation&lt;/code&gt;/&lt;code&gt;calculation.py&lt;/code&gt; 中加入匯入名稱。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
if py_nm=='36w':
    from ..kernel.py36w.slvs import *
    from ..kernel.pyslvs_generate.py36w import tinycadlib
    from ..kernel.pyslvs_generate.py36w.planarlinkage import build_planar
    from ..kernel.pyslvs_generate.py36w.rga import Genetic
    from ..kernel.pyslvs_generate.py36w.firefly import Firefly
    from ..kernel.pyslvs_generate.py36w.de import DiffertialEvolution
&lt;/pre&gt;

&lt;h2&gt;演算法函式庫&lt;/h2&gt;
&lt;p&gt;進入 &lt;code&gt;core/kernel/pyslvs_generate/pyslvs_generate&lt;/code&gt; 資料夾。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;make&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;將產生以下的函式庫：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;de (&lt;code&gt;so&lt;/code&gt; or &lt;code&gt;pyd&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;firefly (&lt;code&gt;so&lt;/code&gt; or &lt;code&gt;pyd&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;planarlinkage (&lt;code&gt;so&lt;/code&gt; or &lt;code&gt;pyd&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;rga (&lt;code&gt;so&lt;/code&gt; or &lt;code&gt;pyd&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;tinycadlib (&lt;code&gt;so&lt;/code&gt; or &lt;code&gt;pyd&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Solvespace 函式庫&lt;/h2&gt;
&lt;p&gt;進入 &lt;code&gt;core\kernel\python-solvespace-lite\solvespace\exposed&lt;/code&gt; 資料夾。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;python configure.py&lt;/p&gt;
&lt;p&gt;make&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;將產生以下的函式庫：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;_slvs (&lt;code&gt;so&lt;/code&gt; or &lt;code&gt;pyd&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;libslvs (&lt;code&gt;so&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;slvs.py&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Pyslvs&lt;/h2&gt;
&lt;p&gt;在倉儲頂層目錄中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;make&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;編譯成功後會跳出程式執行，結束即可。&lt;/p&gt;
&lt;p&gt;編好的執行檔位於 &lt;code&gt;dist/Pyslvs&lt;/code&gt; 中，主程式為 &lt;code&gt;launch_pyslvs&lt;/code&gt;(&lt;code&gt;exe&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;可以將程式用 Debian 包裝或壓縮發佈。&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/04/10</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060410.html" rel="alternate"></link><published>2017-04-10T21:00:00+08:00</published><updated>2017-04-10T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-04-10:blog/40323230ri-zhi-1060410.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三角形圖形改進&lt;/li&gt;
&lt;li&gt;防呆措施&lt;/li&gt;
&lt;li&gt;刪除鍵&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;三角形圖形改進&lt;/h2&gt;
&lt;p&gt;將三角迭代的預覽圖調整得更明確，非連桿或機架的部份改成了虛線。&lt;/p&gt;
&lt;p&gt;不過三角迭代器驗證的部份可能還要想想怎麼規劃。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0410_01.png" /&gt;&lt;/p&gt;
&lt;h1&gt;防呆措施&lt;/h1&gt;
&lt;p&gt;三角迭代器的防呆機制，會比對是否共點或長度為 0，以防產生非預期結果。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0410_02.png" /&gt;&lt;/p&gt;
&lt;h1&gt;刪除鍵&lt;/h1&gt;
&lt;p&gt;當選取表格後，按下 &lt;kbd&gt;Del&lt;/kbd&gt; 鍵可以跳出刪除對話方塊，並指到當前選擇的欄位。&lt;/p&gt;
&lt;p&gt;原理是切換到該表格時，會將所有表格刪除功能的 Shortcut 移除，重新設定該表格刪除功能的 Shortcut 為 &lt;kbd&gt;Del&lt;/kbd&gt; 鍵。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;由於專題報告的時間將近，找了一下學校的規定，必要的話可能得把 Pyslvs 的內容安排在第二組的專題中發表。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://sparc.nfu.edu.tw/~nfuup/rule/download/13.pdf"&gt;http://sparc.nfu.edu.tw/~nfuup/rule/download/13.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;雖然人數都寫為原則，但是系上似乎沒有事後更動組別的辦法。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/04/09</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060409.html" rel="alternate"></link><published>2017-04-09T21:00:00+08:00</published><updated>2017-04-09T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-04-09:blog/40323230ri-zhi-1060409.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三角迭代器的模板&lt;/li&gt;
&lt;li&gt;連續路徑&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;三角迭代器的模板&lt;/h2&gt;
&lt;p&gt;使用三角迭代器的 template 功能可以快速建立多連桿拼裝的實體。&lt;/p&gt;
&lt;p&gt;以下介紹加入四連桿組的流程。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;加入點&lt;/p&gt;
&lt;p&gt;按住 &lt;kbd&gt;Alt&lt;/kbd&gt; + 雙擊滑鼠左鍵快速在畫布上加入 4 個普通節點。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0409_01.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;開啟 template 對話方塊&lt;/p&gt;
&lt;p&gt;點擊「4-bar linkage」按鈕開啟四連桿設定。&lt;/p&gt;
&lt;p&gt;這個視窗中，滑鼠點擊上方三角形的表格，會在下圖顯示出三角形的切割方式供使用者比對；點擊右側的參數表則會隱藏三角形的顯示。&lt;/p&gt;
&lt;p&gt;而點的順序也代表一般解題的求解順序。&lt;/p&gt;
&lt;p&gt;並在參數表中設定對應點，若是其中有重複會無法按下確定鈕。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0409_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;下圖則是 8 連桿的設定。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0409_03.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;計算並合併&lt;/p&gt;
&lt;p&gt;按下求解器的 Solve 鈕求出連桿組邊長，接著合併至畫布中。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0409_04.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加入驅動軸&lt;/p&gt;
&lt;p&gt;在第一個連桿「Line0」上按下滑鼠右鍵，選擇「Turn this Link to Shaft」，將連桿加上驅動軸角度約束。&lt;/p&gt;
&lt;p&gt;並留意設定第二點要有固定約束。&lt;/p&gt;
&lt;p&gt;接著就能做相關模擬操作了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0409_05.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;開發了一些加速繪圖的方式，如使用 &lt;kbd&gt;Alt&lt;/kbd&gt; 鍵快速新增節點，之後會再增加一些方便的功能，加快設計流程。&lt;/p&gt;
&lt;p&gt;關於畫布相關操作說明放到了瀏覽提示中，在關閉側邊欄的情況下仍可參考操作說明。&lt;/p&gt;
&lt;h2&gt;連續路徑&lt;/h2&gt;
&lt;p&gt;新的 Path track 路徑顯示已改成連續線。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0409_06.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;明天再做衝突測試後，會加上三角求解器的防呆措施，之後發布 v0.6.4 更新。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/04/08</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060408.html" rel="alternate"></link><published>2017-04-08T21:00:00+08:00</published><updated>2017-04-08T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-04-08:blog/40323230ri-zhi-1060408.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;圖面標示&lt;/li&gt;
&lt;li&gt;Qt About&lt;/li&gt;
&lt;li&gt;三角形實體&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;圖面標示&lt;/h2&gt;
&lt;p&gt;將點、連桿、呆鏈的編號標籤和數據合併顯示。&lt;/p&gt;
&lt;p&gt;當開啟 point mark 功能時，會顯示編號標籤，當開啟顯示 dimensions 功能實會在標籤後顯示數據。&lt;/p&gt;
&lt;p&gt;關閉 point mark 時，顯示數據也會被關閉。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0408_01.png" /&gt;&lt;/p&gt;
&lt;h2&gt;Qt About&lt;/h2&gt;
&lt;p&gt;使用 Qt 開發的應用程式可以透過以下方式跳出 Qt 的 About 對話窗。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
QMessageBox.aboutQt(self)
&lt;/pre&gt;

&lt;p&gt;其中 self 是凍結的視窗，按下 Close 之後才會執行後續的動作。&lt;/p&gt;
&lt;p&gt;呈現如下圖。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0408_02.png" /&gt;&lt;/p&gt;
&lt;h2&gt;三角形實體&lt;/h2&gt;
&lt;p&gt;新的三角求解器面板介面如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0408_03.png" /&gt;&lt;/p&gt;
&lt;p&gt;右側是加入或移除三角形題目，下方則是套入現成的多連桿 template，協助加入三角形到表單中。&lt;/p&gt;
&lt;p&gt;多連桿 template 將會提供一個參數表加入現成點，然後用新的三角形建立當前位置形成的實體。&lt;/p&gt;
&lt;p&gt;新的三角形 PPP 提供三個已知點，求解器回傳三角形的三邊長，Pyslvs 利用三邊長建立實體。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0408_04.png" /&gt;&lt;/p&gt;
&lt;p&gt;上述的 template 的功能尚未加入，預計明天完成四連桿和八連桿的表單。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0408_05.png" /&gt;&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/04/04</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060404.html" rel="alternate"></link><published>2017-04-04T21:00:00+08:00</published><updated>2017-04-04T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-04-04:blog/40323230ri-zhi-1060404.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;匯入檔案功能（Import）&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;匯入檔案功能（Import）&lt;/h2&gt;
&lt;p&gt;版本 0.6 加入最後的功能為合併兩個檔案的表格內容，以便稍後 template 的加入。&lt;/p&gt;
&lt;p&gt;今天做到的進度為合併兩者實體，不過前者的路徑會被後者覆蓋掉。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0404_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;Import 的另外一個選項是從 template 建立，打算由一個新的 GUI 加入預設的連桿組（使用三角迭代器求解）。&lt;/p&gt;
&lt;p&gt;不過因為有預覽圖的設計，會花較久的時間。&lt;/p&gt;
&lt;p&gt;預計 template 功能檢測完畢後，會發布 v0.6.4，並開始計畫 v0.7 的 Database 格式。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/04/03</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060403.html" rel="alternate"></link><published>2017-04-03T21:00:00+08:00</published><updated>2017-04-03T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-04-03:blog/40323230ri-zhi-1060403.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;衝突提示&lt;/li&gt;
&lt;li&gt;準備版次功能 - &lt;strong&gt;計畫&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;衝突提示&lt;/h2&gt;
&lt;p&gt;在約束衝突時會顯示提示訊息，幫助尋找可能發生的錯誤。&lt;/p&gt;
&lt;p&gt;目前使用的機制是檢查重複約束，會將一樣的約束列出來。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0403_01.png" /&gt;&lt;/p&gt;
&lt;h2&gt;準備版次功能&lt;/h2&gt;
&lt;p&gt;參考 fossil 的資料庫架構：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.fossil-scm.org/xfer/doc/trunk/www/fileformat.wiki"&gt;https://www.fossil-scm.org/xfer/doc/trunk/www/fileformat.wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在 History 分頁中多加一層 Undo and Redo 分頁欄。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0403_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;以後會新增另一個分頁，使用該分頁操作 Database 每次 commit 的內容，打算會有下列功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新增版本&lt;/li&gt;
&lt;li&gt;檢視版本（Read only 模式）&lt;/li&gt;
&lt;li&gt;修改版本註解&lt;/li&gt;
&lt;li&gt;回溯版本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;至於舊的 csv 格式會停止支援，改為 SQL 的資料庫結構。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;新功能是 Pyslvs v0.7 的開發方向，當前的 v0.6 更新著重於穩定性部份。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/03/31</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060331.html" rel="alternate"></link><published>2017-03-31T21:00:00+08:00</published><updated>2017-03-31T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-03-31:blog/40323230ri-zhi-1060331.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;瀏覽提示&lt;/li&gt;
&lt;li&gt;新的存檔格式 - &lt;strong&gt;計畫&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;瀏覽提示&lt;/h2&gt;
&lt;p&gt;在比例滑桿左側加入一個提示 icon，滑鼠移到上方可以有瀏覽提示。&lt;/p&gt;
&lt;p&gt;可能之後會提供其他狀態列沒說明的功能。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0331_01.png" /&gt;&lt;/p&gt;
&lt;h2&gt;新的存檔格式&lt;/h2&gt;
&lt;p&gt;之後會參考 fossil 的 Database 方式提供&lt;strong&gt;更具規劃的&lt;/strong&gt;存檔格式，並且可以紀錄版次。&lt;/p&gt;
&lt;p&gt;使用 SQL 檔案格式的話要將 peewee 套件加回來，結構會參考 PythonCAD 的處理方式。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/03/29</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060329.html" rel="alternate"></link><published>2017-03-29T21:00:00+08:00</published><updated>2017-03-29T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-03-29:blog/40323230ri-zhi-1060329.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;輸入介面改善&lt;/li&gt;
&lt;li&gt;Debian package&lt;/li&gt;
&lt;li&gt;Drive shaft 面板功能&lt;/li&gt;
&lt;li&gt;Path track 面板功能 - &lt;strong&gt;計畫&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;鏈鏈輸入介面改善&lt;/h2&gt;
&lt;p&gt;連桿和呆鍊的設定視窗會偵測當前兩點的距離，方便使用者估算。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0329_01.png" /&gt;&lt;/p&gt;
&lt;h2&gt;Debian package&lt;/h2&gt;
&lt;p&gt;在 Makefile 中加入 deb 選項可以讓編譯完的 Pyslvs 包裝成 Debian 系統的安裝檔，可以當成類似 Windows 的壓縮檔安裝到 Ubuntu 使用者的家目錄 &lt;code&gt;~/Pyslvs&lt;/code&gt; 中。&lt;/p&gt;
&lt;h2&gt;Drive shaft 面板功能&lt;/h2&gt;
&lt;p&gt;改進了之前的水平滑桿，變成比較易懂的 QDial 旋鈕，旋轉方向與圖面一致，逆時針為正。&lt;/p&gt;
&lt;p&gt;不過 QDial 的預設 0 的位置在正下方，要調整可能比較麻煩，因為讀值會變負的，而且起始和終止位置不一定是 0 和 360 度，所以目前尚未改掉。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0329_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;旁邊的播放鈕會自動旋轉 10 圈，可以隨時中斷，也能重新播放。&lt;/p&gt;
&lt;h2&gt;Path track 面板功能&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;速度&lt;/strong&gt;和&lt;strong&gt;加速度&lt;/strong&gt;的功能預計歸類到路徑追蹤的項目中，可以推導該座標的公式，並能藉由輸入值求出當前座標的速度和加速度。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/03/27</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060327.html" rel="alternate"></link><published>2017-03-27T21:00:00+08:00</published><updated>2017-03-27T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-03-27:blog/40323230ri-zhi-1060327.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Release version 0.6&lt;/li&gt;
&lt;li&gt;關於報告&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;Release version 0.6&lt;/h2&gt;
&lt;p&gt;先釋出 0.6.0 版本，較 Bata 版增加防止三角形運算錯誤的機制和一些界面改進。&lt;/p&gt;
&lt;p&gt;還新增生成曲柄滑塊的設計範例，不過計算後不是完整角度的，之後會改良。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0327_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;計算速度和加速度的功能預計在下個小版本 v0.6.1 中加入，並修正上述目前 Pyslvs 範例中不適合的尺寸。&lt;/p&gt;
&lt;p&gt;小更新仍在分支 dev0.6 中開發。&lt;/p&gt;
&lt;h2&gt;關於報告&lt;/h2&gt;
&lt;p&gt;之前申請預延生有用 Word 稍微整理暑假的資訊，並列出大綱。&lt;/p&gt;
&lt;p&gt;雖然當時章節沒分明確，但是已有大綱基本雛型，現階段要將介紹資料整理完整，並為每個大綱內容分配專題的所屬項目。&lt;/p&gt;
&lt;p&gt;接著使用 Leo editor 將 Markdown 文件編排完整供審理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;預定倉儲&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/KmolYuan/Special-Report"&gt;https://github.com/KmolYuan/Special-Report&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前定版在 Pyslvs 0.6 的部份，會據下列項目作剖析說明。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;緒論&lt;/p&gt;
&lt;p&gt;說明研究動機目的、現有參考資料的討論，以及整體大綱分析。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;設計理論&lt;/p&gt;
&lt;p&gt;本專案使用的所有數學公式推導、四連桿相關資訊、演算法的說明。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平面機構解題&lt;/p&gt;
&lt;p&gt;源於 Solvespace 的解題程式庫轉為 Python API（應用程式界面）的過程，並說明 Pyslvs 如何利用之。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;四連桿尺寸合成系統&lt;/p&gt;
&lt;p&gt;介紹合成系統使用的技術。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;電腦輔助設計應用程式框架&lt;/p&gt;
&lt;p&gt;關於 Qt 框架的利用，並闡述使用者界面設計上的考量與版本推進內容。&lt;/p&gt;
&lt;p&gt;此部份也會包含所有模組與系統整合的說明。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;結論與未來展望&lt;/p&gt;
&lt;p&gt;現階段的軟體設計成果以及之後的發展方向。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外&lt;strong&gt;使用者手冊&lt;/strong&gt;和&lt;strong&gt;開發者手冊&lt;/strong&gt;可能要以更有效率的方式統整。可能沒辦法做得和 Python 模組一樣細，開發者手冊會先將大項目和各項區域介紹清楚；使用者手冊則會偏向將概念以「圖示」表達清楚而非有太多截圖。之前寒假寫的可能必須重新改版，用新的論文框架排版。&lt;/p&gt;
&lt;p&gt;上述兩者同樣以 Markdown 文件編寫，放在以下倉儲：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/KmolYuan/Pyslvs-manual"&gt;https://github.com/KmolYuan/Pyslvs-manual&lt;/a&gt;&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/03/25</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060325.html" rel="alternate"></link><published>2017-03-25T21:00:00+08:00</published><updated>2017-03-25T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-03-25:blog/40323230ri-zhi-1060325.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面板工具提示&lt;/li&gt;
&lt;li&gt;演算法結果校正&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;面板工具提示&lt;/h2&gt;
&lt;p&gt;為了讓 GUI 特色更易懂，在面板的按鈕上加入工具提示，滑鼠游標指到上方會出現功能說明。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0325_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;三角求解器的加入鈕也有對應顯示，不用進對話視窗就能看三角形的設計。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0325_02.png" /&gt;&lt;/p&gt;
&lt;h2&gt;演算法結果校正&lt;/h2&gt;
&lt;p&gt;之前的演算法結果是多代入一次 Solvespace 的 kernel 做定位，可是無法辨識是否為反轉四連桿。&lt;/p&gt;
&lt;p&gt;現在有三角求解器可以拆開結果（因為是固定形狀和參數很好分辨），比對頂點的位置後決定是否反轉。&lt;/p&gt;
&lt;p&gt;驗證後合併功能就正常了，不會有路徑在下方卻將呆鏈生成在上方的情況。&lt;/p&gt;
&lt;p&gt;另外發現差分演算法雖然快速，但是誤差滿大，有時候某些角度範圍會讓 Solvespace 的 kernel 求解回傳失敗（不過求解成功的片段路徑會符合要求）。&lt;/p&gt;
&lt;p&gt;其他兩個演算法時間雖然較久，但是不容易發生上述情形。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/03/22</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060322.html" rel="alternate"></link><published>2017-03-22T21:00:00+08:00</published><updated>2017-03-22T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-03-22:blog/40323230ri-zhi-1060322.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度 - 三角求解器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完成合併功能&lt;/li&gt;
&lt;li&gt;演算法合併校正&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度 - 三角求解器&lt;/h1&gt;
&lt;h2&gt;完成合併功能&lt;/h2&gt;
&lt;p&gt;算完結果後會依據參照設定合併成實體。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0322_01.png" /&gt;&lt;/p&gt;
&lt;h2&gt;演算法合併校正&lt;/h2&gt;
&lt;p&gt;由於現在有了三角求解器的驗證 kernel，可以設法利用其功能協助演算法結果預先得到點座標。&lt;/p&gt;
&lt;p&gt;這樣可以降低錯誤發生的情況。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/03/20</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060320.html" rel="alternate"></link><published>2017-03-20T21:00:00+08:00</published><updated>2017-03-20T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-03-20:blog/40323230ri-zhi-1060320.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度 - 三角求解器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;關於範例結合報告&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度 - 三角求解器&lt;/h1&gt;
&lt;h2&gt;關於範例結合報告&lt;/h2&gt;
&lt;p&gt;預計加入的新範例「Theo Jansen's multi linkage（泰奧．楊森的多連桿組）」，為仿生獸的腳轉到 55° 時的座標位置。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0320_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;合併功能只做到加入點，之後還有連桿、呆鏈、滑塊的選項，載入範例後能生成多連桿。&lt;/p&gt;
&lt;p&gt;而新的 csv 格式已經包含設計數據，之後會重新整理程式外附的範例檔（包含一組新的曲柄滑塊），解析並加入報告中。&lt;/p&gt;
&lt;p&gt;看了一下滑塊 PLPP 的部份，似乎沒有較流暢的公式推導，而 SimPy 推出來是用矩陣解的，求解器暫時套用 SimPy 的公式，報告中會另外整理。&lt;/p&gt;
&lt;p&gt;報告最近會開始分類章節，以「電腦輔助設計應用程式」為主，「平面四連桿尺寸合成」和 Solvespace 相關部份為輔，扼要介紹理論部份的內容。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/03/18</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060318.html" rel="alternate"></link><published>2017-03-18T21:00:00+08:00</published><updated>2017-03-18T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-03-18:blog/40323230ri-zhi-1060318.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三角求解器面板&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;三角求解器面板&lt;/h2&gt;
&lt;p&gt;接上 GUI，可以用對話視窗輸入數值求解，切換求解法時會有對應的預覽圖。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0318_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;按下求解鈕後會更新解答，當解答求出後可以生成實體進畫布，不過這部分功能還沒做。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0318_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;支援 PLAP、PLLP、PLPP 三種方式求解。&lt;/p&gt;
&lt;p&gt;另外已修正餘弦定理公式產生分母為 0 的狀況，分母會被設定為 0.01，得出解會有少許誤差。&lt;/p&gt;
&lt;p&gt;最後，這種設計數據會納入檔案格式中，新的範例會給一個有設計數據的空白工作簿，啟動面板後求解，&lt;strong&gt;目標是可以生成範例中仿生獸的腳。&lt;/strong&gt;&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/03/16</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060316.html" rel="alternate"></link><published>2017-03-16T21:00:00+08:00</published><updated>2017-03-16T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-03-16:blog/40323230ri-zhi-1060316.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;卡車尾門範例&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;卡車尾門範例&lt;/h2&gt;
&lt;p&gt;新增伸縮桿的簡單範例，機構源自 &lt;a href="https://www.google.com/patents/US7547055"&gt;https://www.google.com/patents/US7547055&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;改變 Point0 到 Point2 的距離可以收合尾門。&lt;/p&gt;
&lt;p&gt;兩段式的升降裝置找不太到清楚的機構圖，可能要操控 2 個以上的伸縮桿才能達成。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0316_01.png" /&gt;&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Pandoc - Markdown 基本語法介紹</title><link href="http://project.mde.tw/blog/pandoc-markdown-ji-ben-yu-fa-jie-shao.html" rel="alternate"></link><published>2017-03-16T21:00:00+08:00</published><updated>2017-03-16T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-03-16:blog/pandoc-markdown-ji-ben-yu-fa-jie-shao.html</id><summary type="html">&lt;p&gt;一些 Pandoc 常用的 Markdown 語法及注意事項&lt;/p&gt;


&lt;h1&gt;一些 Pandoc 常用的 Markdown 語法及注意事項&lt;/h1&gt;
&lt;p&gt;參考資料：&lt;a href="https://pandoc.org/README.pdf"&gt;https://pandoc.org/README.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;基礎須知：Markdown 相對於其他文書格式，並非「易撰寫」，而是「易閱讀」，因此在語法上有很多種表達方式，擇一即可。&lt;/p&gt;
&lt;p&gt;在需要特殊排版要求時才會加入 html 語法，而 html 語法中的任何 Markdown 記號都會視為通常字元。&lt;/p&gt;
&lt;p&gt;這裡介紹的為 Pandoc 支援的語法，Pelican 轉換網誌時可能無法支援。&lt;/p&gt;
&lt;p&gt;為編輯方便，這篇文章使用 Leo Editor 的 &lt;code&gt;@others&lt;/code&gt; 和 &lt;code&gt;@clean&lt;/code&gt; 語法編輯文件。&lt;/p&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#書目與換頁"&gt;書目與換頁&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#換行記號"&gt;換行記號&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#標題"&gt;標題&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#分隔線"&gt;分隔線&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#粗體與斜體"&gt;粗體與斜體&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#清單"&gt;清單&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#連結與圖片"&gt;連結&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#表格"&gt;表格&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#數學符號"&gt;數學符號&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#程式碼"&gt;程式碼&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#參考文獻"&gt;參考文獻&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#注意事項"&gt;注意事項&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;&lt;a name="書目與換頁"&gt;&lt;/a&gt;Pandoc 書目與換頁&lt;/h2&gt;
&lt;h3&gt;書目&lt;/h3&gt;
&lt;p&gt;使用百分比符號隔著 1 到 4 格空白，插入置中封面文字。&lt;/p&gt;
&lt;pre&gt;
% 封面標題
% 作者
% 28, January, 2017

---

內文不能再使用
&lt;/pre&gt;

&lt;h3&gt;換頁&lt;/h3&gt;
&lt;p&gt;換頁記號使用後不用再換行。&lt;/p&gt;
&lt;pre&gt;
\newpage
&lt;/pre&gt;

&lt;h2&gt;&lt;a name="換行記號"&gt;&lt;/a&gt;換行記號&lt;/h2&gt;
&lt;p&gt;使用&lt;strong&gt;空行&lt;/strong&gt;的方式來作換行，如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;第一段文字

第二段文字
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;「看起來像」空行也會被視作空行，如該行只有空白或 tab 字元。&lt;/p&gt;
&lt;p&gt;若是沒有換行，兩段緊貼的文字仍會視為同一段。&lt;/p&gt;
&lt;p&gt;若要插入一段空行，可以用反斜線 &lt;code&gt;\&lt;/code&gt; 符號加上一個以上的空白字元。&lt;/p&gt;
&lt;h2&gt;&lt;a name="標題"&gt;&lt;/a&gt;標題&lt;/h2&gt;
&lt;p&gt;每個標題中都內建錨點，相當於 html 的 h1, h2, h3。&lt;/p&gt;
&lt;p&gt;分成 Setext 和 Atx 兩種形式，而這兩種形式是可以混用的。&lt;/p&gt;
&lt;p&gt;在 Pandoc 中，每個標題都會轉為 PDF 的目錄書籤。&lt;/p&gt;
&lt;h3&gt;Setext 形式&lt;/h3&gt;
&lt;p&gt;使用 3 個或以上的「等於」與「減號」代表 h1 和 h2。&lt;/p&gt;
&lt;pre&gt;
This is an H1
===

This is an H2
-------------
&lt;/pre&gt;

&lt;h3&gt;Atx 形式&lt;/h3&gt;
&lt;p&gt;井字號的數量決定層級。&lt;/p&gt;
&lt;pre&gt;
# This is an H1

## This is an H2

###### This is an H6
&lt;/pre&gt;

&lt;h2&gt;&lt;a name="分隔線"&gt;&lt;/a&gt;分隔線&lt;/h2&gt;
&lt;p&gt;使用 3 個或以上的「星號」、「減號」、「下底線」來畫出水平分隔線。&lt;/p&gt;
&lt;p&gt;水平線的符號必須被空白圍繞，若是緊貼其他文字則會失效。&lt;/p&gt;
&lt;pre&gt;
---

*    *    *    *

_____
&lt;/pre&gt;

&lt;h2&gt;&lt;a name="粗體與斜體"&gt;&lt;/a&gt;粗體與斜體&lt;/h2&gt;
&lt;p&gt;在內文中標記粗體與斜體，兩者可以混用，但是開頭與結尾必須一致。&lt;/p&gt;
&lt;p&gt;論文中比較少用兩者，可以在寫網誌時畫重點。&lt;/p&gt;
&lt;p&gt;使用「星號」或「下底線」代表斜體。&lt;/p&gt;
&lt;pre&gt;
*斜體文字*

_斜體文字_
&lt;/pre&gt;

&lt;p&gt;使用雙「星號」或「下底線」代表粗體。&lt;/p&gt;
&lt;pre&gt;
**粗體文字**

__粗體文字__
&lt;/pre&gt;

&lt;h2&gt;&lt;a name="清單"&gt;&lt;/a&gt;清單&lt;/h2&gt;
&lt;p&gt;清單分為無序和有序，都可以使用降階不間段放入內容。&lt;/p&gt;
&lt;p&gt;使用「星號」、「減號」、「加號」隔著 1 到 4 格空白來代表無序清單。&lt;/p&gt;
&lt;pre&gt;
* 其中一項

    + 還有一項

    + 還有一項

        - 還有一項

* 其中一項

* 其中一項
&lt;/pre&gt;

&lt;p&gt;使用「普通數字」與「英文句號」隔著 1 到 4 格空白放入內容，產生有序清單。可以完全不照順序排版，在最終會自動轉換成順序排列。&lt;/p&gt;
&lt;pre&gt;
1. 永遠的第一項

1. 永遠的第二項

6. 永遠的第三項
&lt;/pre&gt;

&lt;h2&gt;&lt;a name="連結與圖片"&gt;&lt;/a&gt;連結與圖片&lt;/h2&gt;
&lt;p&gt;基本的連結樣式：&lt;/p&gt;
&lt;pre&gt;
有一個[連結文字](http://www.google.com)在這裡。
&lt;/pre&gt;

&lt;p&gt;轉移的連結樣式。優點是可以統一放在同一處，並且能重複引用。&lt;/p&gt;
&lt;p&gt;要注意冒號後必須有 1 到 4 個空白。&lt;/p&gt;
&lt;pre&gt;
有一個[連結文字][]在這裡。

[連結文字]: http://www.google.com
&lt;/pre&gt;

&lt;p&gt;圖片使用方式跟連結一樣，只須在前端加上驚嘆號。&lt;/p&gt;
&lt;p&gt;圖片從自身檔案開始尋找，或是使用網路連結（轉檔時連網即可）。&lt;/p&gt;
&lt;pre&gt;
![圖片名稱][]

[圖片名稱]: image/a.jpg
&lt;/pre&gt;

&lt;p&gt;Pandoc 會處理單行的圖片（同行不可有字元），為其置中、編入圖片編號（以章節出現排序），並且在下方置入圖片標籤。&lt;/p&gt;
&lt;p&gt;安裝擴充套件 pandoc-fignos 後，使用下面的方式引用：&lt;/p&gt;
&lt;pre&gt;
![圖片名稱][]

請參考圖 {@fig:圖片代稱} 中的內容。

[圖片名稱]: image/a.jpg {#fig:圖片代稱}
&lt;/pre&gt;

&lt;h2&gt;&lt;a name="表格"&gt;&lt;/a&gt;表格&lt;/h2&gt;
&lt;p&gt;Markdown 的表格分為 4 種樣式，並有不同表達法。&lt;/p&gt;
&lt;p&gt;正式表格多用管表格表示：&lt;/p&gt;
&lt;pre&gt;
Table: 表格名稱 {#tbl:表格代號}

| Tables   |      Are      |  Cool |
|----------|:-------------:|------:|
| col 1 is |  left-aligned | $1600 |
| col 2 is |    centered   |   $12 |
| col 3 is | right-aligned |    $1 |

參照表 {@tbl:表格代號}
&lt;/pre&gt;

&lt;p&gt;使用網頁服務生成：&lt;a href="http://www.tablesgenerator.com/markdown_tables"&gt;http://www.tablesgenerator.com/markdown_tables&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a name="數學符號"&gt;&lt;/a&gt;數學符號&lt;/h2&gt;
&lt;p&gt;Pandoc 支援插入 Latex 的數學公式，可以藉由網頁服務轉換。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.hostmath.com/"&gt;http://www.hostmath.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用時兩端包上錢幣符號，如下：&lt;/p&gt;
&lt;pre&gt;
$$\frac{-b\pm\sqrt{b^2-4ac}}{2a}$$
&lt;/pre&gt;

&lt;p&gt;會生成：&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{-b\pm\sqrt{b^2-4ac}}{2a}$$&lt;/div&gt;
&lt;h2&gt;&lt;a name="程式碼"&gt;&lt;/a&gt;程式碼&lt;/h2&gt;
&lt;p&gt;Markdown 用簡單的縮排插入程式碼，如：&lt;/p&gt;
&lt;pre&gt;
這是一段 Python 程式：

    if __name__='__main__':
        print("Hello world!")

印出 Hello world! 字樣。
&lt;/pre&gt;

&lt;p&gt;或是使用重音符（Grave accent）包起單一程式碼：&lt;/p&gt;
&lt;pre&gt;
一段程式：

`print("Hello world!")`
&lt;/pre&gt;

&lt;p&gt;若一大串程式碼，可以用三個以上的重音符包起，也能用語言名稱加註：&lt;/p&gt;
&lt;pre&gt;
Bash 指令：

```bash
sudo apt install python3-pip
sudo pip3 install markdown
```&lt;/pre&gt;

&lt;h2&gt;&lt;a name="參考文獻"&gt;&lt;/a&gt;參考文獻&lt;/h2&gt;
&lt;p&gt;將參考資料的資訊放入 bibtex 檔案中，並給予一個識別名稱（如 myart），結構如下：&lt;/p&gt;
&lt;pre&gt;
@article{myart,
  author  = {作者名字}, 
  title   = {標題},
  journal = {刊物名稱},
  year    = 1993,
  number  = 2,
  pages   = {201-213},
  month   = 7,
  note    = {選擇性註解}, 
  volume  = 4
}
&lt;/pre&gt;

&lt;p&gt;接著可以在內文中使用：&lt;/p&gt;
&lt;pre&gt;
參考於書籍[@myart]。
&lt;/pre&gt;

&lt;p&gt;Pabdoc 會自動編碼，套用不同的 csl 檔案可以改變條列外觀。&lt;/p&gt;
&lt;h2&gt;&lt;a name="注意事項"&gt;&lt;/a&gt;注意事項&lt;/h2&gt;
&lt;p&gt;不像其他語言，在 Leo Editor 中使用 &lt;code&gt;@others&lt;/code&gt; 與 &lt;code&gt;@clean&lt;/code&gt; 編輯 Markdown 論文或技術手冊時，&lt;strong&gt;子節點必須多留一個換行&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;否則 Leo Editor 在儲存時會把下一個子節點的第一行對齊到前個節點的最後一行，導致&lt;strong&gt;沒有換行標記&lt;/strong&gt;，會誤認這兩行的內容為同一行而沒做換行處理。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;更多內容請參見：&lt;a href="http://markdown.tw/"&gt;http://markdown.tw/&lt;/a&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="pandoc"></category><category term="Leo Editor"></category></entry><entry><title>Pandoc - Markdown 轉 PDF 格式</title><link href="http://project.mde.tw/blog/pandoc-markdown-zhuan-pdf-ge-shi.html" rel="alternate"></link><published>2017-03-16T21:00:00+08:00</published><updated>2017-03-16T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-03-16:blog/pandoc-markdown-zhuan-pdf-ge-shi.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Ubuntu 安裝方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Windows 安裝方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;圖片與表格的參照擴充套件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用範例&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Pyslvs 手冊倉儲：&lt;a href="https://github.com/KmolYuan/Pyslvs-manual"&gt;https://github.com/KmolYuan/Pyslvs-manual&lt;/a&gt;&lt;/p&gt;


&lt;h1&gt;Ubuntu 安裝方式&lt;/h1&gt;
&lt;p&gt;首先安裝 Pandoc、texLive、texLive-xetex、etoolbox。&lt;/p&gt;
&lt;p&gt;到 Pandoc 的 Github 倉儲下載 debian 安裝檔，用 software center 安裝。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/jgm/pandoc/releases/"&gt;https://github.com/jgm/pandoc/releases/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接著用 apt 安裝 texLive。&lt;/p&gt;
&lt;pre&gt;
$sudo apt install texlive texlive-xetex texlive-lang-chinese etoolbox
&lt;/pre&gt;

&lt;p&gt;若是有檔案缺損，直接轉檔，可能會缺少所需的轉換範本，出現類似下面的警告：  &lt;/p&gt;
&lt;pre&gt;
! LaTeX Error: File `etoolbox.sty' not found.

Type X to quit or RETURN to proceed,
or enter new name. (Default extension: sty)

Enter file name:
! Emergency stop.
read *

l.8 \RequirePackage

pandoc: Error producing PDF
&lt;/pre&gt;

&lt;h1&gt;Windows 安裝方式&lt;/h1&gt;
&lt;p&gt;Windows 只需安裝 Pandoc 與 MikTex。&lt;/p&gt;
&lt;p&gt;到 Pandoc 的 Github 倉儲下載 msi 安裝檔。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/jgm/pandoc/releases/"&gt;https://github.com/jgm/pandoc/releases/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然後根據 XeLaTex 的說明安裝 MikTex，並執行 MikTex Update 更新 xetex 的檔案。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.texts.io/support/0002/"&gt;http://www.texts.io/support/0002/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Windows 可以使用 MikTex Package Manager 來安裝套件，在過濾器中打上套件搜尋安裝即可。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0121_01.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;以下是 Windows 必須安裝的套件名稱：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;etoolbox&lt;/li&gt;
&lt;li&gt;cjk（中文、日文、韓文語法支援，包含漢字數字）&lt;/li&gt;
&lt;li&gt;xecjk（基本的 CJK 支援）&lt;/li&gt;
&lt;li&gt;makecmds（Latex 的自定義函式，提供自訂與複寫參數）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;圖片與表格的參照擴充套件&lt;/h1&gt;
&lt;p&gt;文章中常有「引用圖 1.1」之類的編號說明。&lt;/p&gt;
&lt;p&gt;不過 Pandoc 沒有內建這個功能，所以必須安裝 pandoc-fignos 和 pandoc-tablenos。&lt;/p&gt;
&lt;p&gt;pandoc-fignos 是 Python 套件，使用 pip 安裝。&lt;/p&gt;
&lt;pre&gt;
$sudo pip3 install pandoc-fignos
$sudo pip3 install pandoc-tablenos
&lt;/pre&gt;

&lt;p&gt;之後在 pandoc 參數中增加 &lt;code&gt;--filter pandoc-fignos&lt;/code&gt; 和 &lt;code&gt;--filter pandoc-tablenos&lt;/code&gt; 來啟用這個語法。&lt;/p&gt;
&lt;h1&gt;使用範例&lt;/h1&gt;
&lt;p&gt;&lt;a href="http://pandoc.org/demos.html"&gt;http://pandoc.org/demos.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;參照 pandoc 的 demo，下載 MANUAL.txt 這個 Markdown 檔案來測試。&lt;/p&gt;
&lt;p&gt;使用以下指令：&lt;/p&gt;
&lt;pre&gt;
$pandoc MANUAL.txt --latex-engine=xelatex -o MANUAL.pdf
&lt;/pre&gt;

&lt;p&gt;轉換後不會有任何提示，會直接輸出檔案。&lt;/p&gt;
&lt;p&gt;平常使用 pandoc 指令，可以如同 Python 直譯器直接輸入 Markdown 語法，輸入後按下 &lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;D&lt;/kbd&gt; 來轉換並顯示 html 語法（Windows 是 &lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;C&lt;/kbd&gt;）。&lt;/p&gt;
&lt;p&gt;若是結合 &lt;code&gt;--latex-engine=xelatex&lt;/code&gt; 或是 &lt;code&gt;-o&lt;/code&gt; 參數，更可以直接輸出成 pdf 檔案。&lt;/p&gt;
&lt;p&gt;而輸出的 pdf 檔案會自動分頁、排版、標記頁碼。demo 網頁上還有其他範例，可以轉換成不同格式的文件。&lt;/p&gt;
&lt;p&gt;手冊方面全局使用 Leo editor 管理，並整合轉檔的工作，圖片則使用另一個倉儲儲存，不過這些 Markdown 樣板的語法跟網誌的語法不太相同，可能要稍微測試並習慣其用法。&lt;/p&gt;
&lt;p&gt;另外還可以加入 &lt;code&gt;--toc&lt;/code&gt; 參數自動生成目錄，為 table of contents 的縮寫。&lt;/p&gt;
&lt;p&gt;生成的目錄如下的形式，並會自動加上連結。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0121_02.png" /&gt;&lt;/p&gt;</summary><category term="pandoc"></category></entry><entry><title>40323230日誌 - 106/03/12</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060312.html" rel="alternate"></link><published>2017-03-12T21:00:00+08:00</published><updated>2017-03-12T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-03-12:blog/40323230ri-zhi-1060312.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三角求解器模組&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;三角求解器模組&lt;/h2&gt;
&lt;p&gt;寫了一個小模組求解，還未連接使用者界面。&lt;/p&gt;
&lt;p&gt;主要功能是傳入一個 list（包含大量題目）並解題。不過 class 裡的函式可以單獨使用。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from math import *

##Directions:
##[{'p1':Point1, 'p2':Point2, 'len1':Line1, ('len2':Line2, 'angle':angle)}, ...]

class solver():
    def __init__(self, Directions=list()):
        #Cosine Theorem
        self.CosineTheoremAngle = lambda a, b, c: acos((b**2+c**2-a**2)/(2*b*c))
        self.CosineTheoremSide = lambda alpha, b, c: b**2+c**2-2*b*c*cos(alpha)
        self.Directions = Directions

    def set(self, Directions): self.Directions = Directions

    def answer(self):
        answer = self.Iterator() if self.Parser() else None
        self.Directions.clear()
        return answer

    def Parser(self):
        for e in self.Directions:
            pos = self.Directions.index(e)
            if e.get('p1', False) is False: return False
            if e.get('p2', False) is False: return False
            if e.get('len1', False) is False: return False
            if e.get('len2', False) is False and e.get('angle', False) is False: return False
            if e.get('len2', False) is False: self.Directions[pos]['Type'] = 'PLAP'
            elif e.get('angle', False) is False: self.Directions[pos]['Type'] = 'PLLP'
        return True

    def Iterator(self):
        results = list()
        for e in self.Directions:
            p1 = results[e['p1']] if type(e['p1'])==int else e['p1']
            p2 = results[e['p2']] if type(e['p2'])==int else e['p2']
            #Direction of the point
            other = e.get('other', False)
            ##True: angle1-angle2
            ##False: angle1+angle2
            if e['Type']=='PLAP': results.append(self.PLAP(p1, e['len1'], e['angle'], p2, other))
            elif e['Type']=='PLLP': results.append(self.PLLP(p1, e['len1'], e['len2'], p2, other))
        return results

    def PLAP(self, p1, line1, angle, p2, other=False):
        x1 = p1[0]
        y1 = p1[1]
        len1 = float(line1)
        angle2 = radians(float(angle))
        angle1 = self.m(p1, p2)
        if other:
            cx = x1+len1*cos(angle1-angle2)
            cy = y1+len1*sin(angle1-angle2)
        else:
            cx = x1+len1*cos(angle1+angle2)
            cy = y1+len1*sin(angle1+angle2)
        return cx, cy

    def PLLP(self, p1, line1, line2, p2, other=False):
        x1 = p1[0]
        y1 = p1[1]
        x2 = p2[0]
        y2 = p2[1]
        len1 = float(line1)
        len2 = float(line2)
        d = sqrt((x1-x2)**2+(y2-y1)**2)
        angle1 = self.m(p1, p2)
        angle2 = self.CosineTheoremAngle(len2, d, len1)
        if other:
            cx = x1+len1*cos(angle1-angle2)
            cy = y1+len1*sin(angle1-angle2)
        else:
            cx = x1+len1*cos(angle1+angle2)
            cy = y1+len1*sin(angle1+angle2)
        return cx, cy

    def m(self, p1, p2):
        x1 = p1[0]
        y1 = p1[1]
        x2 = p2[0]
        y2 = p2[1]
        x = x2-x1
        y = y2-y1
        d = sqrt(x**2+y**2)
        return self.CosineTheoremAngle(y, x, d)*(-1 if y&lt;0 else 1)*(-1 if x&lt;0 else 1)

if __name__=='__main__':
    #Test
    s = solver([
        {'p1':(-60, 0), 'p2':(0, 0), 'len1':30, 'angle':50}, #C
        {'p1':0, 'p2':(0, 0), 'len1':50, 'len2':60}, #D
        {'p1':0, 'p2':1, 'len1':50, 'len2':50}, #E
        ])
    print("C={}\nD={}\nE={}".format(*s.answer()))

    ##cx= -40.716371709403816 cy= 22.98133329356934
    ##dx= -6.698073034033397 dy= 59.62495968661744
    ##ex= -55.44153371488418 ey= 70.76385733649067
&lt;/pre&gt;

&lt;p&gt;解題方向指定 p1、p2、len1、angle 或 len2，Parser 會檢查填入項的完整性；Iterator 會自動判斷輸入內容選擇解題。&lt;/p&gt;
&lt;p&gt;而 p1 與 p2 的座標是使用 list 或 tuple 型態給兩個座標軸（取 [0]、[1]），或是引用上一個解（之後會增加順序檢查機制）。其他數據皆為 float 型態。&lt;/p&gt;
&lt;p&gt;角度方面使用 degree，不過 Python 的 math 模組是用 radian，途中會進行轉換。&lt;/p&gt;
&lt;p&gt;原理都是先求 AB 與水平夾的角度（angle1），最後將 CAB 夾角（angle2）加上 angle1 求 AC 與水平夾的角度，最後求出 C 點座標。&lt;/p&gt;
&lt;p&gt;之中為了方便，將餘弦定理做成 lambda 使用。&lt;/p&gt;
&lt;p&gt;程式可能還有一些漏洞，接上 Gui 之前會再檢查一遍。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/03/11</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060311.html" rel="alternate"></link><published>2017-03-11T21:00:00+08:00</published><updated>2017-03-11T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-03-11:blog/40323230ri-zhi-1060311.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;捲動區塊&lt;/li&gt;
&lt;li&gt;PLAP 和 PLLP 的求解 - &lt;strong&gt;計畫&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;QGraphicsView 畫布 - &lt;strong&gt;計畫&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;捲動區塊&lt;/h2&gt;
&lt;p&gt;面板區由於低解析度的螢幕會塞不進空間，改用捲動方式呈現。&lt;/p&gt;
&lt;p&gt;面板的按鈕也重新歸類命名。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0311_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;反合成四連桿系統由視窗改成面板，運算時會凍結自己的 Tab，主畫面的其他功能能夠照常運作。&lt;/p&gt;
&lt;h2&gt;PLAP 和 PLLP 的求解 - &lt;strong&gt;計畫&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;打算開一個新面板（歸類在四連桿尺寸合成系統中），讓使用者能&lt;strong&gt;混用&lt;/strong&gt;兩種方式堆疊三角形求解，並有連續迭代求解的功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;獨立 Kernel 連接 Gui 操縱。&lt;/li&gt;
&lt;li&gt;參數可以使用現成實體位置或長度。&lt;/li&gt;
&lt;li&gt;理論上支援無限迭代。&lt;/li&gt;
&lt;li&gt;運算結果後，使用者可以選擇&lt;strong&gt;生成實體合併進畫布&lt;/strong&gt;、&lt;strong&gt;全部清除&lt;/strong&gt;或是&lt;strong&gt;修改參數&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這個 project 應該是 0.6 版的主要更新項目，會盡量快點完成。&lt;/p&gt;
&lt;h2&gt;QGraphicsView 畫布 - &lt;strong&gt;計畫&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;更有效率、採用局部更新的畫布。&lt;/p&gt;
&lt;p&gt;不過 Qt 當初設計上比較偏向多媒體，所以許多功能偏向動畫方面。&lt;/p&gt;
&lt;p&gt;看完 Python CAD（Qt4）的 QGraphicsView 部份，操縱上不太像 Free CAD 靈活（模仿其他大型商業軟體）。&lt;/p&gt;
&lt;p&gt;目前想先弄好滑鼠中鍵拖移瀏覽的部份（目前還有諸多問題），可能得搞懂 QTransform 的設定。&lt;/p&gt;
&lt;p&gt;新的畫布使用 -t 參數啟動，舊的畫布仍能正常運作。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Python Parser for command-line options</title><link href="http://project.mde.tw/blog/python-parser-for-command-line-options.html" rel="alternate"></link><published>2017-03-08T21:00:00+08:00</published><updated>2017-03-08T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-03-08:blog/python-parser-for-command-line-options.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Python 的命令列參數管理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;argparse 模組&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;部署說明資訊&lt;/li&gt;
&lt;li&gt;參數類型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Python 的命令列參數管理&lt;/h1&gt;
&lt;p&gt;當使用 sys 模組下的 argv，可以觀看當前的參數內容。&lt;/p&gt;
&lt;p&gt;參數在 sys.argv 下是成 string 型態儲存，但是 list 成次序排列，且只會儲存當前輸入項目，因此在調用上十分不方便。&lt;/p&gt;
&lt;p&gt;Python 的 argparse 模組是一個不錯的選擇（3.2 版加入），可以用簡單的設定設置參數名稱和類型，並自動生成類 Unix OS 的 help 選項供調用。&lt;/p&gt;
&lt;h1&gt;argparse 模組&lt;/h1&gt;
&lt;p&gt;簡單列出常用的選項。&lt;/p&gt;
&lt;p&gt;參考資料：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/3/library/argparse.html"&gt;https://docs.python.org/3/library/argparse.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/5262702/argparse-module-how-to-add-option-without-any-argument"&gt;http://stackoverflow.com/questions/5262702/argparse-module-how-to-add-option-without-any-argument&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Python 函式庫語法範例字典：&lt;a href="http://www.books.com.tw/products/0010726838"&gt;http://www.books.com.tw/products/0010726838&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;部署說明資訊&lt;/h2&gt;
&lt;p&gt;在腳本中設定：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
import argparse

parser = argparse.ArgumentParser(
    prog='prog.py', #程式名稱，預設 sys.argv[0]
    usage='%(prog)s [options]', #自訂使用方法外觀，預設由參數產生
    description='程式說明', #頂端程式說明，預設 None
    epilog='程式說明2', #底端程式說明，預設 None
    prefix_chars='-', #參數起始字串，預設 '-'
    add_help=False, #是否開啟 Help 選項，預設 True
    )
parser.add_argument('integers', metavar='N', type=int, nargs='+',
                    help='an integer for the accumulator') #第一個參數
parser.add_argument('--sum', dest='accumulate', action='store_const',
                    const=sum, default=max,
                    help='sum the integers (default: find the max)') #第二個參數
args = parser.parse_args() #解析
&lt;/pre&gt;

&lt;p&gt;如果有啟用 add_help 選項，模組產出的 Help 說明如下：&lt;/p&gt;
&lt;pre&gt;
$ python3 prog.py -h
usage: prog.py [options]

程式說明

positional arguments:
 N           an integer for the accumulator

optional arguments:
 -h, --help  show this help message and exit
 --sum       sum the integers (default: find the max)

 程式說明2
&lt;/pre&gt;

&lt;h2&gt;參數類型&lt;/h2&gt;
&lt;p&gt;add_argument() 方法中可使用的選項。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;name or flags&lt;/p&gt;
&lt;p&gt;名稱或標籤，看之前設置的 prefix_chars 決定，名稱只能為一個，標籤表示法可以有多個。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;action&lt;/p&gt;
&lt;p&gt;傳入參數的動作，預設為 &lt;code&gt;'store'&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;'store'&lt;/code&gt;：儲存，啟用此標籤時會存入後方跟著的項目，按照 type 選項儲存輸入值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;'store_const'&lt;/code&gt;：儲存為常數，啟用此標籤時會存入一個定值，這時必須設定 const 選項。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;'store_true'&lt;/code&gt; 和 &lt;code&gt;'store_false'&lt;/code&gt;：儲存為 True 或 False，啟用此標籤時會存入 True 或 False。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;'append'&lt;/code&gt;：產生一個 list，啟用此標籤時會將後方跟著的項目，按照 type 選項儲存到 list 中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;'append_const'&lt;/code&gt;：產生一個 list，啟用此標籤時會將 const 選項的類型存入 list 中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;'count'&lt;/code&gt;：紀錄這個標籤出現的次數，如 &lt;code&gt;-v&lt;/code&gt; 選項輸入成 &lt;code&gt;-vvv&lt;/code&gt; 時會回傳 3。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;'help'&lt;/code&gt;：預設已經加入，此時若是自行設置會導致衝突。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;'version'&lt;/code&gt;：顯示版本而不啟動程式，這時必須設定 version 選項。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;argparse.Action&lt;/code&gt; 類型：繼承後，透過修改 &lt;strong&gt;call&lt;/strong&gt; 和 &lt;strong&gt;init&lt;/strong&gt; 方法來達成額外的條件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;nargs&lt;/p&gt;
&lt;p&gt;決定多個參數傳入時的處理方式，預設由 action 選項決定。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;'N'&lt;/code&gt;：迭代，使用一個 list 包裝此標籤後的參數。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;'?'&lt;/code&gt;：單一，一次只能傳入一個參數，後方的項目會被視為其他標籤。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;'*'&lt;/code&gt;：不限，使用一個 list 包裝此標籤後的參數，多餘的參數會自動歸類到此標籤下。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;'+'&lt;/code&gt;：至少一個，類似 &lt;code&gt;'*'&lt;/code&gt;，但是在此標籤沒有任何參數時會跳出錯誤訊息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;argparse.REMAINDER&lt;/code&gt; 物件：存為 list，使用一個 list 包裝此標籤和其參數。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;const&lt;/p&gt;
&lt;p&gt;根據 action 和 nargs 選項決定的定值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;default&lt;/p&gt;
&lt;p&gt;未輸入時的預設值，不受 type 選項的轉換。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;argparse.SUPPRESS&lt;/code&gt; 物件：若此選項沒有任何參數，不會建立這個選項。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;type&lt;/p&gt;
&lt;p&gt;轉換輸入值的類型，支援任何可呼叫(callable)的類型，預設為 string。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;open&lt;/code&gt;：這個類型可以開啟純文字格式的檔案。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;argparse.FileType('w')&lt;/code&gt;：argparse 也提供讀寫檔案的選項，作用同上。&lt;/li&gt;
&lt;li&gt;choices 選項會在 type 選項轉換完畢後才比對。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;choices&lt;/p&gt;
&lt;p&gt;比對輸入值的項目是否符合，可接受 list 與 generator，若否則跳出錯誤。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;required&lt;/p&gt;
&lt;p&gt;是否為必要標籤，預設為 False。若要啟用，將其設為 True 即可，Help 項目中會歸類成必要標籤。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;help&lt;/p&gt;
&lt;p&gt;當顯示 Help 項目時的說明文字，預設為空字串。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;'%(arg)s'&lt;/code&gt;：說明文字中可以引用其他選項，如 &lt;code&gt;%(default)s&lt;/code&gt;、&lt;code&gt;%(type)s&lt;/code&gt; 等，若要使用 &lt;code&gt;%&lt;/code&gt; 符號，可以用 &lt;code&gt;%%&lt;/code&gt; 表示。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;argparse.SUPPRESS&lt;/code&gt; 物件：這個標籤不會顯示在 Help 項目中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary><category term="Python3"></category></entry><entry><title>40323230日誌 - 106/03/05</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060305.html" rel="alternate"></link><published>2017-03-05T21:00:00+08:00</published><updated>2017-03-05T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-03-05:blog/40323230ri-zhi-1060305.html</id><summary type="html">&lt;p&gt;Leo editor 報告樣板&lt;/p&gt;


&lt;h1&gt;Leo editor 報告樣板&lt;/h1&gt;
&lt;p&gt;統整了一下之前在 Pyslvs 手冊的紀錄，將 Pandoc 和 Reveal.js 的整合放在 Github 倉儲。&lt;/p&gt;
&lt;p&gt;倉儲位址：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/KmolYuan/Leo-editor-report-template"&gt;https://github.com/KmolYuan/Leo-editor-report-template&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PDF 按鈕在儲存 Markdown 後使用，會存成一份內含英文目錄的 PDF 在 pdf 資料夾中。&lt;/li&gt;
&lt;li&gt;Reveal.js 按鈕會將文章處理後存到 html 的節點去，所以轉換完後要再存一次檔，才會寫入 html 中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相關設定皆可到個別 Cloned node 中修改。&lt;/p&gt;
&lt;p&gt;之後研究看看 pelican 或 Sphinx 輸出成說明網頁。&lt;/p&gt;
&lt;p&gt;接下來會參照學長的論文格式寫關於「電腦輔助設計（CAD）應用程式框架」、「平面機構解題」、「四連桿尺寸合成系統」的 paper。&lt;/p&gt;</summary><category term="pandoc"></category></entry><entry><title>40323230日誌 - 106/03/04</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060304.html" rel="alternate"></link><published>2017-03-04T21:00:00+08:00</published><updated>2017-03-04T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-03-04:blog/40323230ri-zhi-1060304.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Release version 0.5&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;Release version 0.5&lt;/h2&gt;
&lt;p&gt;釋出 Pyslvs version 0.5 穩定版。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0304_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;新功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用者介面改善。&lt;/li&gt;
&lt;li&gt;滑塊、伸縮桿鏈格功能。&lt;/li&gt;
&lt;li&gt;參數表格功能，能夠在節點、連桿、呆鍊表格中使用參數。&lt;/li&gt;
&lt;li&gt;大部分的表格都有復原與重做功能。&lt;/li&gt;
&lt;li&gt;輸出草圖或模型為 DXF 和 Solvespace 格式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 Github 上附有 Windows 平台 64 位元的自解壓縮包供下載（83.1 MB）。&lt;/p&gt;
&lt;p&gt;接下來 dev 的分支會先保留，供之後紀錄。&lt;/p&gt;
&lt;p&gt;Version 0.5 作為第一個穩定版（之前的版本沒除太多錯），撰寫報告會以這個版本為主。&lt;/p&gt;
&lt;p&gt;之後會將 Markdown 用 Pandoc 與 Leo Editor 轉檔的模板整理後放在公開倉儲。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/03/01</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060301.html" rel="alternate"></link><published>2017-03-01T21:00:00+08:00</published><updated>2017-03-01T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-03-01:blog/40323230ri-zhi-1060301.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DXF 輸出 - 2D 模型&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;DXF 輸出 - 2D 模型&lt;/h2&gt;
&lt;p&gt;新增這個功能匯出 2D 圖檔，可作為雷射切割使用。&lt;/p&gt;
&lt;p&gt;可用參數基本和 slvs 格式差不多，亦可自訂每個元件的間隙。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0301_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;這樣大量的 2D 圖形需要轉出時就很方便了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0301_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;有稍微花時間研究這個 DXF write 模組，似乎也能支援畫出 3D 的模型，可能是一個匯入 V-rep 的途徑？&lt;/p&gt;
&lt;p&gt;這週末整理好功能後會釋出 Version 0.5，包含在寒假進行的大量更動，比 Version 0.4 更穩定。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/02/28</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060228.html" rel="alternate"></link><published>2017-02-28T21:00:00+08:00</published><updated>2017-02-28T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-28:blog/40323230ri-zhi-1060228.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介面改進&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;介面改進&lt;/h2&gt;
&lt;p&gt;增加轉出格式的預覽圖。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0228_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;另外縮減了程式碼和修改 import PyQt5 模組的方式。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/02/27</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060227.html" rel="alternate"></link><published>2017-02-27T21:00:00+08:00</published><updated>2017-02-27T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-27:blog/40323230ri-zhi-1060227.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;slvs 格式 - 組立&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;p&gt;由於發現 Ubuntu 上的 Solvespace 是 whitequark 倉儲編的非穩定版，嘗試之後似乎有一些 3D 約束會閃退的狀況，之後再重裝 2016 年底的穩定版看看。&lt;/p&gt;
&lt;p&gt;所以先在 Windows 的舊版 Solvespace 上組合。&lt;/p&gt;
&lt;h2&gt;slvs 格式 - 組立&lt;/h2&gt;
&lt;p&gt;在 Windows 版的 Pyslvs 轉檔。&lt;/p&gt;
&lt;p&gt;之前以為 Linux 檔案結構的 &lt;code&gt;/&lt;/code&gt; 和 Windows 的反斜線會衝突，但是實際測試後發現 Python 的 os 模組和 Qt 的 QFileInfo 會按平台轉換，所以輸出沒問題。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0227_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;輸出後得到組合架構圖和連桿、呆鏈的 slvs 檔。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0227_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;首先將這些檔案一一點開重新存檔。&lt;/p&gt;
&lt;p&gt;舊版的 Solvespace 有跳出提示說這是新版格式的訊息，不過不影響解題。&lt;/p&gt;
&lt;p&gt;接著開啟組合架構圖，選擇 New Group &amp;gt; Import \ Assemble，匯入其他 slvs 檔。&lt;/p&gt;
&lt;p&gt;這時就可以利用 Constrain point to point、Parallel、Constrain point to plane 約束將匯入文件的草圖和底層的草圖相接。而將側邊點約束到草圖平面上可以防止零件滾動。&lt;/p&gt;
&lt;p&gt;一般來說，一個零件只要上述 3 個約束就能完全固定了。&lt;/p&gt;
&lt;p&gt;組立完成後，就能拉動驅動軸的連桿帶動全體了。&lt;/p&gt;
&lt;p&gt;下圖是組合完後的比對。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0227_03.png" /&gt;&lt;/p&gt;
&lt;p&gt;由於上面那張圖是第一次測試品，之後又組一隻腳的範例。&lt;/p&gt;
&lt;p&gt;這次有開中間軸選項（直徑為 2 單位）。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0227_04.png" /&gt;&lt;/p&gt;
&lt;p&gt;整個流程慢慢組的話不到 10 分鐘可以完成。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/02/26</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060226.html" rel="alternate"></link><published>2017-02-26T21:00:00+08:00</published><updated>2017-02-26T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-26:blog/40323230ri-zhi-1060226.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;slvs 格式 - 命名規則&lt;/li&gt;
&lt;li&gt;參數式設計&lt;/li&gt;
&lt;li&gt;新增一些範例&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;slvs 格式 - 命名規則&lt;/h2&gt;
&lt;p&gt;將命名的選項調整完善，如下圖把尺寸資訊編入檔名裡。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0226_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;再加上幾個測試應該就能使用全部的自訂選項了。&lt;/p&gt;
&lt;p&gt;另外還把組合圖第一層的草圖函式獨立出來，另外有選項可以單獨生成 2D slvs 檔案。&lt;/p&gt;
&lt;h2&gt;參數式設計&lt;/h2&gt;
&lt;p&gt;之前荒廢有點久的參數功能，因為表格統整等等項目還沒做好，所以都沒維護相關區域。&lt;/p&gt;
&lt;p&gt;後來寫好 QUndoCommand 後，統整好表格增刪功能，幾個函式的適應力更為活用，稍微增加判斷式就能接手 Parameter 的增删功能。&lt;/p&gt;
&lt;p&gt;所以現在 Parameter 表格也支援復原重做功能了。&lt;/p&gt;
&lt;p&gt;新增一個 n0 參數。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0226_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;新增一個點，座標打上 (n0, 0.0)。&lt;/p&gt;
&lt;p&gt;如下圖，點座標會自己對應到 (70.0, 0.0) 的位置。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0226_03.png" /&gt;&lt;/p&gt;
&lt;p&gt;原理是更新數據（將表格內容轉為 list 與 dict 儲存）時，會偵測 n 開頭的字元，並自動對應到 Parameter 的字典裡找尋。表格上的樣子是紀錄對應到哪個參數。&lt;/p&gt;
&lt;p&gt;若是使用該參數，並在之後刪除它，程式會在刪除前將該參數的代鏈換回它代表的數據。&lt;/p&gt;
&lt;p&gt;以上的流程都能任意復原重做，Parameter 的功能支援在節點、連桿、呆鍊的尺寸中使用。&lt;/p&gt;
&lt;p&gt;另外可能還有一些問題待處理，會再檢查一下。&lt;/p&gt;
&lt;h2&gt;新增一些範例&lt;/h2&gt;
&lt;p&gt;新增了一個滑塊的範例。&lt;/p&gt;
&lt;p&gt;另外還把葛式四連桿的路徑重 load 過，參考 PMKS 的範例。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/02/25</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060225.html" rel="alternate"></link><published>2017-02-25T21:00:00+08:00</published><updated>2017-02-25T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-25:blog/40323230ri-zhi-1060225.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;slvs 格式&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;slvs 格式&lt;/h2&gt;
&lt;p&gt;更新組合圖的輸出。&lt;/p&gt;
&lt;p&gt;使用一隻仿生獸的腳來當範例。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0225_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;輸出選項新增了「建立資料夾」的選項，不用再預先新增資料夾了。預設是工作簿的名稱。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0225_04.png" /&gt;&lt;/p&gt;
&lt;p&gt;接著會分別輸出零件檔（目前只有連桿和呆練）。若有勾選，會產生組合圖的檔案。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0225_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;在 Solvespace 開啟的組合檔，第一個線架構圖層已經生成了，可以使用滑鼠拉動，但是若是包含滑塊或伸縮桿，並不會有這兩者的約束。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0225_03.png" /&gt;&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/02/22</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060222.html" rel="alternate"></link><published>2017-02-22T21:00:00+08:00</published><updated>2017-02-22T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-22:blog/40323230ri-zhi-1060222.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;slvs 格式調整&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;p&gt;在 16.04 上編譯了新版的 Solvespace，除了一些如 &lt;code&gt;zlib1-dev&lt;/code&gt; 和 &lt;code&gt;libpng-dev&lt;/code&gt; 之類的舊套件無法安裝外，編譯過程順利。安裝在 /usr/share/ 中。&lt;/p&gt;
&lt;h2&gt;slvs 格式調整&lt;/h2&gt;
&lt;p&gt;之前鏈有試驗性地做出鏈桿的檔案，所以補上了呆鍊的部份。&lt;/p&gt;
&lt;p&gt;呆鍊有兩種樣式，分為整塊的 Sheet 板與 Form 支梁。&lt;/p&gt;
&lt;p&gt;下圖為支梁樣式在 Solvespace 中的樣子。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0222_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;Pyslvs 上的尺寸設定，有圓角直徑、厚度、孔徑、軸徑可調整。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0222_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;另還會有「產生組合圖」的選項，不過因為技術問題，沒法直接匯進其他零件。&lt;/p&gt;
&lt;p&gt;因此先暫時產生線架構的草圖，額外手動組裝。這部份最近幾天會開始做。&lt;/p&gt;
&lt;p&gt;還有必須注意零件檔是沒有 Surface 數據的，&lt;strong&gt;手動組裝時必須先用 Solvespace 開啟後再存檔一次&lt;/strong&gt;，才會產生數據。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/02/21</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060221.html" rel="alternate"></link><published>2017-02-21T21:00:00+08:00</published><updated>2017-02-21T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-21:blog/40323230ri-zhi-1060221.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面板調整&lt;/li&gt;
&lt;li&gt;伸縮桿面板&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;面板調整&lt;/h2&gt;
&lt;p&gt;所有面板做了以下調整：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由於一次只啟用 1個驅動軸 Shaft0，所以驅動軸面板將只支援控制 Shaft0 而已。&lt;/li&gt;
&lt;li&gt;所有面板改成當修改或刪除任何表格時強制關閉，新增則不受影響。&lt;/li&gt;
&lt;li&gt;使用者拉動滑桿調整展示角度或位置時，每改變一次位置，就會設置一個復原點。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;伸縮桿面板&lt;/h2&gt;
&lt;p&gt;類似活塞的功能（滑塊加上距離約束），通過這個面板可以調整滑動的位置。&lt;/p&gt;
&lt;p&gt;另外還有自訂距離範圍的功能，按下旁邊的 Reset 鈕可以重置上限和當前位置。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0221_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;顯示方面也做了一些改變，當有啟用「顯示標註」功能時，驅動軸和伸縮桿會顯示當前距離或角度。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/02/18</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060218.html" rel="alternate"></link><published>2017-02-18T21:00:00+08:00</published><updated>2017-02-18T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-18:blog/40323230ri-zhi-1060218.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介面小改進&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;p&gt;由於今天剛回學校，忙準備一些事，所以做的比較少。&lt;/p&gt;
&lt;h2&gt;介面小改進&lt;/h2&gt;
&lt;p&gt;一些介面上的小更動。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;右鍵選單歸類。&lt;/li&gt;
&lt;li&gt;編輯任何表格後都會關閉面板分頁，以免誤觸失去條件的面板。&lt;/li&gt;
&lt;li&gt;表格在新增後會自動捲到底，捲動方式從&lt;strong&gt;每格(ScrollPerItem)&lt;/strong&gt;改成&lt;strong&gt;每像素(ScrollPerPixel)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;批次移動和路徑追蹤的表單新增「加入全部」和「移除全部」鈕，樣式為雙箭頭 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;範例選單的狀態列會顯示範例編號。&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/02/17</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060217.html" rel="alternate"></link><published>2017-02-17T21:00:00+08:00</published><updated>2017-02-17T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-17:blog/40323230ri-zhi-1060217.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;批次移動&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;批次移動&lt;/h2&gt;
&lt;p&gt;將所選的節點群平移（原點不可選）。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0217_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;移動後採用「批次移動」命令包裝，內含這些點的修改指令。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0217_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;命令文字提示如下：&lt;/p&gt;
&lt;pre&gt;
Batch move {Point1, Point2, Point3, Point4, Point5}
- Moved (+0.00, -50.00)
&lt;/pre&gt;

&lt;p&gt;有了移動功能後，管理點座標會更為容易。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/02/16</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060216.html" rel="alternate"></link><published>2017-02-16T21:00:00+08:00</published><updated>2017-02-16T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-16:blog/40323230ri-zhi-1060216.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;節點關聯查詢&lt;/li&gt;
&lt;li&gt;取代點&lt;/li&gt;
&lt;li&gt;複製點&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;p&gt;從 Leo Editor 借鑒一些功能。&lt;/p&gt;
&lt;h2&gt;節點關聯查詢&lt;/h2&gt;
&lt;p&gt;鏈增一個面板，會顯示與個別節點相關的連桿、呆鍊等等。&lt;/p&gt;
&lt;p&gt;因為在刪除該節點時會把相關項目移掉免得出錯，所以就增加這個功能方便使用者檢視它們的關係。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0216_01.png" /&gt;&lt;/p&gt;
&lt;h2&gt;複製點&lt;/h2&gt;
&lt;p&gt;在滑鼠右鍵選單中增加複製點的功能。&lt;/p&gt;
&lt;p&gt;會新增一個與目標數據一樣的節點，初始顏色是橘色。&lt;/p&gt;
&lt;h2&gt;取代點&lt;/h2&gt;
&lt;p&gt;類似一般 IDE 的搜尋取代，可以把一個節點的所有關聯&lt;strong&gt;完全轉移&lt;/strong&gt;到另一個點上，但是如果發生約束衝突會導致解決失敗。&lt;/p&gt;
&lt;p&gt;這個功能也支援復原。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0216_02.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;準備再新增批次移動的功能供使用者調整選取的節點，可以將這些點平移到指定的增量。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/02/15</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060215.html" rel="alternate"></link><published>2017-02-15T21:00:00+08:00</published><updated>2017-02-15T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-15:blog/40323230ri-zhi-1060215.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;復原與重做功能 - 支援項目&lt;/li&gt;
&lt;li&gt;新增「歷史紀錄」分頁&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;復原與重做功能 - 支援項目&lt;/h2&gt;
&lt;p&gt;現在 Pyslvs 支援復原的命令如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全部表格的新增、編輯、刪除功能&lt;/li&gt;
&lt;li&gt;驅動軸的切換功能&lt;/li&gt;
&lt;li&gt;路徑追蹤的更新、清除功能&lt;/li&gt;
&lt;li&gt;路徑解題會以逐項添加實體的方式呈現&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外還有一些較細節的命令在製作中。&lt;/p&gt;
&lt;h2&gt;新增「歷史紀錄」分頁&lt;/h2&gt;
&lt;p&gt;這個分頁中有命令紀錄的表單，包含開啟檔案時讀取的動作。&lt;/p&gt;
&lt;p&gt;使用滑鼠點擊清單上的命令即可回溯，對開發設計很有幫助。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0215_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;影片展示&lt;/strong&gt;：&lt;/p&gt;
&lt;iframe width="640" height="360" src="https://www.youtube.com/embed/RJU0OUPQotk" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Arguments and Keywords in Python Function</title><link href="http://project.mde.tw/blog/arguments-and-keywords-in-python-function.html" rel="alternate"></link><published>2017-02-14T21:00:00+08:00</published><updated>2017-02-14T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-14:blog/arguments-and-keywords-in-python-function.html</id><summary type="html">&lt;p&gt;Python 函式的引數與關鍵字&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函式基本用法&lt;/li&gt;
&lt;li&gt;引數與關鍵字&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Python 函式的引數與關鍵字&lt;/h1&gt;
&lt;h2&gt;函式基本用法&lt;/h2&gt;
&lt;p&gt;一般的 Python 函式如下：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def AFunction(x, y, z):
    print(x, y, z)

a = 10
b = 20
c = 30
AFunction(a, b, c)
#10 20 30
&lt;/pre&gt;

&lt;p&gt;函式接收名稱（name），以在函式中利用之。&lt;/p&gt;
&lt;p&gt;另一種指定 name 的用法如下：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def AFunction(x=0, y=0, z=0):
    print(x, y, z)

a = 10
b = 20
AFunction(a, z=b)
#10  0  20
&lt;/pre&gt;

&lt;p&gt;規則：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指定預設數值的項目必須置於尾端。&lt;/li&gt;
&lt;li&gt;未指定的項目會依順序代入。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;若是接收數目與輸入不同，會 Raise 出 TypeError。&lt;/p&gt;
&lt;h2&gt;引數與關鍵字&lt;/h2&gt;
&lt;p&gt;Python 提供了使用 tuple、list、dict 來輸入函式，樣式和使用上與 C 語言類似，不過並不是代表指標（Pointer）的意思。&lt;/p&gt;
&lt;p&gt;有序排列的 tuple 和 list 使用星號 * 代表，稱為「引數（Arguments, args）」，會依序輸入或接收進函式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;純輸入&lt;/strong&gt;：接收端數量不對等會回傳錯誤。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def AFunction(x, y, z):
    print(x, y, z)

aList = [10, 20, 30]
AFunction(*aList)
#10  20  30
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;純接收&lt;/strong&gt;：型態為 tuple。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def AFunction(*aList):
    print(aList)

AFunction(10, 20, 30)
#(10, 20, 30)
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;輸入 + 接收&lt;/strong&gt;：數量必須調整與對應適當。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def AFunction(a, b, c, *aList):
    print(aList) #前三項不會顯示

AFunction(10, 20, *[30, 40, 50, 60])
#(40, 50, 60)
&lt;/pre&gt;

&lt;p&gt;使用索引的 dict 使用雙星號 ** 代表，稱為「關鍵字（Keywords, kwargs）」，會依名稱填入函式。名稱的部份&lt;strong&gt;規定必須使用 string 表示&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;純輸入&lt;/strong&gt;：接收端名稱不同、未指定預設值的項目沒輸入，皆會回傳錯誤。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def AFunction(x, y, z):
    print(x)

aList = {'x':10, 'y':20, 'z':30}
AFunction(**aList)
#10
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;純接收&lt;/strong&gt;：型態為 dict。注意&lt;strong&gt;輸入端都需要給名稱&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def AFunction(**aList):
    print(aList)

AFunction(c=10, a=20, b=30)
#{'a': 20, 'c': 10, 'b': 30}
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;輸入 + 接收&lt;/strong&gt;：名稱必須調整與對應適當。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def AFunction(missed, **aList):
    print(aList) #不會列出 missed

AFunction(a=10, b=20, **{'c':30, 'missed':40, 'd':50})
#{'a': 10, 'c': 30, 'b': 20, 'd': 50}
&lt;/pre&gt;

&lt;p&gt;引數與關鍵字是可以混合用的，不過兩者必須擺在接收端和輸入端的最後項。&lt;/p&gt;
&lt;p&gt;此時函式會照位置依序對應，再照引數依序對應，有名稱的項目最後才根據關鍵字對應。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def AFunction(x, y, *aList, **bList):
    print(aList)
    print(bList)

AFunction(0, u=10, y=20, *[30, 40], **{'z':50, 'w':60})
#TypeError: AFunction() got multiple values for argument 'y'
&lt;/pre&gt;

&lt;p&gt;以上錯誤就是因為第一個 0 和 [30, 40] 的 list 已經帶入 x 和 y，並且多出一個 40，而之後又追加一個 y 的名稱所致。&lt;/p&gt;
&lt;p&gt;善用這個功能，可以創造多變的輸入函式，應用到迴圈處理（如新增許多不同欄數的表格內容），不用再個別撰寫類似的函式流程。&lt;/p&gt;</summary><category term="Python3"></category></entry><entry><title>40323230日誌 - 106/02/13</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060213.html" rel="alternate"></link><published>2017-02-13T21:00:00+08:00</published><updated>2017-02-13T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-13:blog/40323230ri-zhi-1060213.html</id><summary type="html">&lt;p&gt;Qt 的復原與重做功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本功能&lt;/li&gt;
&lt;li&gt;QUndoStack 巨集&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;復原與重做功能&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Qt 的復原與重做功能&lt;/h1&gt;
&lt;p&gt;由於之前 Ubuntu 14.04 更新了 LiberOffice，沒想到 LiberOffice 的 Python 3.5 程式庫被 PyInstaller 錯認，導致在 Ubuntu 14.04 無法編譯出執行檔。&lt;/p&gt;
&lt;p&gt;於是最近幾天裝了第三個系統 Ubuntu 16.04 來編譯，並且整理合併了原本雜亂的 Table Widget 管理用函式，為復原與重做功能。&lt;/p&gt;
&lt;p&gt;參考資料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://doc.qt.io/qt-5/qundostack.html#beginMacro"&gt;http://doc.qt.io/qt-5/qundostack.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;基本功能&lt;/h2&gt;
&lt;p&gt;在 Qt 的程式中，使用下列類型管理指令以供復原。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;QUndoGroup&lt;/p&gt;
&lt;p&gt;統整不同區域，如個別視窗、Widget。每個區域用 QUndoStack 紀錄。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;QUndoStack&lt;/p&gt;
&lt;p&gt;統整不同的指令紀錄，如新增、刪除、編輯。每個指令用 QUndoCommand 紀錄。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;QUndoCommand&lt;/p&gt;
&lt;p&gt;代表想要復原的指令，指令中可以包含其他 QUndoCommand。每個指令都要有下列方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Redo - &lt;code&gt;QUndoCommand.redo()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;重做，可視為正指令，第一次呼叫會執行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Undo - &lt;code&gt;QUndoCommand.undo()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;復原，做出動作達成與 Redo 相反的狀態。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;由於 QUndoCommand 在 QUndoStack 必須順序執行，因此在指定位置上用當前的位置考慮就好。&lt;/strong&gt;如新增「最後一項」，Undo 時刪掉最後一項就好，不用擔心之後的指令造成這個項目不再是最後一項。&lt;/p&gt;
&lt;p&gt;至於編輯和刪除，&lt;strong&gt;要先紀錄刪除前的狀態（儲存到子項目），才能在 Undo 時加回來。&lt;/strong&gt;寫在 &lt;code&gt;self.__init__()&lt;/code&gt; 即可，會比 Redo 早執行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;呼叫 QUndoStack.push(&lt;code&gt;QUndoCommand()&lt;/code&gt;) 方法來執行 QUndoCommand 的 Redo 項目，同時將 QUndoCommand 加入紀錄中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;呼叫 QUndoStack.redo() 和 QUndoStack.undo() 方法來操作 QUndoCommand 的復原與重做。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要用 GUI 的方式查看並控制 QUndoStack，可以使用 QUndoView 這個 Widget。下面是一個只有 QUndoView 的 QDialog 懸浮窗，輸入對應的 stack 後，直接用滑鼠點擊可以馬上回到該階段。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
class commandWindow(QDialog):
    def __init__(self, stack, parent=None):
        super(commandWindow, self).__init__(parent)
        undoView = QUndoView(stack)
        undoView.setEmptyLabel("Start.")
        undoView.setAttribute(Qt.WA_QuitOnClose, False)
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.addWidget(undoView)
        self.setWindowTitle("Command List")
        self.setSizeGripEnabled(False)
        size = QSize(250, 200)
        self.setMinimumSize(size)
        self.setMaximumSize(size)
&lt;/pre&gt;

&lt;h2&gt;QUndoStack 巨集&lt;/h2&gt;
&lt;p&gt;QUndoStack 的巨集功能幫開發者可以錄製多個 QUndoCommand 組成的指令。&lt;/p&gt;
&lt;p&gt;原理就是建立一個空的 QUndoCommand，再將輸入的 QUndoCommand 建到這個指令下，在使用 count() 方法回傳命令數時，這種巨集只算 1 個指令。&lt;/p&gt;
&lt;p&gt;使用 beginMacro() 方法時，該 QUndoStack 所有項目都會凍結，包含 undo() 都會無法使用，直到使用 endMacro()。&lt;/p&gt;
&lt;p&gt;使用方式：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
stack.beginMacro("複合指令") #開始錄製
stack.push(AFunction()) #紀錄第一個 QUndoCommand
print("複合指令執行中") #一般程式不會影響
stack.push(BFunction()) #紀錄第二個 QUndoCommand
stack.endMacro() #結束錄製
&lt;/pre&gt;

&lt;p&gt;這樣下 undo() 方法就會一次倒敘 AFunction() 和 BFunction() 回去。&lt;/p&gt;
&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;復原與重做功能&lt;/h2&gt;
&lt;p&gt;參照一些簡單的範例達成了復原功能，並且在 Command line 上的 print 字樣也有所標示。&lt;/p&gt;
&lt;p&gt;不過還沒把一些更新功能轉成 QUndoCommand，所以暫時無法使用懸浮窗控制，全都加入後會預設啟用懸浮窗。&lt;/p&gt;
&lt;p&gt;下圖是載入檔案後編輯連桿的長度。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0213_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;Z&lt;/kbd&gt; 復原。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0213_02.png" /&gt;&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/02/10</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060210.html" rel="alternate"></link><published>2017-02-10T21:00:00+08:00</published><updated>2017-02-10T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-10:blog/40323230ri-zhi-1060210.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Slider 功能修正&lt;/li&gt;
&lt;li&gt;容量縮減&lt;/li&gt;
&lt;li&gt;防呆措施&lt;/li&gt;
&lt;li&gt;轉出 3D 模型&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;Slider 功能修正&lt;/h2&gt;
&lt;p&gt;將滑塊功能從 1 連桿上的 1 點改成 2 點間的 1 點定義。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0210_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;只是 Solvespace kernel 處理上仍有些不妥，若是如上圖旋轉中心與這 2 點共線，&lt;strong&gt;會讓 Point3 在一定距離內被鎖到旋轉中心上，因為這樣也符合條件。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;容量縮減&lt;/h2&gt;
&lt;p&gt;讓許多對話方塊共用同 ui，如一般的新增／編輯視窗共用。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0210_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;所有的警告視窗都刪除，替代成防呆措施或 QMessageBox（如：未存檔警告）。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0210_03.png" /&gt;&lt;/p&gt;
&lt;p&gt;Windows 編譯時複製的 kernel 也改成只複製 py35w 的，不過減量效果較有限，從 386 MB 縮減到 377 MB。&lt;/p&gt;
&lt;h2&gt;防呆措施&lt;/h2&gt;
&lt;p&gt;實體和模擬的警告視窗都移除了，改成符合條件才會允許建立或修改這些約束。&lt;/p&gt;
&lt;p&gt;例如下圖中的新增視窗 start 和 end 選到了相同的節點，OK 鈕就會變成 Disable 狀態。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0210_04.png" /&gt;&lt;/p&gt;
&lt;h2&gt;轉出 3D 模型&lt;/h2&gt;
&lt;p&gt;由於目前暫時沒有 Solvespace Surface 功能的程式庫，最近會先嘗試做出 OBJ 的轉檔功能。&lt;/p&gt;
&lt;p&gt;Solvespace 格式 import 只支援自己的 *.slvs 檔比較可惜，必要的話得看一下原始碼的內容作編譯。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/02/09</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060209.html" rel="alternate"></link><published>2017-02-09T21:00:00+08:00</published><updated>2017-02-09T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-09:blog/40323230ri-zhi-1060209.html</id><summary type="html">&lt;p&gt;關於 Solvespace 的 3D 格式&lt;/p&gt;


&lt;h1&gt;關於 Solvespace 的 3D 格式&lt;/h1&gt;
&lt;p&gt;這幾天研究了 fourbarlinkage 和 jasen_8link 的檔案。&lt;/p&gt;
&lt;p&gt;使用純「拉伸」群組的檔案結構如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0209_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;「組合圖」的檔案結構如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0209_03.png" /&gt;&lt;/p&gt;
&lt;p&gt;這兩個 project 的組立都是將零件匯入，並約束到「組合圖」的草圖中。&lt;/p&gt;
&lt;p&gt;若是只改動連桿的長度，該零件 &lt;code&gt;.slvs&lt;/code&gt; 格式的變動如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0209_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;雖然其中包含一些 20 位小數造成的誤差，但是主要的內容都是紀錄運算結果。&lt;/p&gt;
&lt;p&gt;也因為如此，就算其中有缺損，Solvespace 仍能依據主要實體重新算好結果，存檔時重新存入檔案中。&lt;/p&gt;
&lt;p&gt;這些運算結果也包含拉伸出的表面，尤其是弧線的分段計算，每個 1/2 圓弧都會分為 4 等分計算，所以一個完整圓會有 8 段 Curve（平面的 4 等分座標都在一直線上），這些數據就是分段點的當前座標。&lt;/p&gt;
&lt;p&gt;不過這些算好的數據並不是給當前檔案看的，而是拿來&lt;strong&gt;匯入&lt;/strong&gt;用的，倘若缺少這些數據，使用它們的「組合圖」就會發生缺損，而且回溯結構時會變紅字。&lt;/p&gt;
&lt;p&gt;而「組合圖」也會將子項目的數據複製一份存起來，給更大的「組合圖」使用。&lt;/p&gt;
&lt;p&gt;然而，「組合圖」要讀取的這些數據不能有錯誤的答案（因為本身沒有該實體），否則該曲線關聯的 Surface 會消失變成破面。&lt;/p&gt;
&lt;p&gt;Python-solvespace 的模組沒有加入 Surface 的相關功能，所以沒辦法求出結果。&lt;/p&gt;
&lt;p&gt;目前的進度為可以透過 GUI 用迴圈導出 &lt;code&gt;*.slvs&lt;/code&gt; 的零件檔案，但是因為上述問題，無法做成組合圖。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0209_04.png" /&gt;&lt;/p&gt;
&lt;p&gt;不知是否需要加入 Solvespace Surface 的相關功能還是找其他格式（如 OBJ file）解決。&lt;/p&gt;
&lt;p&gt;已測試可以在 V-rep 中使用 blender 匯出的模型。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0209_05.png" /&gt;&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/02/07</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060207.html" rel="alternate"></link><published>2017-02-07T21:00:00+08:00</published><updated>2017-02-07T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-07:blog/40323230ri-zhi-1060207.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Leo Editor - 簡單的節點控制&lt;/p&gt;
&lt;p&gt;簡述 Leo Editor 的 @button 節點運用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Generators&lt;/li&gt;
&lt;li&gt;Position Getters&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 手冊應用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 目標 - 模型銜接 V-rep&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Leo Editor - 簡單的節點控制&lt;/h1&gt;
&lt;p&gt;參考資料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://leoeditor.com/cheatsheet.html#scripting"&gt;http://leoeditor.com/cheatsheet.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注：一些方法（method）可以利用 Leo 的自動完成功能（&lt;kbd&gt;Alt&lt;/kbd&gt; + &lt;kbd&gt;1&lt;/kbd&gt;）尋找。&lt;/p&gt;
&lt;h2&gt;Generators&lt;/h2&gt;
&lt;p&gt;一些常用的 generator。&lt;/p&gt;
&lt;p&gt;Python 的 generator 使用方式：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
pList = [e.copy() for e in c.all_positions()]
&lt;/pre&gt;

&lt;p&gt;&lt;a href="http://project.mde.tw/blog/40323230ri-zhi-1060204.html"&gt;上一篇文章&lt;/a&gt; 提到了不要直接使用 generator 來下指令，否則會出現 &lt;code&gt;&amp;lt;pos 139770197424392 [0] None&amp;gt;&lt;/code&gt; 回傳值為 None 的情形。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在一般情形下，@button 中的 &lt;code&gt;p&lt;/code&gt; 為「當前節點」而非「該 @button 節點」的 position，應當特別注意。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;c.all_positions()
    依序回傳大綱所有節點的 position，包含的子項目會跟在父節點之後。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;c.all_unique_positions()
    依序回傳大綱所有節點的 position，包含的子項目會跟在父節點之後，但是分身節點只會回傳一次。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p.children()
    依序回傳該 position 子節點的 position。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p.parents()
    依序（由底開始）回傳該 position 父節點的 position。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p.self_and_parents()
    依序（由底開始）回傳該 position 父節點的 position，第一次會回傳自身。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p.self_and_siblings()
    依序回傳該 position 同層級節點的 position。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p.following_siblings()
    依序回傳該 position 下方同層級節點的 position。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p.subtree()
    依序回傳該 position 子孫節點的 position，包含的子孫項目會跟在父節點之後。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p.self_and_subtree()
    依序回傳該 position 子孫節點的 position，包含的子孫項目會跟在父節點之後，第一次會回傳自身。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Position Getters&lt;/h2&gt;
&lt;p&gt;一些常用的 Getter。&lt;/p&gt;
&lt;p&gt;這些方法回傳 position 的週邊資訊，上面提過的 Generator 將不再說明 。&lt;/p&gt;
&lt;p&gt;Python 的方法可以使用多層（只要確定非空值）：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
B = p.next().firstChild().b
&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;p.back()
    回傳該 position 上方一個節點的 position。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p.next()
    回傳該 position 下方一個節點的 position。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p.firstChild()
    回傳該 position 第一個子節點的 position。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p.lastChild()
    回傳該 position 最後一個子節點的 position。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p.parent()
    回傳該 position 第一個父節點的 position。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p.level()
    回傳該 position 的層級整數（int）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;至於 position 的新增、移動、刪除方法使用後會如同修改 vnode，發生大綱樹不會即時更新的情形（無法選擇更新後節點、不會提醒儲存以及存檔後不會編輯檔案節點），必須重新存檔才能更新大綱樹。也因為如此不符合 @button 的功能需求，因此就不介紹了。&lt;/p&gt;
&lt;h1&gt;Pyslvs 手冊應用&lt;/h1&gt;
&lt;p&gt;縮減了原先的語法，使用 Leo 提供的 generator，變得更易懂。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
pList = [e.copy() for e in c.all_positions()] #節點參照
hList = [e.h for e in c.all_positions()] #索引
MD = pList[hList.index("@clean {}.md".format(filename))] #找到 Markdown file
pos = hList.index("{} Target node".format(filename)) #目標
B = [e.b for e in MD.self_and_subtree()]
B = ''.join(B).replace("%", "##").replace("\n@language md", '').replace("\n@others", '').replace("*@fig:", '').split("\n\n\\newpage")
head = """&lt;section&gt;
&lt;section data-markdown data-separator="^\\n&lt;!--===--&gt;\\n"&gt;
&lt;script type="text/template"&gt;"""
tail = """
&lt;/script&gt;
&lt;/section&gt;
&lt;/section&gt;
"""
B = [head+e+tail for e in B]
pList[pos].b = removeParentheses("@language html\n"+'\n'.join(B))
g.es("{} HTML 簡報轉換完畢".format(filename))
&lt;/pre&gt;

&lt;h1&gt;Pyslvs 目標 - 模型銜接 V-rep&lt;/h1&gt;
&lt;p&gt;為了達成 Pyslvs 的「2D 線條」轉成 V-rep 能用的「3D 支架」（或是連桿之類的），要在接下來的版本做出這個功能。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0207_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;由於 STL 是三角形接合的立體物件，要憑空畫出 3D 支架的組合圖，想知道這方面的資料。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/02/04</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060204.html" rel="alternate"></link><published>2017-02-04T21:00:00+08:00</published><updated>2017-02-04T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-04:blog/40323230ri-zhi-1060204.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Leo Editor - 簡單的節點控制&lt;/p&gt;
&lt;p&gt;簡述 Leo Editor 的 @button 節點運用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;預先定義名稱：c、g、p&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Vnode&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Position&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Generator&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 @button 複製節點正文&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 手冊應用&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Leo Editor - 簡單的節點控制&lt;/h1&gt;
&lt;p&gt;參考資料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://leoeditor.com/tutorial-scripting.html#predefined-symbols-c-g-and-p"&gt;http://leoeditor.com/tutorial-scripting.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://leoeditor.com/tutorial-scripting.html#predefined-symbols-c-g-and-p"&gt;http://leoeditor.com/scripting.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;預先定義名稱：c、g 和 p&lt;/h2&gt;
&lt;p&gt;在可執行腳本中預先定義的符號 c、g 和 p。&lt;/p&gt;
&lt;p&gt;c 為包含腳本大綱的 &lt;strong&gt;commander&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Commander 為指令類別的實體（instance），在 &lt;code&gt;leoCommands.py&lt;/code&gt; 文件中定義。&lt;/li&gt;
&lt;li&gt;Commander 提供了所有大綱資料與 Leo 原始碼的權限。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;g 為 Leo 的 leo.core.leoGlobals 模組。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;這個模組包含許多實用的函式，如 &lt;code&gt;g.es&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;p 是當前選擇節點的 &lt;strong&gt;position&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;position 為位置類別的實體，在 &lt;code&gt;leoNodes.py&lt;/code&gt; 文件中定義。&lt;/li&gt;
&lt;li&gt;位置類型提供安全、方便的方式來存取與修改大綱節點。&lt;/li&gt;
&lt;li&gt;對於任何位置的 &lt;code&gt;p&lt;/code&gt;，&lt;code&gt;p.v&lt;/code&gt; 是一個 &lt;strong&gt;vnode&lt;/strong&gt; 物件。&lt;/li&gt;
&lt;li&gt;vnode 包含所有在 Leo 大綱的永久資料。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Vnode&lt;/h2&gt;
&lt;p&gt;vnode 為 vnode 類別的實體，在 &lt;code&gt;leoNodes.py&lt;/code&gt; 文件中定義。每個 vnode 代表關聯著一個大綱節點的&lt;em&gt;所有&lt;/em&gt;資訊，包含著&lt;em&gt;專用&lt;/em&gt;數據帶有它的大鋼結構。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;v.b 是（大綱）節點的正文（body text）。&lt;/li&gt;
&lt;li&gt;v.h 是節點的標題（headline）。&lt;/li&gt;
&lt;li&gt;v.u 是節點的&lt;strong&gt;使用者資訊&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;所有分身節點共用同一個 vnode。&lt;/strong&gt;反之，每個 vnode 表示出所有分身相應的節點。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0204_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;由於&lt;em&gt;單一個&lt;/em&gt; vnode 可以代表&lt;em&gt;多個&lt;/em&gt;大綱節點，直接使用 vnode 會變得較尷尬。這就是為何出現 position：&lt;strong&gt;position 簡化對 vnode 的存取。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;Position&lt;/h2&gt;
&lt;p&gt;一個 position 代表一個具體的大綱節點在大綱一個精確的位置上，position 為位置類別的實體，在 &lt;code&gt;leoNodes.py&lt;/code&gt; 文件中定義。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在位置 &lt;code&gt;p&lt;/code&gt; 上的 vnode 就是 &lt;code&gt;p.v&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;由於所有分身共用一樣的 vnode，多個 position 可能會擁有一樣的 &lt;code&gt;p.v&lt;/code&gt; 內容。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p.b&lt;/code&gt;、&lt;code&gt;p.h&lt;/code&gt;、&lt;code&gt;p.u&lt;/code&gt; 代表著 &lt;code&gt;p.v.b&lt;/code&gt;、&lt;code&gt;p.v.h&lt;/code&gt;、&lt;code&gt;p.v.u&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;對於任何一個 Commander &lt;code&gt;c&lt;/code&gt;，&lt;code&gt;c.p&lt;/code&gt; 為當前選擇的節點。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;position 常因為大綱結構改變而變成無效。&lt;/strong&gt;腳本應當只在確保大綱結構不會發生任何改變時儲存位置以供稍後使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;c.positionExists(p)&lt;/code&gt; 會在 &lt;code&gt;c.p&lt;/code&gt; 仍為有效值時回傳 True。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0204_02.png" /&gt;&lt;/p&gt;
&lt;h2&gt;Generator&lt;/h2&gt;
&lt;p&gt;Leo 的 Generator 即為 Python generator，這些 generator 追蹤（逐漸地）Leo 大綱的一個個節點：&lt;strong&gt;Leo generators yield 出一個位置序列。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;命令（commander）和位置類別定義了數個 generator，&lt;code&gt;c.all_positions()&lt;/code&gt; 隨著大綱順序追蹤大綱。下面的程式 print 出正確縮排的標題清單。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
for p in c.all_positions():
    print(' '*p.level()+p.h)
&lt;/pre&gt;

&lt;p&gt;Leo generator &lt;strong&gt;yield&lt;/strong&gt;（回傳一個環節）出 position。它們&lt;em&gt;不會&lt;/em&gt;回傳一個實際的 list；這為大型的大綱節省了不少空間。事實上，這個位置序列其實是一個&lt;strong&gt;單一&lt;/strong&gt;、&lt;strong&gt;不斷變化位置&lt;/strong&gt;的序列。這是一個非常重要的空間優化。&lt;/p&gt;
&lt;p&gt;當一個 generator 已經回傳完成，這個單一位置變成了一個&lt;strong&gt;空的 position&lt;/strong&gt;。&lt;code&gt;p.v&lt;/code&gt; 會在空的 position 為 None。這裡有正確及錯誤的方式測試空的 position。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
if not p:       # Right
if not p.v:     # Right
if p is None:   # Wrong!
&lt;/pre&gt;

&lt;p&gt;為了避免上述情形，應當使用 &lt;code&gt;copy()&lt;/code&gt; 方法複製 vnode 與 position 類型的物件，再予以修改。&lt;/p&gt;
&lt;h2&gt;使用 @button 複製節點正文&lt;/h2&gt;
&lt;p&gt;自己做了一個按鈕程式來應用 Leo editor 的腳本功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目標&lt;/strong&gt;：將 I 節點下的 Hellow World! 文章改名複製到 J 節點下。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0204_03.png" /&gt;&lt;/p&gt;
&lt;p&gt;由於還不太熟悉 Leo 的 generator，先用比較生疏的方式指定目標。&lt;/p&gt;
&lt;p&gt;複製節點文章程式：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
pList = [e.copy() for e in c.all_positions()]
nList = [e.h for e in c.all_nodes()]
bList = [e.b for e in c.all_nodes()]
Istart = nList.index("I")+1
Iend = nList.index("i-c")+1
Jstart = nList.index("J")+1
Jend = nList.index("j-c")+1
B = bList[Istart:Iend]
P = pList[Jstart:Jend]
B = [e.replace('i', 'j') for e in B]
for e in range(len(P)): P[e].b = B[e]
g.es('Copied!')
&lt;/pre&gt;

&lt;p&gt;清空節點文章程式：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
pList = [e.copy() for e in c.all_positions()]
nList = [e.h for e in c.all_nodes()]
Jstart = nList.index("J")+1
Jend = nList.index("j-c")+1
P = pList[Jstart:Jend]
for e in range(len(P)): P[e].b = ''
g.es('Cleaned!')
&lt;/pre&gt;

&lt;p&gt;列出 position 和 vnode 程式：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
pList = [str(e.copy()) for e in c.all_positions()]
nList = [str(e.copy()) for e in c.all_nodes()]
g.es('\n'.join(pList))
g.es('\n'.join(nList))
&lt;/pre&gt;

&lt;h1&gt;Pyslvs 手冊應用&lt;/h1&gt;
&lt;p&gt;使用 Leo editor 的腳本功能達成轉換 Pandoc 特殊語法。&lt;/p&gt;
&lt;p&gt;目前功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;及時裁切處理 Markdown 文件，輸出 Reveal.js 的 Markdown + html 語法到指定節點（Target node）。&lt;/li&gt;
&lt;li&gt;切開 &lt;code&gt;\newpage&lt;/code&gt; 記號成水平投影片。&lt;/li&gt;
&lt;li&gt;圖片參照記號移除，但是內文的還未解決。&lt;/li&gt;
&lt;li&gt;其他皆按照 data-markdown 的功能排版。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;程式還有些雜亂，之後會整修一下。&lt;/p&gt;
&lt;p&gt;轉換程式：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
pList = [e.copy() for e in c.all_positions()]
nList = [e.h for e in c.all_nodes()]
bList = [e.b for e in c.all_nodes()]
Istart = nList.index("@clean {}.md".format(filename))
Iend = nList.index("@clean reveal.js/{}.html".format(filename))
pos = nList.index("{} Target node".format(filename))
B = bList[Istart:Iend]
P = pList[pos]
B[0] = B[0].replace("%", "##")+"\n\\newpage"
B = ''.join(B).replace("\n@language md", '').replace("\n@others", '').split("\n\n\\newpage")
head = """&lt;section&gt;
&lt;section data-markdown data-separator="^\\n&lt;!--===--&gt;\\n"&gt;
&lt;script type="text/template"&gt;"""
tail = """
&lt;/script&gt;
&lt;/section&gt;
&lt;/section&gt;
"""
B = [head+e+tail for e in B]
P.b = removeParentheses("@language html\n"+'\n'.join(B))
g.es("{} HTML 簡報轉換完畢".format(filename))
&lt;/pre&gt;

&lt;p&gt;移除圖片參照專用函式 &lt;code&gt;removeParentheses()&lt;/code&gt;：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def removeParentheses(content):
    while content.find("{")!=-1:
        start = content.find("{")
        end = content.find("}")+1
        result = content[start:end]
        content = content.replace(result, '')
    return content
&lt;/pre&gt;

&lt;p&gt;轉換過程不會用到外部程式，三份 html 文件都是共用同一份 js 檔案。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/02/03</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060203.html" rel="alternate"></link><published>2017-02-03T21:00:00+08:00</published><updated>2017-02-03T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-03:blog/40323230ri-zhi-1060203.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Leo Editor - Pyslvs 手冊 - Reveal.js&lt;/p&gt;
&lt;p&gt;兩種方式轉成 Reveal.js 樣板：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Leo Editor Cloned Node&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pandoc - Template&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pelican 的 Pandoc Plugin&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Leo Editor - Pyslvs 手冊 - Reveal.js&lt;/h1&gt;
&lt;p&gt;為了達成使用相同內容達成一樣的效果，所以找了兩種方法，目前各有優缺，暫時都保留。&lt;/p&gt;
&lt;h2&gt;Leo Editor Cloned Node&lt;/h2&gt;
&lt;p&gt;使用 Leo Editor 的分身節點套用相同的內容，並用 data-markdown 讀取；原始碼中會包含為轉換的 Markdown 語法。&lt;/p&gt;
&lt;p&gt;不過這種方式無法分章節（水平投影片），因此每個章節都需要分身，否則會讀取到 LaTex 的換頁標記。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0203_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;優點&lt;/strong&gt;是可以自由裁切投影片長度（使用自訂記號），而且完全不會影響 Pandoc 的讀取。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0203_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺點&lt;/strong&gt;是不能使用使用圖片參照，可能還要另外想辦法或是捨棄這種用法。&lt;/p&gt;
&lt;p&gt;還有一個較小的&lt;strong&gt;缺點&lt;/strong&gt;是使用記號裁切後，分開的超連結內容會被脫離，必須在裁切前補上註釋，而 Pandoc 可能也會警告重複轉換的內容。&lt;/p&gt;
&lt;h2&gt;Pandoc - Template&lt;/h2&gt;
&lt;p&gt;在 Github 上找到有人寫的 Template 檔，讓 Pandoc 直接轉好 index.html，而且認得圖片參照與特殊用法。&lt;/p&gt;
&lt;p&gt;倉儲位址：&lt;a href="https://gist.github.com/aaronwolen/5017084"&gt;https://gist.github.com/aaronwolen/5017084&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用的指令：&lt;/p&gt;
&lt;pre&gt;
$pandoc -t html5 --template=template-revealjs.html \
  --standalone --section-divs \
  --variable transition="linear" \
  example.md -o example.html
&lt;/pre&gt;

&lt;p&gt;主要使用 &lt;code&gt;--section-divs&lt;/code&gt; 配上 &lt;code&gt;-t html5&lt;/code&gt; 並套用 Reveal.js 的套件轉出。&lt;/p&gt;
&lt;p&gt;轉出來的樣式如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0203_03.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺點&lt;/strong&gt;明顯就是「小節」會依附在「章」中，每一頁都會有「章」的開頭文字擋住。&lt;/p&gt;
&lt;h1&gt;Pelican 的 Pandoc Plugin&lt;/h1&gt;
&lt;p&gt;Pelican 部分有找到相關的擴充套件 pandoc_reader。&lt;/p&gt;
&lt;p&gt;倉儲位址：&lt;a href="https://github.com/liob/pandoc_reader"&gt;https://github.com/liob/pandoc_reader&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;還沒測試過效果，不過會使用到 command line 的 Pandoc，應該能套用原本的 Markdown 文件。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/02/02</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060202.html" rel="alternate"></link><published>2017-02-02T21:00:00+08:00</published><updated>2017-02-02T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-02:blog/40323230ri-zhi-1060202.html</id><summary type="html">&lt;p&gt;Leo Editor - Pyslvs 手冊&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Pandoc - PDF&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Reveal.js - HTML 簡報&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Leo Editor - Pyslvs 手冊&lt;/h1&gt;
&lt;p&gt;目前以 Leo Editor 編輯 Markdown 檔案，為了讓章節更分明，用 node 的方式統整內容。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0202_01.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;匯出的 PDF 輸出在 &lt;code&gt;/PDF&lt;/code&gt; 資料夾內，而 Reveal.js 則是放在 &lt;code&gt;/reveal.js&lt;/code&gt; 資料夾內。&lt;/p&gt;
&lt;p&gt;至於 Pelican 的部份還沒研究樣板的關係，暫時未加入。&lt;/p&gt;
&lt;h2&gt;Pandoc - PDF&lt;/h2&gt;
&lt;p&gt;這部份使用 Pandoc 的命令匯出，在語法上會用到擴展的功能，Pelican 和 Reveal.js 可能不會支援。&lt;/p&gt;
&lt;p&gt;在 Leo Editor 中設計了 3 個按鈕轉檔，Python code 判斷平台與字型，Windows 採用&lt;strong&gt;標楷體&lt;/strong&gt;；Ubuntu 後來由&lt;strong&gt;文泉驛微米黑&lt;/strong&gt;改成&lt;strong&gt;教育部標準楷書&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0202_04.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;Python code 使用 Clone node 的方式，使三本手冊套用一樣的設定輸出。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
import os, platform
if platform.system().lower()=="linux": font = "教育部標準楷書"
elif platform.system().lower()=="windows": font = "DFKai-SB"
else: font = "Arial"
fontsize = "12"
margin = "1in"
settingFlag = "--latex-engine=xelatex --toc --filter pandoc-fignos --template=template.tex -V \"mainfont:{0}\" -V fontsize={1}pt -V geometry:margin={2}".format(font, fontsize, margin)
os.system("pandoc {0}.md -o PDF/{0}.pdf {1}".format(filename, settingFlag))
g.es("{} PDF 轉換完畢".format(filename))
&lt;/pre&gt;

&lt;p&gt;只有名稱 filename 使用不同字串而已。&lt;/p&gt;
&lt;h2&gt;Reveal.js - HTML 簡報&lt;/h2&gt;
&lt;p&gt;Reveal.js 若是要使用 Markdown 語法，必須先將 markdown plugin 加回來。&lt;/p&gt;
&lt;p&gt;啟動時使用：&lt;/p&gt;
&lt;pre class="brush: java"&gt;
Reveal.initialize({
    dependencies: [
        { src: 'plugin/markdown/marked.js' },
        { src: 'plugin/markdown/markdown.js' },
        { src: 'plugin/notes/notes.js', async: true },
        { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
    ]
});
&lt;/pre&gt;

&lt;p&gt;並且從 &lt;a href="https://github.com/hakimel/reveal.js"&gt;官方倉儲&lt;/a&gt; 載回 &lt;code&gt;lib&lt;/code&gt; 資料夾。&lt;/p&gt;
&lt;p&gt;編寫 index.html 時使用下面的語法：&lt;/p&gt;
&lt;pre class="brush: html"&gt;
&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
        Markdown 文字
    &lt;/script&gt;
&lt;/section&gt;
&lt;/pre&gt;

&lt;p&gt;並利用 Clone node 與原文件同步。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0202_02.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;使用後的樣式如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0202_03.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;另外還有需要換頁的問題，官方提供的語法可以自動分行、輸入現成 md 檔等等。&lt;/p&gt;
&lt;pre class="brush: html"&gt;
&lt;section data-markdown="example.md"  
     data-separator="^\n\n\n"  
     data-separator-vertical="^\n\n"  
     data-separator-notes="^Note:"  
     data-charset="iso-8859-15"&gt;
&lt;/section&gt;
&lt;/pre&gt;

&lt;p&gt;不過遇到 Pandoc 語法（如圖片參照）就沒辦法使用了。而針對換頁，可能還需要斟酌嵌入方式，或是在原文件中加入特殊 html 註解換頁。&lt;/p&gt;
&lt;p&gt;至於 Pelican 的 Markdown 應該也和 Reveal.js 一樣，只是不需要分頁。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Qt5 - Ubuntu switch Fcitx input method</title><link href="http://project.mde.tw/blog/qt5-ubuntu-switch-fcitx-input-method.html" rel="alternate"></link><published>2017-01-24T21:00:00+08:00</published><updated>2017-01-24T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-01-24:blog/qt5-ubuntu-switch-fcitx-input-method.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;解決 Ubuntu 平台無法在 Qt5 切換 Fcitx 輸入法的問題&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;解決 Ubuntu 平台無法在 Qt5 切換 Fcitx 輸入法的問題&lt;/h1&gt;
&lt;p&gt;參考資料：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cnblogs.com/cposture/p/5397694.html"&gt;http://www.cnblogs.com/cposture/p/5397694.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用 Python 3 啟動 Leo editor、QtCreator，甚至是自己的 PyQt 專案時，會發生無法在視窗內使用英文以外的輸入法。&lt;/p&gt;
&lt;p&gt;在 Qt4 時，這個功能可以直接在 Qt Setting 中選擇。Qt5 則是依賴「fcitx-qt5」這個套件，使用 apt 檢查時，會顯示已經安裝並為最新版。&lt;/p&gt;
&lt;p&gt;但是安裝 Qt 時的 fcitx-qt5 套件沒有對應到作業系統的 Fcitx 版本時，就要手動 make 了。&lt;/p&gt;
&lt;p&gt;在編譯 fcitx-qt5 前，先確認已經安裝最新的 CMake。&lt;/p&gt;
&lt;p&gt;示範的 Qt 安裝位置為 &lt;code&gt;/opt/Qt/&lt;/code&gt;，版本為 5.6，請根據自身版本做調整。&lt;/p&gt;
&lt;p&gt;這些流程在 14.04 和 16.04 中是大同小異的，並沒有太大分別。&lt;/p&gt;
&lt;h1&gt;編譯 fcitx-qt5&lt;/h1&gt;
&lt;p&gt;從官方倉儲下載 fcitx-qt5，進入該資料夾中：&lt;/p&gt;
&lt;pre&gt;
$git clone https://github.com/fcitx/fcitx-qt5
$cd fcitx-qt5
&lt;/pre&gt;

&lt;p&gt;接著準備編譯 fcitx-qt5。&lt;/p&gt;
&lt;pre&gt;
$cmake .
$make
$sudo make install
&lt;/pre&gt;

&lt;p&gt;在使用 CMake 時會發生如下問題。&lt;/p&gt;
&lt;h2&gt;extra-cmake-modules&lt;/h2&gt;
&lt;p&gt;錯誤訊息：&lt;/p&gt;
&lt;pre&gt;
CMake Error at CMakeLists.txt:8 (find_package):
Could not find a package configuration file provided by "ECM" (requested
  version 1.4.0) with any of the following names:
ECMConfig.cmake
ecm-config.cmake
  Add the installation prefix of "ECM" to CMAKE_PREFIX_PATH or set "ECM_DIR"
  to a directory containing one of the above files.  If "ECM" provides a
  separate development package or SDK, be sure it has been installed.
-- Configuring incomplete, errors occurred!
&lt;/pre&gt;

&lt;p&gt;到下面網址下載 CMake 額外模組：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://launchpad.net/ubuntu/+source/extra-cmake-modules/1.4.0-0ubuntu1"&gt;https://launchpad.net/ubuntu/+source/extra-cmake-modules/1.4.0-0ubuntu1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解壓縮進入，編譯並安裝模組。編譯前必須指定 CMAKE_PREFIX_PATH 位置到 Qt GCC 的 CMake 上。&lt;/p&gt;
&lt;pre&gt;
$export CMAKE_PREFIX_PATH="/opt/Qt/5.6/gcc_64/lib/cmake/"
$cmake .
$make
$sudo make install
&lt;/pre&gt;

&lt;h2&gt;xkbcommon&lt;/h2&gt;
&lt;p&gt;錯誤訊息：&lt;/p&gt;
&lt;pre&gt;
-- Found PkgConfig: /usr/bin/pkg-config (found version "0.26") 
-- Could NOT find XKBCommon_XKBCommon (missing:  XKBCommon_XKBCommon_LIBRARY XKBCommon_XKBCommon_INCLUDE_DIR) 
CMake Error at /usr/share/cmake-2.8/Modules/FindPackageHandleStandardArgs.cmake:108 (message):
  Could NOT find XKBCommon (missing: XKBCommon_LIBRARIES XKBCommon) (Required is at least version "0.5.0")
&lt;/pre&gt;

&lt;p&gt;到 &lt;a href="http://xkbcommon.org/"&gt;http://xkbcommon.org/&lt;/a&gt; 下載最新的穩定版本。&lt;/p&gt;
&lt;p&gt;解壓縮後進入資料夾，安裝時需要用到 bison 套件。&lt;/p&gt;
&lt;pre&gt;
$sudo apt-get install bison
$./configure --prefix=/usr --libdir=/usr/lib/x86_64-linux-gnu --disable-x11
$make
$sudo make install
&lt;/pre&gt;

&lt;h1&gt;安裝 fcitx-qt5&lt;/h1&gt;
&lt;p&gt;若順利執行 CMake 並成功編譯，會在 &lt;code&gt;platforminputcontext&lt;/code&gt; 出現 fcitx-qt5 的程式庫，名為 &lt;code&gt;libfcitxplatforminputcontextplugin.so&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;接著刪除 Qt 內的 fcitx-qt5 套件：&lt;/p&gt;
&lt;pre&gt;
$sudo rm -f /opt/Qt/5.6/gcc_64/plugins/platforminputcontexts/libfcitxplatforminputcontextplugin.so
$sudo rm -f /opt/Qt/Tools/QtCreator/lib/Qt/plugins/platforminputcontexts/libfcitxplatforminputcontextplugin.so
&lt;/pre&gt;

&lt;p&gt;然後進入 &lt;code&gt;platforminputcontext&lt;/code&gt; 資料夾，先讓該程式庫「可執行化」後再複製。&lt;/p&gt;
&lt;pre&gt;
$sudo chmod +x libfcitxplatforminputcontextplugin.so
$sudo cp libfcitxplatforminputcontextplugin.so /opt/Qt/5.6/gcc_64/plugins/platforminputcontexts/
$sudo cp libfcitxplatforminputcontextplugin.so /opt/Qt/Tools/QtCreator/lib/Qt/plugins/platforminputcontexts/
&lt;/pre&gt;

&lt;p&gt;然後設定 Qt5 的預設輸入法為 Fcitx。&lt;/p&gt;
&lt;p&gt;直接執行下面這兩個命令，若是登出或重新開機失效，則要到 .bashrc 文件中加入。&lt;/p&gt;
&lt;pre&gt;
$export XMODIFIERS=@im=fcitx
$export QT_IM_MODULE=fcitx
&lt;/pre&gt;

&lt;p&gt;重新啟動 Qt 相關的程式，便能使用 Fcitx 切換其他輸入法了。&lt;/p&gt;</summary><category term="PyQt5"></category><category term="Leo Editor"></category></entry><entry><title>Pelican - Windows Python Error</title><link href="http://project.mde.tw/blog/pelican-windows-python-error.html" rel="alternate"></link><published>2017-01-22T21:00:00+08:00</published><updated>2017-01-22T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-01-22:blog/pelican-windows-python-error.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;解決 ValueError: embedded null byte 錯誤&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;解決 ValueError: embedded null byte 錯誤&lt;/h1&gt;
&lt;p&gt;一直以來，某些使用 Python 3.5（無論 Anaconda 與否）的 Windows 電腦會無法使用 Pelican 轉換網誌。&lt;/p&gt;
&lt;p&gt;於是加入 &lt;code&gt;--debug&lt;/code&gt; 指令檢查。&lt;/p&gt;
&lt;pre&gt;
    ...

    File "c:\users\...\pelican\utils.py", line 101, in strftime
        return super(SafeDatetime, self).strftime(fmt)
ValueError: embedded null byte
&lt;/pre&gt;

&lt;p&gt;重新搜尋了這個問題，找到了一篇新的文章：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://xingjian.me/how-to-fix-value-error-embedded-null-byte-error.html"&gt;http://xingjian.me/how-to-fix-value-error-embedded-null-byte-error.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;於是到 cmd 的 Python 直譯器打入下列指令檢查：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
import locale, time
locale.setlocale(locale.LC_ALL, 'ko')
time.strftime('%a')
&lt;/pre&gt;

&lt;p&gt;Python Rise 了相同的錯誤如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0122_01.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;解決方式就是重新設定 local 的設定。&lt;/p&gt;
&lt;p&gt;到 Python 或 Anaconda 的資料夾中找到 pelican，編輯其 utils.py 檔案（如：&lt;code&gt;Python35\Lib\site-packages\pelican\utils.py&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;搜尋 &lt;code&gt;def strftime(date, date_format)&lt;/code&gt; 這個函式。&lt;/p&gt;
&lt;p&gt;在函式這片註解後加入 &lt;code&gt;locale.setlocale(locale.LC_ALL, 'en')&lt;/code&gt; 指令，如下：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def strftime(date, date_format):
    '''
    Replacement for built-in strftime

    ...

    This works by 'grabbing' possible format strings (those starting with %),
    formatting them with the date, (if necessary) decoding the output and
    replacing formatted output back.
    '''
    locale.setlocale(locale.LC_ALL, 'en')
&lt;/pre&gt;

&lt;p&gt;之後存檔關閉即可。&lt;/p&gt;
&lt;p&gt;接著就能使用 Pelican 的功能了。&lt;/p&gt;</summary><category term="Pelican"></category><category term="Leo Editor"></category></entry><entry><title>40323230日誌 - 106/01/20</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060120.html" rel="alternate"></link><published>2017-01-20T21:00:00+08:00</published><updated>2017-01-20T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-01-20:blog/40323230ri-zhi-1060120.html</id><summary type="html">&lt;p&gt;Pyslvs version 0.4 Relese&lt;/p&gt;


&lt;h1&gt;Pyslvs version 0.4 Relese&lt;/h1&gt;
&lt;p&gt;最終在轉動軸的設定中加入修正選項，並優化 csv 的儲存格式。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0120_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;v0.4 版的功能如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;包含完整編譯流程的 Makefile。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加入演算法，讓使用者可以依據路徑需求生成四連桿的結果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之後會開始完成技術文件和在 v0.5 版中補完之前的目標。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/01/19</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060119.html" rel="alternate"></link><published>2017-01-19T21:00:00+08:00</published><updated>2017-01-19T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-01-19:blog/40323230ri-zhi-1060119.html</id><summary type="html">&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;平行軸 Bug&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;平行軸 Bug&lt;/h2&gt;
&lt;p&gt;Version 0.4 準備收工，最近陸陸續續修正了一些界面的合理性問題，並且測試了一下目前的範本運作情形。&lt;/p&gt;
&lt;p&gt;除了之前提到演算法可能出現結果錯誤之外，在葛式四連桿的範例中找到一直沒解決的問題。&lt;/p&gt;
&lt;p&gt;「平行四邊形」的連桿範例為機架、三根連桿長皆相等的模型，如下圖：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0119_01.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;在理想狀況下，兩個從動節點的路徑應為兩個半徑相等的正圓。&lt;/p&gt;
&lt;p&gt;不過 Solvespace 的 kernel 卻會造成下面的情況（單純用滑鼠繞行）：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0119_02.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;花了一些時間，寫了一小串校正函式，但是會造成其他範例出現不應該出現的反轉。&lt;/p&gt;
&lt;p&gt;下圖是 Pyslvs 出現相同的狀況：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0119_03.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;預計在 Shaft 加入最後一個功能，「平行機件」的選項，可以讓對稱的範例順利執行。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/01/16</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060116.html" rel="alternate"></link><published>2017-01-16T21:00:00+08:00</published><updated>2017-01-16T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-01-16:blog/40323230ri-zhi-1060116.html</id><summary type="html">&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;拖放檔案開啟功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;反轉 Y 軸初始位置功能&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;拖放檔案開啟功能&lt;/h2&gt;
&lt;p&gt;參考資料：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://doc.qt.io/qt-5/dnd.html"&gt;http://doc.qt.io/qt-5/dnd.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以透過 Qt 的拉入事件「dragEnterEvent」和拖放事件「dropEvent」達成。&lt;/p&gt;
&lt;p&gt;這次只有讓外部資訊拖入，若要讓內部資訊脫出需要其他設置，不過這個功能或許會應用到其他部份，所以先作筆記。&lt;/p&gt;
&lt;p&gt;當 QWidget 設定允許拖放動作 &lt;code&gt;setAcceptDrops(true)&lt;/code&gt; 後，就能使用滑鼠攜帶資訊，滑鼠游標會變成拖放樣式而非禁止符號。&lt;/p&gt;
&lt;p&gt;透過拉入事件「dragEnterEvent」可以允許「哪些資訊」可以被拖入，如字串、圖片、網址和檔案位址。&lt;/p&gt;
&lt;p&gt;拖放事件「dropEvent」可以設定拖入後要執行的動作。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def dragEnterEvent(self, event):
    mimeData = event.mimeData()
    if mimeData.hasUrls():
        for url in mimeData.urls():
            FilePath = url.toLocalFile()
            if QFileInfo(FilePath).suffix()=="csv": event.acceptProposedAction()

def dropEvent(self, event):
    FilePath = event.mimeData().urls()[-1].toLocalFile()
    self.checkChange(FilePath, [], "Loaded drag-in file:\n"+FilePath)
    event.acceptProposedAction()
&lt;/pre&gt;

&lt;p&gt;上面的 dragEnterEvent 先判斷 QEvent 的攜帶資訊 mimeData 是否為副檔名「csv」的 URL，接著才會通過檢查（&lt;code&gt;acceptProposedAction()&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;後面的 dropEvent 則是取出想要的檔案位址並開啟，若是一次選取多個檔案則只開啟最後一個。&lt;/p&gt;
&lt;h2&gt;反轉 Y 軸初始位置功能&lt;/h2&gt;
&lt;p&gt;在選定的連桿上按下滑鼠右鍵可以根據固定軸反轉 Y 軸座標的初始位置，若是沒有固定軸，就反轉終點的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0116_01.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;以下是反轉之後重繪的路徑圖。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0116_02.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;透過這個功能能夠手動修正初始位置，不過若是能夠自動檢查並修正會比較好。&lt;/p&gt;
&lt;p&gt;過幾天應該能開始寫開發手冊。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/01/15</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060115.html" rel="alternate"></link><published>2017-01-15T21:00:00+08:00</published><updated>2017-01-15T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-01-15:blog/40323230ri-zhi-1060115.html</id><summary type="html">&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路徑演算法功能&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;路徑演算法功能&lt;/h2&gt;
&lt;p&gt;Pyslvs 生成曲柄搖桿的步驟：&lt;/p&gt;
&lt;iframe width="640" height="360" src="https://www.youtube.com/embed/wjdBAlF9u4Y" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;鏈
演算法算出的結果有兩種形式：&lt;/p&gt;
&lt;p&gt;一個呆鍊的方向朝上，主動軸（短軸）在左方，為學長論文中的模型。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_sol鏈espace/0115_01.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;另一個呆鍊的端點朝下，主動軸在右方，剛好跟上述的情況相反。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0115_02.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;雖在轉換式中做了些修正，但是有時仍然會發生 Solvespace kernel 解決失敗的情況。&lt;/p&gt;
&lt;p&gt;大約原因應該是初始位置帶來的困擾。由於是讀取 C++ 程式庫的問題，若是學 C 語言即時運算會造成 QPainter 畫布閃爍問題（不過還不知道 QGraphicsView 的效果），之後想在發布 Version 0.4 前做一個理想化初始位置的功能。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/01/14</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060114.html" rel="alternate"></link><published>2017-01-14T21:00:00+08:00</published><updated>2017-01-14T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-01-14:blog/40323230ri-zhi-1060114.html</id><summary type="html">&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;程式 - 求解轉換函式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;界面 - 演算法結果說明文字&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;程式 - 求解轉換函式&lt;/h2&gt;
&lt;p&gt;利用演算法得出的解需要經過 Solvespace kernel 的轉換才能得到點座標，不過之前的函式沒經過考慮，會重複許多流程，因此將函式合併，當提供相應值時會回傳需要的解。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
pathTrackProcess = not angle==None
staticProcess = not table_point==None
generateConversionProcess = not generateResult==None
...
if pathTrackProcess:
    try: return x, y
    except: return 0, 0
elif staticProcess:
    try: return resultList, sys.dof, script
    except: return list(), -1, str()
elif generateConversionProcess:
    try: return resultList
    except: return list()
&lt;/pre&gt;

&lt;p&gt;另外編出 Python Script 的部份縮減很多，只會提供表格的點座標和約束讓使用者利用。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0114_01.jpg" /&gt;&lt;/p&gt;
&lt;h2&gt;界面 - 演算法結果說明文字&lt;/h2&gt;
&lt;p&gt;由於做出預覽會造成 QPaint 畫布需要處理很多項目，所以未來使用 QGraphicsView 畫布時再補回去。&lt;/p&gt;
&lt;p&gt;當 Path Solving 面板算出結果後會將資料存入待審清單中，滑鼠移上去時可以看到使用演算法、AD點座標、運算時間等等數據。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0114_02.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;剩下上述的轉換函式、點擊 Merge 鈕加入表單的功能。&lt;/p&gt;
&lt;p&gt;完成並驗證演算法流程後，即會發布 Version 0.4。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/01/05</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060105.html" rel="alternate"></link><published>2017-01-05T21:00:00+08:00</published><updated>2017-01-05T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-01-05:blog/40323230ri-zhi-1060105.html</id><summary type="html">&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;界面調整 - 面板&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;編譯 - Makefile&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;界面調整 - 面板&lt;/h2&gt;
&lt;p&gt;當初構想的清單原本也是置頂的視窗，但是後來發現在 Windows 中開啟會導致清單視窗 crash，所以將一些額外的面板合併到點座標的分頁去。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0105_01.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;不過這些面板插入分頁後排版不太人性化，之後還會再修正。&lt;/p&gt;
&lt;h2&gt;編譯 - Makefile&lt;/h2&gt;
&lt;p&gt;最後還是統一兩個版本都使用 Makefile 來編譯，方便 Windows 可攜的版本下指令，只要使用下列語句即可分辨平台：&lt;/p&gt;
&lt;pre&gt;
ifeq ($(OS),Windows_NT)
#執行 Windows 編譯
else
#執行 Linux 編譯
endif
&lt;/pre&gt;

&lt;p&gt;另外在 Readme 上也有做修正。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/01/04</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060104.html" rel="alternate"></link><published>2017-01-04T21:00:00+08:00</published><updated>2017-01-04T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-01-04:blog/40323230ri-zhi-1060104.html</id><summary type="html">&lt;p&gt;Pyslvs 編譯進度 - 演算法 - Windows 版編譯：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;演算法函式庫除錯&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;編譯方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 編譯進度 - 演算法 - Windows 版編譯&lt;/h1&gt;
&lt;h2&gt;演算法函式庫除錯&lt;/h2&gt;
&lt;p&gt;之前嘗試過在 Widows 平台編譯學長的 Cython 函式庫，但是使用 MinGW 和 VS 都出錯，於是上網了解一下關鍵原因。&lt;/p&gt;
&lt;p&gt;在官方說明中提到，目前尚未支援 Windows 的 64 位元 GNU，而使用 MinGW32 的話，會造成 64 位元的 Python 無法輸入或讀取任何資訊（進位制不同）。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/cython/cython/wiki/CythonExtensionsOnWindows#less-useful-information"&gt;https://github.com/cython/cython/wiki/CythonExtensionsOnWindows#less-useful-information&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因此在 Windows 平台中只能使用微軟提供的 SDK 協助編譯了。&lt;/p&gt;
&lt;p&gt;使用 Visual Studio Community 客戶端安裝 Windows SDK 即可，若是 Python 認不得 2012 以上的版本，必須編輯 Anaconda 的 Lib\distutils\ 資料夾中的 &lt;code&gt;cygwinccompiler.py&lt;/code&gt;，在大約 85 行的位置插入以下程式碼：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
elif msc_ver == '1700':
    # Visual Studio 2012 / Visual C++ 11.0
    return ['msvcr110']
elif msc_ver == '1800':
    # Visual Studio 2013 / Visual C++ 12.0
    return ['msvcr120']
elif msc_ver == '1900':
    # Visual Studio 2015 / Visual C++ 14.0
    return ['vcruntime140']
&lt;/pre&gt;

&lt;p&gt;Cython 在編譯時才會找到 SDK 的工具。&lt;/p&gt;
&lt;p&gt;編譯後，執行 test.py 時出現了類似 &lt;code&gt;IndexError: index 250 is out of bounds for axis 0...&lt;/code&gt; 的訊息，顯示某個 List 超出可讀取範圍。&lt;/p&gt;
&lt;p&gt;在不斷測試與檢查之後發現是 Cython 從 C 語言 import 的 random 函數有問題。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from libc.stdlib cimport rand, RAND_MAX, srand

cdef double randV():
    return rand()*1.0 / RAND_MAX
&lt;/pre&gt;

&lt;p&gt;這個是產生亂數用的 function，在 Windows 下，回傳值某些時候會大於 1，這就導致長度 250 的 list 出現 &lt;code&gt;[250]&lt;/code&gt; 的選項。&lt;/p&gt;
&lt;p&gt;為了避免這個狀況發生，改寫上面的函式成下面的樣子：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
cdef double randV():
    randomNum = rand()*1.0 / RAND_MAX
    if randomNum&gt;=1: randomNum -= 0.1
    return randomNum
&lt;/pre&gt;

&lt;p&gt;這裡使用迭代運算而非重新指定值，速度會比較快一點。&lt;/p&gt;
&lt;p&gt;需要修改的檔案為 &lt;code&gt;rga.pyx&lt;/code&gt; 和 &lt;code&gt;de.pyx&lt;/code&gt;，其他函式庫都沒問題。&lt;/p&gt;
&lt;p&gt;但是因為 Windows 平台多加了判斷式，還有其他因素，運算時間慢上 1 倍（中間的螢火蟲演算法完全相同）。以下是相同題目的運算結果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0104_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0104_02.jpg" /&gt;&lt;/p&gt;
&lt;h2&gt;編譯方法&lt;/h2&gt;
&lt;p&gt;由於加入了 Cython 的程式庫，原本的編譯方式又沒辦法使用了，會出現「pythoncom」匯入的錯誤。&lt;/p&gt;
&lt;p&gt;用兩種方式重新編譯後，發現在 PyInstaller 的資料夾（dist）中執行它的主程式，會顯示找不到 py35w 的核心。&lt;/p&gt;
&lt;p&gt;於是就將 cxFreeze 的 core 資料夾複製到 PyInstaller 的資料夾中，再啟動主程式就可以使用了，也不會出現任何錯誤。&lt;/p&gt;
&lt;p&gt;此方法已經套用到 winBuild.bat 中。&lt;/p&gt;
&lt;p&gt;目前暫時將 PyInstaller 的 -w 參數拿掉，方便在 Windows 平台查看 console 資訊。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/01/02</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060102.html" rel="alternate"></link><published>2017-01-02T21:00:00+08:00</published><updated>2017-01-02T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-01-02:blog/40323230ri-zhi-1060102.html</id><summary type="html">&lt;p&gt;Pyslvs 編譯進度 - 演算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;介面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程式&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 編譯進度 - 演算法&lt;/h1&gt;
&lt;h2&gt;介面&lt;/h2&gt;
&lt;p&gt;稍微改寫介面：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0102_01.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;加入可以控制部份限制值的功能，並做好回傳結果的 dictionary 分類。&lt;/p&gt;
&lt;p&gt;考慮之後，最後還是拿回進度條，做成流動的樣式（最大最小值設為 0 即可）。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0102_02.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;除了現在的視窗外，之後還會加入第二個較小的清單窗格供使用者挑選，切換清單選擇項目時即可預覽，點選「合併」按鈕即可合併至畫布。&lt;/p&gt;
&lt;h2&gt;程式&lt;/h2&gt;
&lt;p&gt;測試不同組座標放入，發現超過當初預設的數目時，kernel 會報錯。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
p = len(path)
upperVal = Limits[0]+[360.0]*p
lowerVal = Limits[1]+[0.0]*p
Parm_num = p+9
&lt;/pre&gt;

&lt;p&gt;這裡 p 代表座標的數量，upperVal 和 lowerVal 是限制值的組合（共 9 項）加上後面點座標的轉動可能性。&lt;/p&gt;
&lt;p&gt;Parm_num 會帶入三種演算法的 nParm、D 位置，必須等於 upperVal 和 lowerVal 的長度。&lt;/p&gt;
&lt;p&gt;比較好奇的是最後回傳的 fitnessParameter 長度會剛好等於 Parm_num，而且前 9 項是 Ax、Ay、Dx、Dy、L0、L1、L2、L3、L4 的答案，後面都是超過範圍的 float 數值，不知道代表含意。&lt;/p&gt;
&lt;p&gt;預覽的部份比較複雜，因為當前的 Solvespace 解題 function 是針對左邊的表單寫的，若是拿來運算 3 個未知點的圖形，必須改寫帶入參數。&lt;/p&gt;
&lt;p&gt;單機演算法解題的部份預計寒假初完成，釋出 Version 0.4.0，寒假進行中會加入平行運算，並同時完成其他項目。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/01/01</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060101.html" rel="alternate"></link><published>2017-01-01T21:00:00+08:00</published><updated>2017-01-01T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-01-01:blog/40323230ri-zhi-1060101.html</id><summary type="html">&lt;p&gt;Pyslvs 編譯進度 - 演算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程式&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 編譯進度 - 演算法&lt;/h1&gt;
&lt;h2&gt;程式&lt;/h2&gt;
&lt;p&gt;將編譯好的 so 函式庫放到 kernel 資料夾的 pyslvs_generate 資料夾中，一樣是分開版本。&lt;/p&gt;
&lt;p&gt;跟 Path track 與普通解題函式一起放在 calculation.py 中。&lt;/p&gt;
&lt;p&gt;載入選擇：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
if platform.system().lower()=="linux":
    if py_nm=="3.4":
        from ..kernel.pyslvs_generate.py34 import tinycadlib
        from ..kernel.pyslvs_generate.py34.planarlinkage import build_planar
        from ..kernel.pyslvs_generate.py34.rga import Genetic
        from ..kernel.pyslvs_generate.py34.firefly import Firefly
        from ..kernel.pyslvs_generate.py34.de import DiffertialEvolution
    if py_nm=="3.5":
        from ..kernel.pyslvs_generate.py35 import tinycadlib
        from ..kernel.pyslvs_generate.py35.planarlinkage import build_planar
        from ..kernel.pyslvs_generate.py35.rga import Genetic
        from ..kernel.pyslvs_generate.py35.firefly import Firefly
        from ..kernel.pyslvs_generate.py35.de import DiffertialEvolution
&lt;/pre&gt;

&lt;p&gt;這裡必須額外載入 tinycadlib 函式庫。&lt;/p&gt;
&lt;p&gt;在同層目錄下，planarlinkage 函式庫可以搜尋到 tinycadlib 函式庫，但是當用外部位置載入時，被包起來的 so 檔會找不到原本存在的名稱，所以額外載入 tinycadlib 供其使用。&lt;/p&gt;
&lt;p&gt;當使用 Path solving panel 後可以回傳數據，但是無法回傳進度，要有這個功能可能得改寫演算法。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0101_01.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;選擇演算方法的部份是切換式的，一次只能儲存一組解。如果空間允許，可能建一個清單儲存結果。&lt;/p&gt;
&lt;p&gt;至於 Windows 方面則完全封鎖功能，編譯時會跳過整個 Path solving 的相關函式。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/12/29</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051229.html" rel="alternate"></link><published>2016-12-29T21:00:00+08:00</published><updated>2016-12-29T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-12-29:blog/40323230ri-zhi-1051229.html</id><summary type="html">&lt;p&gt;Pyslvs 編譯進度 - 演算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;編譯&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 編譯進度 - 演算法&lt;/h1&gt;
&lt;h2&gt;編譯&lt;/h2&gt;
&lt;p&gt;倉儲：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/40323230/pyslvs_generate-1" title="github.com"&gt;https://github.com/40323230/pyslvs_generate-1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;將演算法的原始碼統整，並為其 Makefile 添加 clean 指令。&lt;/p&gt;
&lt;p&gt;接著就 test.py 範例檔研究了一下，將原本回傳的字串全部改成 float 型態的 list，並且調整了一些顯示方式。&lt;/p&gt;
&lt;p&gt;將結果轉換為浮點數：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
a = [k for k in map(lambda x: [float(i) for i in x.split(',')[1::]],[e for e in time_and_fitness.split(';')[0:-1]])]
b = [float(e) for e in fitnessParameter.split(',')]
print(a)
print(b)
&lt;/pre&gt;

&lt;p&gt;X 和 Y 座標的部份之後再做處理，可以確保的是能夠從整個字串中取回數值，回傳至 Pyslvs 時再做篩選。&lt;/p&gt;
&lt;p&gt;目前在 14.04 和 16.04 的 Python 3.4 和 3.5 測試都運作良好，Windows 還沒試過。&lt;/p&gt;
&lt;p&gt;Linux 編譯流程：&lt;/p&gt;
&lt;p&gt;進入 &lt;code&gt;Tinycad_package&lt;/code&gt; 目錄下。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$sudo&lt;/span&gt; pip3 install Cython
&lt;span class="nv"&gt;$make&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在該目錄下會編譯出可用的動態連結庫，將其移出就能讓 Python 程式碼使用。&lt;/p&gt;
&lt;p&gt;接著就要讓 Pyslvs 使用演算法解題。&lt;/p&gt;
&lt;p&gt;目前測試解題速度平均 25 秒左右，舊電腦 35 秒左右。&lt;/p&gt;
&lt;p&gt;會試圖研究 Windows 版的編譯方式，最後會像 Python Solvespace 的 kernel 一樣偵測平台和 Python 版本作切換。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/12/26</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051226.html" rel="alternate"></link><published>2016-12-26T21:00:00+08:00</published><updated>2016-12-26T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-12-26:blog/40323230ri-zhi-1051226.html</id><summary type="html">&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基因演算法 - 反解機構流程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;復原重做功能計畫構思&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Solvespace 格式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 圖示&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;基因演算法 - 反解機構流程&lt;/h2&gt;
&lt;p&gt;做好第二個需要運算用的 panel，不過還沒套入基因演算法的 function 和 kernel，所以目前是存一個必經點的 list 給 QThread 在背景運算（或有其他可變項目），算完後預計用淺色的機構圖形展示結果，使用者可以決定是否需要合併到畫布上，亦或清除後重新計算一個結果。&lt;/p&gt;
&lt;p&gt;Path Solving 這個面板是置頂的，會紀錄一個需要經過點的 list，關閉視窗後還在，除非重新啟動主程式；會考慮是否將「設計中」項目一起存進檔案中。&lt;/p&gt;
&lt;p&gt;當面板開啟後，畫布的右鍵選單就能加入路徑點（不過還沒做出路徑點的顯示），或是自定座標。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1226_01.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;按下 Generate button 就會開始計算，回傳機構數據，並預覽在畫布上。&lt;/p&gt;
&lt;p&gt;合併的功能還需要想一下，畢竟 Solvespace 還需要初始座標，如果定的不好又會產生問題，所以必須稍微想一下。&lt;/p&gt;
&lt;h1&gt;Solvespace 格式&lt;/h1&gt;
&lt;p&gt;之前一直放置的原因就是因為 Qt 表格的字串沒有轉換格式，現在因為有分門別類的 list 儲存實體和約束，所以會比較好設計。&lt;/p&gt;
&lt;p&gt;最近有空會試試看重寫一下 Solvespace 的格式，讓 Pyslvs 可以完美支援輸出回 Solvespace 做參照。&lt;/p&gt;
&lt;h1&gt;復原重做功能計畫構思&lt;/h1&gt;
&lt;p&gt;使用 Qt 的 undo 功能的話就得做多種「命令」格式，如果加入「命令」的時機太過底層，就會被非預期的命令呼叫到，例如讀檔和手動加入點座標是使用同一個 function。&lt;/p&gt;
&lt;p&gt;所以盡量使用比較簡潔的命令。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;表格處理方面：增、刪、編輯、上下移、修改 point style。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面板方面：路徑追蹤功能、驅動軸改的 demo angle、未來的 Path Solving。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外有機會的話考慮做視窗的 undo list。&lt;/p&gt;
&lt;h1&gt;Pyslvs 圖示&lt;/h1&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1226_02.png" /&gt;&lt;/p&gt;
&lt;p&gt;稍微設計了 Pyslvs 的圖示，對應 Python 的顏色風格。&lt;/p&gt;
&lt;p&gt;Windows 方面有 256 x 256 大小的 ico 檔案可以使用。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/12/22</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051222.html" rel="alternate"></link><published>2016-12-22T21:00:00+08:00</published><updated>2016-12-22T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-12-22:blog/40323230ri-zhi-1051222.html</id><summary type="html">&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;移除需求提示視窗&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;雙平台編譯流程&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;移除需求提示視窗&lt;/h2&gt;
&lt;p&gt;將大量當前不可用的命令 Disable，取代之前跳出的「不符鏈要求」提示視窗。&lt;/p&gt;
&lt;p&gt;例如建立一個三角呆鍊需要 3 個連接點，如果點的表單沒有 3 個以上的點，會以紅字顯示需要的項目。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1222_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;而編輯、刪除、上下移、轉換等等功能，雖然沒有說明，但是也必須符合條件時才會顯示或啟用。&lt;/p&gt;
&lt;p&gt;至於路徑規劃、驅動軸等等面板，也都有相應的需求才能使用按鈕。&lt;/p&gt;
&lt;p&gt;這個顯示的偵測是每次修改表格時，比以往按下產生一個新的對話視窗省資源。&lt;/p&gt;
&lt;h2&gt;雙平台編譯流程&lt;/h2&gt;
&lt;p&gt;Version 0.4 在 Github 的 Readme 中，寫上了 Linux 和 Windows 平台編譯出 Pyslvs 可執行檔的說明。&lt;/p&gt;
&lt;p&gt;Linux 可以用 PyInstaller 或 cxFreeze 的 CLI（cxFreeze 不支援 Windows）直接編譯（擇一即可）。&lt;/p&gt;
&lt;p&gt;而 Windows 方面寫了一個批次檔（名為 &lt;code&gt;winBuild.bat&lt;/code&gt;），可以編好兩個工具生成的檔案後合併，並已經指定好程式的圖示檔；有安裝必須工具的情況下能直接點兩下執行，在可攜環境必須用 command line 執行。&lt;/p&gt;
&lt;p&gt;不過 Windows 版執行檔無法觀看文字回應（不會有 print），不過可以用參數命令正常開啟檔案、使用 Fusion 介面。&lt;/p&gt;
&lt;p&gt;有試過工具安裝本機的情況下編譯 Windows 版本，但是仍不能只用單一工具，可能是 PyInstaller 和 cxFreeze 互有優缺吧。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/12/21</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051221.html" rel="alternate"></link><published>2016-12-21T21:00:00+08:00</published><updated>2016-12-21T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-12-21:blog/40323230ri-zhi-1051221.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs v0.4 預計目標&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 緊急修正&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs v0.4 預計目標&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;於分支 dev0.4 中開發&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;釋出 version 0.3 後，整個軟體大致的雛型已經出現了，不過在範例和轉檔部分仍然需要改進。&lt;/p&gt;
&lt;p&gt;而另外需要進行的重大改進，包含以下目標：&lt;/p&gt;
&lt;h2&gt;可互動物件的畫布&lt;/h2&gt;
&lt;p&gt;這部分可能需要為「需要顯示」的項目歸類，包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;點（特殊標示：固定軸／滑塊）鏈鏈&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;連桿（特殊標示：驅動軸／滑塊軌道）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;呆鍊&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;路徑點（特殊標示：作用中路徑）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這些物件可能要分別做不同的類型，並且要擁有現在 QPainter 的特性（例如更換顏色），需要協同的需求性滿高的。&lt;/p&gt;
&lt;h2&gt;復原重做功能&lt;/h2&gt;
&lt;p&gt;這個部分正在著手製作，在部屬上較麻煩而已。&lt;/p&gt;
&lt;p&gt;分為下列幾個功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;表格新增復原（所有表格）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表格刪除復原（所有表格）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表格調整次序復原（驅動軸）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;物件外觀復原（必須配合新的畫布做調整）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Undo 與 Redo 功能是每個有存檔需求的軟體都必須要的項目，未來可能其他 project 可能也會應用到，所以會優先完成，並會把 Qt 的概念和使用方式做一篇整理。&lt;/p&gt;
&lt;h2&gt;基因演算法 - 反解機構&lt;/h2&gt;
&lt;p&gt;Github 倉儲：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/kmollee/django-project-template" title="github.com"&gt;https://github.com/kmollee/django-project-template&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這個部分使用之前學長的基因演算法，和 Solvespace 的 Kernel 一樣掛在軟體中。&lt;/p&gt;
&lt;p&gt;不過目前遇到的問題點是這個 Kernel 鏈在 Linux 開發的，要給 Windows 平台使用的話就要重新編譯。&lt;/p&gt;
&lt;p&gt;另外演算法的部分還要審查一下，以確定四連桿呆鍊的方向。&lt;/p&gt;
&lt;h1&gt;Pyslvs 緊急修正&lt;/h1&gt;
&lt;p&gt;由於之前將模組放在 &lt;code&gt;__init__.py&lt;/code&gt; 檔的行為在 PyInstaller 和 cxFreeze 會被識別為掛在資料夾下，因此將模組修正到新的 &lt;code&gt;modules.py&lt;/code&gt; 檔下避免誤判。&lt;/p&gt;
&lt;p&gt;更新在分支 master 中。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>Python Copy Module</title><link href="http://project.mde.tw/blog/python-copy-module.html" rel="alternate"></link><published>2016-12-19T21:00:00+08:00</published><updated>2016-12-19T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-12-19:blog/python-copy-module.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Python 的記憶體管理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Copy Module&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Python 的記憶體管理&lt;/h1&gt;
&lt;p&gt;參考資料：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://billy3321.blogspot.tw/2009/01/python.html" title="billy3321.blogspot.tw"&gt;http://billy3321.blogspot.tw/2009/01/python.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.python-course.eu/deep_copy.php" title="www.python-course.eu"&gt;http://www.python-course.eu/deep_copy.php&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相對於 C 語言而論，Python 的層級較為高階，為了展現可讀性以及易於管理，有自動調整的功能。&lt;/p&gt;
&lt;p&gt;按常理而言，所有的記憶體位址是不能任意更動儲存值類型的。對 Python 而言，不同類型的值進行運算時都會進行轉換，重新分配後才會寫入新的位址中，也造成執行效率沒有 C 語言來的迅速。&lt;/p&gt;
&lt;p&gt;Python 另一個特色是 list 類型，可以存入任何類型的值，並且能自由修改與增刪。&lt;/p&gt;
&lt;p&gt;這是因為 Python 大部分的情況下都是以「記憶體位址」來存取（可以使用 &lt;code&gt;id()&lt;/code&gt; 函式查詢），相當於 C 語言的指標，共用指標的物件就是同一個物件，其中一項值改變時，就會一起更改。&lt;/p&gt;
&lt;p&gt;如以下範例：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def changeLastOne(list1):
    list1[-1] = "c"
    list1.append("d")

b = [1, 2, 3]
changeLastOne(b)
print(b) #[1, 2, "c", "d"]
&lt;/pre&gt;

&lt;p&gt;上述 changeLastOne 的 function 中，「list1」存取了「b」的記憶體位址（相當於下了 &lt;code&gt;list1 = b&lt;/code&gt; 的指令），改變「list1」的值時，「b」的值也會改變。&lt;/p&gt;
&lt;p&gt;這種基本的參照位址不僅限於兩個變數，可以同時參照給很多對象。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
a = 0
b = 0
print(a is b) #True

a = 0
b = 0
a += 1
print(a is b) #False a = 1, b = 0
c = 1
print(a is c) #True
&lt;/pre&gt;

&lt;p&gt;在這個例子中，Python 會將還未拿來處理的記憶體共用位址，節省空間，改變時才會複製出來修改，存入其他位址。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
a = [0, 1, 2, 3, 4]
b = a[:] #使用了分割器，但是不分割
b[1] = 'x'
print(b) #[0, 'x', 2, 3, 4]
print(a) #[0, 1, 2, 3, 4]
&lt;/pre&gt;

&lt;p&gt;上述的例子拿 list a 做了分割動作給 b，不過取出了完整值，導致 Python 認為這是個「處理」動作，於是將新的記憶體位址分配給它。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
a = [0, 1, 2, 3, [0, 1, 2]]
b = a[:] #使用了分割器，但是不分割
b[1] = 'x'
b[4][2] = 'x'
print(b) #[0, 'x', 2, 3, [0, 1, 'x']]
print(a) #[0, 1, 2, 3, [0, 1, 'x']]
&lt;/pre&gt;

&lt;p&gt;然而對於父類型儲存的記憶體位址，Python 也會一併複製，導致兩個父類型，雖然數據不同，卻會共用同一個子類型。&lt;/p&gt;
&lt;h1&gt;Copy Module&lt;/h1&gt;
&lt;p&gt;參考資料：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.python.org/3.5/library/copy.html" title="docs.python.org"&gt;https://docs.python.org/3.5/library/copy.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不過這樣就會產生複製資料的問題，如果使用 &lt;code&gt;a = b&lt;/code&gt;，一律都是複製位址，無法做出一個一模一樣的資料分開修改，因此就必須匯入 Python 內建的 copy 模組。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
import copy

a = [0, 1, 2, 3, [0, 1, 2]]
shallowCopy = copy.copy(a)
deepCopy = copy.deepcopy(a)
&lt;/pre&gt;

&lt;p&gt;Copy 模組中包含兩種複製方式，名為「淺層複製」和「深層複製」，可以重新命令 Python 的參照方式。&lt;/p&gt;
&lt;h2&gt;淺層複製&lt;/h2&gt;
&lt;pre class="brush: python"&gt;
shallowCopy[1] = 'x'
shallowCopy[4][2] = 'x'
print(shallowCopy) #[0, 'x', 2, 3, [0, 1, 'x']]
print(a) #[0, 1, 2, 3, [0, 1, 'x']]
&lt;/pre&gt;

&lt;p&gt;相當於一般 Python 的複製方式（如同上述的分割器），底層的物件仍然是共用記憶體位址的。&lt;/p&gt;
&lt;h2&gt;深層複製&lt;/h2&gt;
&lt;pre class="brush: python"&gt;
deepCopy[1] = 'x'
deepCopy[4][2] = 'x'
print(deepCopy) #[0, 'x', 2, 3, [0, 1, 'x']]
print(a) #[0, 1, 2, 3, [0, 1, 2]]
&lt;/pre&gt;

&lt;p&gt;完全的複製資料，會透過紀錄位址盡可能的將目標值搜尋回來，建立在新的記憶區中，複製出來的項目已經和原本的資料完全不一樣了。&lt;/p&gt;
&lt;h2&gt;自訂 class 的比較&lt;/h2&gt;
&lt;pre class="brush: python"&gt;
from copy import copy, deepcopy

class foo():
    def __init__(self, mylist):
        self.list = mylist

listA = [0, 1, 2, 3]
originData = foo(listA)
shallowCopy = copy(originData)
deepCopy = deepcopy(originData)

listA.append("g") #listA = [0, 1, 2, 3, "g"]

print(shallowCopy.list) #[0, 1, 2, 3, "g"]
print(deepCopy.list) #[0, 1, 2, 3]
&lt;/pre&gt;

&lt;p&gt;不過進行「深層複製」會較「淺層複製」耗時間，如果想要取的值沒有子項目的話，使用「淺層複製」就不用去尋找是否有記憶體位址。&lt;/p&gt;
&lt;p&gt;這部份紀錄是為了接下來做 Undo 與 Redo 功能，Qt 的 QUndoCommand 必須存入物件關聯，以及複製出當前的值做參考，所以必須瞭解 Python 的記憶區管理方式。&lt;/p&gt;</summary><category term="Python3"></category></entry><entry><title>40323230日誌 - 105/12/14</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051214.html" rel="alternate"></link><published>2016-12-14T21:00:00+08:00</published><updated>2016-12-14T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-12-14:blog/40323230ri-zhi-1051214.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路徑追蹤 - 驅動軸&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;大二專題網站&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;路徑追蹤 - 驅動軸&lt;/h2&gt;
&lt;p&gt;路徑追蹤功能已經可以將所有驅動軸旋轉的座標路徑一齊算出。&lt;/p&gt;
&lt;p&gt;之後會再修正畫面的呈現，因為還沒有類似遮罩的功能，無法分辨對應的驅動軸。&lt;/p&gt;
&lt;p&gt;預計將 Shaft0 的路徑彩色顯示（對應機構點的顏色），其他驅動的路徑以灰色顯示；而且外觀會隨著上移和下移驅動軸表格而變。&lt;/p&gt;
&lt;p&gt;至於 QGraphicsView 畫布的測試仍須一段時間，找不太到可互動的畫布範例，PyQt 的範例也更少；而 Python CAD 的物件類型分滿細的，在繼承方面比較難找些。&lt;/p&gt;
&lt;h1&gt;大二專題網站&lt;/h1&gt;
&lt;p&gt;今天讓學弟建了倉儲來存放未來網誌的文章，並稍微講解 Python 程式常用規則，想請教老師下學期專題網站的建立。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/12/13</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051213.html" rel="alternate"></link><published>2016-12-13T21:00:00+08:00</published><updated>2016-12-13T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-12-13:blog/40323230ri-zhi-1051213.html</id><summary type="html">&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;捷徑功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;驅動軸相關&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Kernel 其他修正&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;捷徑功能&lt;/h2&gt;
&lt;p&gt;現在所有表格在項目上雙擊滑鼠左鍵，可以編輯該項目內容。&lt;/p&gt;
&lt;p&gt;而在衝突導致解題失敗時，DOF 的欄位會顯示 "Failed" 字樣，標籤也會改成粗體紅字。&lt;/p&gt;
&lt;p&gt;之後會再審視不方便的操作方式以改進。&lt;/p&gt;
&lt;h2&gt;驅動軸相關&lt;/h2&gt;
&lt;p&gt;改善關於驅動軸相關的功能，並且改成只能驅動 DOF 為 1 的機構。&lt;/p&gt;
&lt;p&gt;目前畫面上顯示的解為 Shaft0 的 Demo Angle 的解，而要切換驅動軸，可以右鍵選單中的上移與下移功能，移到 Shaft0 位置的就會套用 Demo Angle 的約束；目前只剩驅動軸和參數表格有上移與下移的選項。&lt;/p&gt;
&lt;p&gt;另外驅動軸面板的切換選單可以暫時套用選定軸的 Demo Angle 約束，關閉面板後會切回 Shaft0 的約束。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1213_01.png" /&gt;&lt;/p&gt;
&lt;p&gt;在 Path Track 功能中，用了一組選擇驅動軸的介面，不過還沒連接 function，在預設的選項中只有 Shaft0，調成 All 後將會解出所有驅動軸帶動的路徑。&lt;/p&gt;
&lt;p&gt;設計好驅動軸的功能後，大致上就能解所有 DOF 為 1 的純連桿機構路徑了；而驅動滑塊的功能還待加入。&lt;/p&gt;
&lt;h2&gt;Kernel 其他修正&lt;/h2&gt;
&lt;p&gt;Grashof chain 範例已經全數加入，不過因為 Kernel 問題，某些範例的路徑追蹤點必須重新繪製。&lt;/p&gt;
&lt;p&gt;與驅動軸旋轉點相依的其他點，初始值也必須做修正，不然在轉到 180 度之後，會造成其他點因為旋轉點初始位置修正，造成機構反折的狀況。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/12/12</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051212.html" rel="alternate"></link><published>2016-12-12T21:00:00+08:00</published><updated>2016-12-12T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-12-12:blog/40323230ri-zhi-1051212.html</id><summary type="html">&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;諸多錯誤修正鏈鏈&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;葛氏運動鍊：Kernel 校正&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;復原重做功能&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;諸多錯誤修正&lt;/h2&gt;
&lt;p&gt;之前留下一些大大小小的 Bug，會造成程式在讀取檔案或是新增資料時因錯誤而關閉。&lt;/p&gt;
&lt;p&gt;花了一些時間測試功能，確定已完成的功能運作流暢。&lt;/p&gt;
&lt;p&gt;另外還修整了一下界面，避免在 Windows 和 Ubuntu 切換之鏈發生 Layout 空間延展的問題。&lt;/p&gt;
&lt;h2&gt;葛氏運動鍊：Kernel 校正&lt;/h2&gt;
&lt;p&gt;Example 項目中多出了一個鏈"Grashof chain" 類別，預計加入所有葛氏運動鍊的四連桿範例。&lt;/p&gt;
&lt;p&gt;也因為當時寫的校正座標指令是以原點為中心點，造成其他象限的中心軸轉動時，旋轉點出現怪異的運算結果。&lt;/p&gt;
&lt;p&gt;校正繞行圓心時造成中心與旋轉點的位置差，目前座標位置如果比中心還高，基本運行就會流暢，不過如果初始低於圓心，還要加上其他判斷才能修正。&lt;/p&gt;
&lt;p&gt;提前測試一下學長論文中的近似直線範例：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1212_01.png" /&gt;&lt;/p&gt;
&lt;h2&gt;復原重做功能&lt;/h2&gt;
&lt;p&gt;這個部份快要整備好了，但是不知道運作效能如何，也還沒部屬必須紀錄的步驟。&lt;/p&gt;
&lt;p&gt;仿照 Qt 的方式寫了一個相似的類型（因為 Qt 必須部屬在所有指令上，而且還要另外寫反向命令），並在需要時存入重要資訊，一定的步驟內可還原上次的表格內容。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/12/09</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051209.html" rel="alternate"></link><published>2016-12-09T21:00:00+08:00</published><updated>2016-12-09T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-12-09:blog/40323230ri-zhi-1051209.html</id><summary type="html">&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;背景資料名稱&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改畫布&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;背景資料名稱&lt;/h2&gt;
&lt;p&gt;之前為了不讓格式混亂，使用一個函式來轉換所有表格的字串成為數據，但是因為只單純用到清單的功能，分不出來項次代表的內容。&lt;/p&gt;
&lt;p&gt;後來成功改成鍵值的方式存取，在辨識上會更容易。&lt;/p&gt;
&lt;p&gt;這部份希望改成修改時同步清單，而非使用時才轉換。&lt;/p&gt;
&lt;h2&gt;修改畫布&lt;/h2&gt;
&lt;p&gt;由於當前的畫布互動功能只侷限於觀看的部份，在編修上還是得頻繁地去側邊的表格調整，所以必須針對這個部份改強。&lt;/p&gt;
&lt;p&gt;參考 Python CAD（GPL 2.0）的方式，使用 QGraphicsView 和 QGraphicsScene 來建立畫布，以方便管理。&lt;/p&gt;
&lt;p&gt;另外 QGraphicsView 和 QGraphicsScene 的顯示功能也比單純的 QPainter 強大，節省了不少功能。&lt;/p&gt;
&lt;p&gt;不過這種方式修改的部份滿多的，也要重新建立迴圈來畫圖，所以可能會用上一段時間，先從範例的部份開始練習。&lt;/p&gt;
&lt;p&gt;如果瞭解 QGraphicsView 和 QGraphicsScene 的流程後，也會把教學寫在網誌上。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/12/08</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051208.html" rel="alternate"></link><published>2016-12-08T21:00:00+08:00</published><updated>2016-12-08T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-12-08:blog/40323230ri-zhi-1051208.html</id><summary type="html">&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Bug 修正&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;檔案格式檢查&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;__init__.py&lt;/code&gt; 利用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;反解連桿尺寸 &amp;amp; 多個驅動軸&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;技術手冊&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;Bug 修正&lt;/h2&gt;
&lt;p&gt;檢查了一下之前的 code，將兩個地方修正。&lt;/p&gt;
&lt;p&gt;一個是開新檔案的 function 填錯 table 位置所以刪錯項目；另一個是一段時間前將 function 歸類時，造成填寫路徑清單的視窗 function 名稱寫錯。&lt;/p&gt;
&lt;p&gt;另外將清單處理的 &lt;code&gt;list_process.py&lt;/code&gt; 更名為 &lt;code&gt;listProcess.py&lt;/code&gt;，並從 calculation 資料夾轉到 io 底下。這裡的函式經過歸類後，比較像讀寫功能；而非計算功能。&lt;/p&gt;
&lt;h2&gt;檔案格式檢查&lt;/h2&gt;
&lt;p&gt;做了一個小型的檔案格式檢查函式，讀取 csv 的三個標籤（&lt;code&gt;_info_&lt;/code&gt;、&lt;code&gt;_table_&lt;/code&gt;、&lt;code&gt;_path_&lt;/code&gt;）數量來檢查。&lt;/p&gt;
&lt;p&gt;不過就算如此，其中寫入錯誤訊息，還是會導致程式錯誤而關閉，應該改寫成跳出回報錯誤的視窗拒讀，避免造成如 Solvespace 閃退的困擾。&lt;/p&gt;
&lt;p&gt;而之後可能會移除非必要的項目減少 csv 檔案體積和利於程式檢查。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;__init__.py&lt;/code&gt; 利用&lt;/h2&gt;
&lt;p&gt;為了讓 &lt;code&gt;main.py&lt;/code&gt; 起始的標頭不要都是 import 的項目，將所有的 import 項目放到 core 資料夾的 &lt;code&gt;__init__.py&lt;/code&gt; 中（跟 &lt;code&gt;main.py&lt;/code&gt; 同層級）。&lt;/p&gt;
&lt;p&gt;這樣 &lt;code&gt;main.py&lt;/code&gt; 可以向 &lt;code&gt;__init__.py&lt;/code&gt; 借入資料，節省主程式的空間。&lt;/p&gt;
&lt;h2&gt;反解連桿尺寸 &amp;amp; 多個驅動軸&lt;/h2&gt;
&lt;p&gt;預計加入過去學長使用的演算法，使用者指定路徑後，以四連桿的方式反推，「設計」出近似使用者指定路徑的四連桿。&lt;/p&gt;
&lt;p&gt;這個演算法可能會變成類似解路徑的彈出功能，會在介面上規劃空間給它使用，並將解出的第一組解填入表單讓 Solvespace kernel 運算顯示，使用者亦能在產生滿意解之後，另行編修。&lt;/p&gt;
&lt;p&gt;原本的路徑功能也是想支援多個驅動軸的功能，由於當時不太了解 Python 的功能，並沒有做出。不過當初資料格式是有支援寫入多個驅動軸運行的結果，應該較容易相容。&lt;/p&gt;
&lt;h2&gt;技術手冊&lt;/h2&gt;
&lt;p&gt;由於後輩的加入，開發人員的技術手冊應該要在下學期開始前盡快完成，期末前會再審查一次原始碼，歸類好後 Relese v0.4.0 或更新版本以給技術手冊介紹使用。&lt;/p&gt;
&lt;p&gt;之後範例檔案都會存在 core/io/example.py，用 function 回傳 data 值讓程式讀取，若有改版也會附上檔案格式修改的提醒。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/12/07</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051207.html" rel="alternate"></link><published>2016-12-07T21:00:00+08:00</published><updated>2016-12-07T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-12-07:blog/40323230ri-zhi-1051207.html</id><summary type="html">&lt;p&gt;PyInstaller 編譯問題&lt;/p&gt;


&lt;h1&gt;PyInstaller 編譯問題&lt;/h1&gt;
&lt;p&gt;將目前原始碼轉為執行檔的測試。由於之前只有成功編譯小型的 PyQt5 介面，所以嘗試看看在比較大的架構下，所有分支模組中是否會有導入問題。&lt;/p&gt;
&lt;h2&gt;Pyslvs 程式碼整理&lt;/h2&gt;
&lt;p&gt;將程式碼整理了一下，避免發生一些狀況。&lt;/p&gt;
&lt;p&gt;移除了讀取 git 資訊的功能，因為這個資訊會讀取 &lt;code&gt;.git&lt;/code&gt; 資料夾內的內容。&lt;/p&gt;
&lt;p&gt;後來將 PyQt4 的導入去除，實際上也沒有用到 PyQt4 的框架。&lt;/p&gt;
&lt;h2&gt;Solvespace 函式庫問題&lt;/h2&gt;
&lt;p&gt;出現了一個重大的問題，在編譯後會找不到函式庫的名稱。&lt;/p&gt;
&lt;pre&gt;
ImportError: No module named 'core.kernel.py35w._slvs'
...
ImportError: DLL load failed: The specified module could not be found.
&lt;/pre&gt;

&lt;p&gt;參閱 PyInstaller 的技術文件後，瞭解到如果使用的 DLL 類函式庫名稱不在程式碼中的話，必須手動加入 Spec 文件中。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://pyinstaller.readthedocs.io/en/stable/spec-files.html#adding-binary-files" title="pyinstaller.readthedocs.io"&gt;https://pyinstaller.readthedocs.io/en/stable/spec-files.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Spec 文件是 PyInstaller 的執行腳本，若沒有指定的話會自己生產一個預設設定的 Spec 文件。&lt;/p&gt;
&lt;p&gt;Spec 文件的 Analysis 中包含四個項目：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;scripts&lt;/code&gt;：當作主程式啟動的腳本（就是指令中 input 的檔案，只有一個）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;pure&lt;/code&gt;：所需的 Python 模組（通常會直接參照 import 的項目搜尋到，所以不用填）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;binaries&lt;/code&gt;：所需的非 Python 模組。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;datas&lt;/code&gt;：其他所需的非二進制文件（如圖片或是音訊檔）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不過在 &lt;code&gt;binaries&lt;/code&gt; 清單中的示範是填入函式庫中的連結名稱，不知道如果是 DLL 或 SO 的話要如何辨識名稱；直接寫上 &lt;code&gt;_slvs.pyd&lt;/code&gt; 或是 &lt;code&gt;libslvs.so&lt;/code&gt; 的位址也不能解決問題。&lt;/p&gt;
&lt;h2&gt;Ubuntu 編譯成功&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1207_01.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;在一台 16.04 的實體機中，使用 PyInstaller 直接用預設設定編譯，能成功編譯出 Pyslvs 的 Linux 版可執行檔。&lt;/p&gt;
&lt;p&gt;Linux 平台的 SO 函式庫似乎不用特別指定也能找到 &lt;code&gt;_slvs.so&lt;/code&gt; 和 &lt;code&gt;libslvs.so&lt;/code&gt; 的內容；Windows 的 DLL 就得看當初連結庫的名稱是什麼了。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/12/06</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051206.html" rel="alternate"></link><published>2016-12-06T21:00:00+08:00</published><updated>2016-12-06T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-12-06:blog/40323230ri-zhi-1051206.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Windows 環境&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Windows 版進度&lt;/h1&gt;
&lt;p&gt;因為其他作業需求必須編譯 Windows 版的 Python 執行檔，所以順便弄了一下編譯環境。&lt;/p&gt;
&lt;p&gt;在 Windows 架好了撰寫 Pyslvs 所必須的工具：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Anaconda Python 3.5.4（執行檔安裝）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Qt 5.7（官方執行檔安裝）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pip 套件（下載&lt;code&gt;get-pip.py&lt;/code&gt;執行）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新 SIP（conda install 更新）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PyQt 5.7（pip 安裝）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;QScintilla（pip 安裝）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Eric6（Python 執行 &lt;code&gt;install.py&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PyInstaller（pip 安裝）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;現在的 PyInstaller 已經不能跨平台編譯了，只能在相應的平台編出可執行檔，而且有 32 和 64 位元的差異。&lt;/p&gt;
&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;p&gt;將範例檔直接放入程式中而不會不小心覆蓋到原始檔。&lt;/p&gt;
&lt;p&gt;另外還將存檔功能歸類了一下，避免搞亂原本的範例。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1206_01.jpg" /&gt;&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/11/27</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051127.html" rel="alternate"></link><published>2016-11-27T21:00:00+08:00</published><updated>2016-11-27T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-11-27:blog/40323230ri-zhi-1051127.html</id><summary type="html">&lt;p&gt;關於 Pyslvs 格式整合的計畫&lt;/p&gt;


&lt;h1&gt;2D 格式&lt;/h1&gt;
&lt;p&gt;目前只能畫出支架的圖形，所以要盡快弄出完整樣式。&lt;/p&gt;
&lt;p&gt;使用 dxfwrite（授權類型：MIT）畫出基本連桿（或滑塊）的圖形，也許可以給幾種款式選擇。&lt;/p&gt;
&lt;p&gt;匯出後（到其他 CAD 軟體上），不同件使用不同圖塊，方便使用者分開更改或直接長出建模。&lt;/p&gt;
&lt;p&gt;這方面參照一下 dxfwrite 寫入的方式，放到 Free CAD 或 Autodesk 產品中能夠編修就沒問題了。&lt;/p&gt;
&lt;h1&gt;3D 格式&lt;/h1&gt;
&lt;p&gt;使用 &lt;a href="https://github.com/apparentlymart/python-stl" title="github.com"&gt;python-stl&lt;/a&gt;（授權類型：MIT）畫出立體的模型，符合結構強度的外觀。&lt;/p&gt;
&lt;p&gt;這部份可以盡量少讓使用者修改，或變成組合圖的形式（需要調整重疊順序）。&lt;/p&gt;
&lt;p&gt;轉成 3D 的功能主要是讓 V-rep 可以馬上導入做模擬，可以做一個「生成關節轉軸」的選項。&lt;/p&gt;
&lt;p&gt;不過對寫入 STL 文件沒什麼經驗，可能要稍微比對其他 3D 模型。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/11/20</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051120.html" rel="alternate"></link><published>2016-11-20T21:00:00+08:00</published><updated>2016-11-20T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-11-20:blog/40323230ri-zhi-1051120.html</id><summary type="html">&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;佈署單元測試函式（unittest）&lt;/h2&gt;
&lt;p&gt;建構了需要測試的項目，會提取主程式的函式測試回傳值。&lt;/p&gt;
&lt;p&gt;也因為測試需求，把主程式 &lt;code&gt;main.py&lt;/code&gt; 單獨留在 core 資料夾中，其他程式都歸類進資料夾中，方便之後測試函式呼叫。&lt;/p&gt;
&lt;p&gt;不過目前的項目只有 Kernel 解題，之後會增加測試單元。&lt;/p&gt;
&lt;p&gt;執行頂層目錄的 &lt;code&gt;launch_test.py&lt;/code&gt; 來啟動單元測試。&lt;/p&gt;
&lt;h2&gt;清單處理格式轉移&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;處理表格及算點的程式都放到 calculation 資料夾中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原本都是讀取 Qt 的 Table Widget 來取得點座標，但是這樣處理太過混亂（因為回傳值是字串而非數字），也會降低執行效率，所以打算更改。&lt;/p&gt;
&lt;p&gt;原先處理表格的 &lt;code&gt;list_process.py&lt;/code&gt; 劃分出不同表格的 class，它們的函式也重新命名過，更能知道用途。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Points (style)
Lines
Chains
Shafts
Sliders
Rods
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;下一步是在 &lt;strong&gt;init&lt;/strong&gt; 初始化函式中建立空的 list（每筆資料型態都是鍵值），和 Qt 的 Table Widget 同時紀錄資料（格式對應），取資料時不再於 Table Widget 抓資料，而是呼叫所屬 class 的 list，不用轉換格式。&lt;/p&gt;
&lt;p&gt;至於還有一些名稱太冗長的程式碼，可能會用 class 歸類，更容易瞭解用途。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/11/19</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051119.html" rel="alternate"></link><published>2016-11-19T21:00:00+08:00</published><updated>2016-11-19T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-11-19:blog/40323230ri-zhi-1051119.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;Pyslvs 編譯進度&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;視角拖曳&lt;/h2&gt;
&lt;p&gt;做出與 AutoCAD 相似的檢視方式，單靠按住滑鼠滾輪即可自由移動圖形而不會一直鎖定在畫面上。&lt;/p&gt;
&lt;p&gt;過去按住 Ctrl 鍵的功能仍會保留。由於必須按住鍵盤，不至於會與主要檢視方式衝突。&lt;/p&gt;
&lt;h2&gt;技術手冊&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;User Manual
Developer Manual
Application Examples
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;技術手冊採用 Markdown 的方式寫成。&lt;/p&gt;
&lt;p&gt;在系統裝上 Pandoc 與 TeX Live 可以轉成其他純文字格式或 PDF。&lt;/p&gt;
&lt;p&gt;接下來會先大約在 Developer Manual 簡介原始碼，細部內容會一邊開發一邊補齊。&lt;/p&gt;
&lt;p&gt;User Manual 的部份則是做所有功能的介紹，不過預計會附上程式的圖片（改版時若是動到界面就比較麻煩），解釋操作各項功能的方式。&lt;/p&gt;
&lt;p&gt;這三個手冊目前是使用中文說明。&lt;/p&gt;
&lt;h2&gt;v0.3.0 核心改動&lt;/h2&gt;
&lt;p&gt;最近參考大量  Java Script 的程式架構後，覺得以鍵值管理變數的方式比較容易分清用途，解說上也較好管理。&lt;/p&gt;
&lt;p&gt;不過相對於 Java Script，Python 的物件得先建立 class，定義上比較繁瑣，所以就使用 Dictionary 來存取變數，雖然使用上比 Java Script 麻煩許多。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1119_01.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;目前畫布 &lt;code&gt;canvas.py&lt;/code&gt; 中的變數已經分類得差不多了，計算那塊由於關聯太多物件，修改需要花一段時間，亦或使用 Python 原本的 class 建構？&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/11/18</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051118.html" rel="alternate"></link><published>2016-11-18T21:00:00+08:00</published><updated>2016-11-18T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-11-18:blog/40323230ri-zhi-1051118.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;Pyslvs v0.2.0 Release &amp;amp; informations&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs v0.2.0 Release&lt;/h1&gt;
&lt;h2&gt;包含功能&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;儲存時紀錄路徑（存檔格式改變）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多種輔助與控制面板&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;授權聲明&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;問題&lt;/h2&gt;
&lt;p&gt;暫停進階選項的開發，將階段放在解題異常的問題上。&lt;/p&gt;
&lt;p&gt;目前已知問題是在解題時，運算某些位置會發生錯誤，必須修正此問題。&lt;/p&gt;
&lt;p&gt;而 v0.3.0 的目標就是解決死點問題，而滑塊功能仍會繼續測試。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/10/17</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051017.html" rel="alternate"></link><published>2016-10-17T21:00:00+08:00</published><updated>2016-10-17T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-10-17:blog/40323230ri-zhi-1051017.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Kernel 編譯&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Kernel 編譯&lt;/h1&gt;
&lt;p&gt;位於 python-solvespace 倉儲的程式庫文件因應 Pyslvs 的自動切換功能，編譯後不會放在 Ubuntu 或是 Windows 資料夾中了，而是採用 Pyslvs 的顯示方式。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1017_01.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;這個改變儲存在 configure.py 文件中，生成後的 Makefile 將會鎖定在一個編譯者的 Python 版本上，使用其他 Python 編譯的話，要重新用 configure.py 生成。&lt;/p&gt;
&lt;p&gt;而這個 configure.py 的功能之後可能會變成 Leo Editor 的按鈕。&lt;/p&gt;
&lt;p&gt;目前為止還沒測試 Windows 的編譯，也許試過之後會嘗試改用 MinGW，讓 Ubuntu 平台的協同者能為 Windows 編譯。&lt;/p&gt;
&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;p&gt;增加參數控制功能，使用 Python 內建的 sys.argv 清單判定。&lt;/p&gt;
&lt;pre&gt;
$python3 launch_pyslvs.py [arg1] [arg2] ...
&lt;/pre&gt;

&lt;p&gt;可能包裝成執行檔後用終端機呼叫才會出現。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1017_02.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;目前大約做了如下幾個基本的參數。&lt;/p&gt;
&lt;h2&gt;Git 資訊 &lt;code&gt;-g / --git&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;使用後啟動時的標題會讀取目前版次的代碼，不過軟體若是沒帶有 Git 的資訊就會無法顯示。&lt;/p&gt;
&lt;h2&gt;開啟檔案 &lt;code&gt;-o&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;在這個參數上直接接上 CSV 檔案的名稱，可以在開啟 Pyslvs 時馬上載入這個檔案。&lt;/p&gt;
&lt;p&gt;不過如果副檔名不是 CSV 的話就不會讀取。&lt;/p&gt;
&lt;h2&gt;基本資訊 &lt;code&gt;-h / --help&lt;/code&gt; &lt;code&gt;-v / --version&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;使用這兩個參數後將不會開啟 Pyslvs 本體，只會顯示其資訊，偵測的優先權最高。&lt;/p&gt;
&lt;p&gt;若是使用 &lt;code&gt;-v / --version&lt;/code&gt;，只會列出 Pyslvs 和 Python 的版本。&lt;/p&gt;
&lt;h2&gt;其他待加入功能&lt;/h2&gt;
&lt;p&gt;預計加入檢查程式庫和整個 GUI 的 Debug 功能，不過還要研究 Python 的 unit test。&lt;/p&gt;</summary><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/10/16</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051016.html" rel="alternate"></link><published>2016-10-16T21:00:00+08:00</published><updated>2016-10-16T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-10-16:blog/40323230ri-zhi-1051016.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Putty 連線&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;顯示資訊&lt;/h2&gt;
&lt;p&gt;啟動時顯示的資訊加上 commit 編號和平台類型。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1016_01.jpg" /&gt;&lt;/p&gt;
&lt;h2&gt;自動選擇平台版本&lt;/h2&gt;
&lt;p&gt;現在程式庫改移到 kernel 資料夾中，Pyslvs 會讀取平台資訊和 Python 版本來選擇 import 的程式庫。&lt;/p&gt;
&lt;p&gt;名稱為不同版本的 Python 名稱，如 py35。後方加上「w」為 Windows 平台的版本。&lt;/p&gt;
&lt;p&gt;不過若是如此，當 Python Solvespace kernel 更新時，要為所有平台搬運進倉儲。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1016_02.jpg" /&gt;&lt;/p&gt;
&lt;h2&gt;設定檔&lt;/h2&gt;
&lt;p&gt;GUI 的設定檔存放在主目錄，名為 &lt;code&gt;Pyslvs_Settings.ini&lt;/code&gt;，還未開始連結設定功能。&lt;/p&gt;
&lt;p&gt;這個檔案並不會被 git 上傳。&lt;/p&gt;
&lt;h2&gt;License&lt;/h2&gt;
&lt;p&gt;加入了 GPL 3 的授權檔案。&lt;/p&gt;
&lt;p&gt;另外，在 main.py 程式碼中加入了簡短宣告條文（參考自 Gimp）。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;Putty 連線&lt;/h1&gt;
&lt;p&gt;在研究室用 Putty 實測了虛擬機連線的部份，同為 Linux 平台中就沒出現跨平台的錯誤，所以在跨平台撰寫後，測試時可能就得注意了。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/10/13</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051013.html" rel="alternate"></link><published>2016-10-13T21:00:00+08:00</published><updated>2016-10-13T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-10-13:blog/40323230ri-zhi-1051013.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Asus 開機選項（UEFI）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Qt 升級&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;個人網頁創建&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Asus BIOS&lt;/h1&gt;
&lt;p&gt;一些新版的 BIOS 採用 UEFI 模式讀取開機硬體，會有以光碟開機後產生光碟錯誤的提示（甚至讀不到鍵盤無法選擇）；或是選單黑屏卡死。&lt;/p&gt;
&lt;p&gt;學校的新電腦 BIOS 必須啟用相容模式（預設是自動，要強制啟動）才能讀取安裝光碟或隨身碟。&lt;/p&gt;
&lt;p&gt;啟用後重新開機，按 F8 叫出開機選單，選擇沒有「UEFI」字樣的選項，才能用一般的選項載入。&lt;/p&gt;
&lt;p&gt;之前發現第一台測試機的顯示卡不太好，跑 QPainter 的快速 Render 時會滿 lag 的（拖動滑桿控制轉軸時），所以想用新電腦的配備處理看看。&lt;/p&gt;
&lt;h1&gt;Qt 和 PyQt 升級&lt;/h1&gt;
&lt;p&gt;安裝 Qt 後會多出 Qt Maintanance Tool 的捷徑，使用其可以額外安裝、升級、移除現有的 Qt 程式庫。&lt;/p&gt;
&lt;p&gt;不過若要升級，必須每個新版本慢慢升上去，有點花時間就是。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1013_01.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1013_02.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;至於 PyQt 的部份，由於 apt-get 的 &lt;code&gt;python3-pyqt5&lt;/code&gt; 16.04 只支援到 5.5，而且 16.10 也只支援到 5.6，所以看似只能使用 pip3 安裝，不過還沒測試是否會衝突。&lt;/p&gt;
&lt;h1&gt;個人網頁&lt;/h1&gt;
&lt;p&gt;複製了 project site 網站的倉儲建了一個副本，準備改成自己的個人網頁，目前只有存自己的文章。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://40323230.github.io/YuanBlog/blog/"&gt;https://40323230.github.io/YuanBlog/blog/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之後會在 About 加入簡介和心智圖，並整理 Tags。&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323230日誌 - 105/10/11</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051011.html" rel="alternate"></link><published>2016-10-11T21:00:00+08:00</published><updated>2016-10-11T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-10-11:blog/40323230ri-zhi-1051011.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Kubuntu 16.04 一些瑣事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Python Solvespace Makefile 配置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Kubuntu 16.04&lt;/h1&gt;
&lt;p&gt;安裝 Eric6 成功之後，又安裝了 Leo Editor（使用 &lt;code&gt;git clone&lt;/code&gt; 後直接 launch 的方式），在 Python 3.5 + PyQt 5.5 的情形下沒有遇到無法切換輸入法的問題，所以就可以用這台電腦寫網誌了。&lt;/p&gt;
&lt;p&gt;升級之後有類似 Windows 的不定期更新，不過是非強制的，可以不用理它。&lt;/p&gt;
&lt;p&gt;另外新版的 Plasma 將帳戶和即時通綁在一起，所以通知列一直會有即時通的圖示關不掉，不過不妨礙工作。&lt;/p&gt;
&lt;p&gt;資源使用量：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1011_01.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;另外比較奇怪的一點是 Eric6 偵測相關工具時發現了 Pyside（不過 Python 3 無法 import；Python 2 可以）；卻找不到 PyQt（但是可以 import），可能是路徑問題。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1011_02.jpg" /&gt;&lt;/p&gt;
&lt;h1&gt;Python Solvespace Makefile 配置&lt;/h1&gt;
&lt;p&gt;撰寫了 configure.py 來幫忙生成 Makefile，放在 exposed 資料夾裡。&lt;/p&gt;
&lt;p&gt;不過目前只能支援 Ubuntu（測試成功），Windows 的部份因為有可攜環境的關係，需要知道各種工具的位置，必須另外做調整。&lt;/p&gt;
&lt;p&gt;也因為如此，目前 Windows 的部份是原本 W: 槽的設定，之後會改用 Windows 7 測試新的可攜 Solvespace 編譯環境，還有如果本機直接安裝相關工具的環境。&lt;/p&gt;
&lt;p&gt;能夠自動偵測環境編譯後，在想是否需要重新規劃 Submodule 的父子關係，因為 Pyslvs GUI 無法直接切換對應 Python 版本的 Kernal 來用，只會拿到上個使用者的核心來使用，有很大的機率會出問題。&lt;/p&gt;
&lt;p&gt;因此當其他協同者下載 Pyslvs 後，可能需要重新編譯 Kernal 來用，之後放入專案中（或許 Makefile 可以協助），協同 GUI 時就不用理會核心版本不同了。&lt;/p&gt;
&lt;p&gt;至於之後是否會在 16.04 升級 Qt 或 PyQt，可能得尋找其他方法，目前是不會更改內建的程式庫。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - Kubuntu 16.04</title><link href="http://project.mde.tw/blog/40323230ri-zhi-kubuntu-1604.html" rel="alternate"></link><published>2016-10-07T21:00:00+08:00</published><updated>2016-10-07T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-10-07:blog/40323230ri-zhi-kubuntu-1604.html</id><summary type="html">&lt;p&gt;：：Kubuntu 16.04 資訊紀錄：：&lt;/p&gt;


&lt;h1&gt;Kubuntu 16.04&lt;/h1&gt;
&lt;h2&gt;系統資訊&lt;/h2&gt;
&lt;p&gt;Ubuntu: 16.04&lt;/p&gt;
&lt;p&gt;KDE Plasma: 5.5.5&lt;/p&gt;
&lt;p&gt;Qt: 5.5.1&lt;/p&gt;
&lt;p&gt;核心：3.13.0-36-generic (x64)&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1007_01.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;由於研究室有空閒的兩台電腦效能不佳，只有 4GB 的記憶體，且無法模擬 x64 作業系統的能力，所以就配合使用 16.04 版本的測試。&lt;/p&gt;
&lt;p&gt;用 Kubuntu 升級成實體機測試後，其中一台較沒問題，另一台雙系統的電腦反而效能不彰。&lt;/p&gt;
&lt;p&gt;Kubuntu 是使用 muon 系統更新來升級的（但是 16.04 中名稱變為「軟體更新 Update Manager」），若是更新選項調成 LTS 穩定版，就會偵測到 16.04，接受後就會升級。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1007_02.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;升級時所有內建軟體（包括終端機 Konsole）都會凍結，設定功能也會停用，整個過程大約 1 小時左右。升級時建議不要開外部程式以免造成中斷。&lt;/p&gt;
&lt;p&gt;而自己的電腦仍在 14.04 開發。&lt;/p&gt;
&lt;h2&gt;升級後問題&lt;/h2&gt;
&lt;p&gt;主要最大的部份是改用 &lt;strong&gt;Python 3.5&lt;/strong&gt; 與內建 &lt;strong&gt;Qt / PyQt 5.5.1&lt;/strong&gt;。因此在升級時 Python 3.4 和它相關的所有套件都會被移除。（Python 2.7 也因為比 16.04 舊的關係，一樣會被移除）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;新工具：由於官方套件供應者變成 Xenial，所有套件都已經捨棄舊版（如不再提供 GNU 4），而且內建更多工具（如 CMake、Python-dev）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新驅動：內建非穩定版 Ubuntu 15 的 Kernel，支援以往 14.04 沒支援的驅動，要注意是否有新的驅動選項要勾選（如測試電腦中有主機板驅動的選項，預設是未啟用）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;KDE 界面變動：需要稍微習慣和重新設定新的圖形界面，例如滑鼠點兩下的設定放在「滑鼠」中而非檔案總管。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pidgin 移除：通訊程式 Pidgin 不再於新的 KDE 支援了，若不想在更新程式捷徑時出現錯誤，必須在軟體中心移除它。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Python 3.5 套件：安裝 pip 與 QScintilla、QtSQL、QtSVG 時要使用 apt-get，不然自行下載的版本會無法認得內建的 Qt 5。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安裝 QMake：內建的 Qt 沒有附上 QMake，使用 apt-get 下載 &lt;code&gt;qt5-qmake&lt;/code&gt; 安裝它。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;安裝 Eric 6 IDE&lt;/h2&gt;
&lt;p&gt;以下為項目的安裝方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Qt5（內建 5.5，目前與 Pyslvs 並沒有相容問題）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SIP（重新安裝）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PyQt5（內建）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;QScintilla2（用 apt-get 安裝，名稱 &lt;code&gt;python3-pyqt5.qsci&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;QtSQL（Eric 6 需求，用 apt-get 安裝，名稱 &lt;code&gt;python3-pyqt5.qtsql&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;QtSVG（Eric 6 需求，用 apt-get 安裝，名稱 &lt;code&gt;python3-pyqt5.qtsvg&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Eric 6（正常安裝）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Python Solvespace 核心&lt;/h2&gt;
&lt;p&gt;遇到 Python dev Kernel 不相容的問題，因為之前是使用 Python 3.4。意味著必須重編一個 Python Solvespace 的核心給使用 Python 3.5 的 16.04。&lt;/p&gt;
&lt;p&gt;不過新工具跟自己電腦的 14.04 一樣，只要一個新的 Makefile 就行了。&lt;/p&gt;
&lt;p&gt;Python Solvespace 或其 GUI 的編譯是否需要加入 CMake 或 QMake？因為以前不熟悉的關係只能手寫 Makefile，如果能因應未來版本的相關 lib，會比較符合升級的概念。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 影音</title><link href="http://project.mde.tw/blog/40323230ri-zhi-ying-yin.html" rel="alternate"></link><published>2016-10-06T21:00:00+08:00</published><updated>2016-10-06T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-10-06:blog/40323230ri-zhi-ying-yin.html</id><summary type="html">&lt;p&gt;：：影片作業環境（Ubuntu）：：&lt;/p&gt;


&lt;h1&gt;Kazam&lt;/h1&gt;
&lt;p&gt;Ubuntu 平台的錄製軟體，為 KDE 系列的附屬程式，因此安裝 Kubuntu 時就內建了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1006_01.jpg" /&gt;&lt;/p&gt;
&lt;h1&gt;FFmpeg&lt;/h1&gt;
&lt;p&gt;從官方網站下載 &lt;code&gt;.tar.bz2&lt;/code&gt; 壓縮檔解開並進入資料夾。&lt;/p&gt;
&lt;pre&gt;
$./configure --disable-yasm #若是不支援某些項目會提醒停用參數
$make
$sudo make install
&lt;/pre&gt;

&lt;p&gt;最後檢查一下是否安裝：&lt;/p&gt;
&lt;pre&gt;
$ffmpeg -h
&lt;/pre&gt;

&lt;h1&gt;SRT 字幕&lt;/h1&gt;
&lt;p&gt;以前自己載過 Youtube 的字幕練習英文，所以不算陌生。&lt;/p&gt;
&lt;p&gt;未來做 introduction video 應該能好好發揮。&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323230日誌 - 105/10/05</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051005.html" rel="alternate"></link><published>2016-10-05T21:00:00+08:00</published><updated>2016-10-05T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-10-05:blog/40323230ri-zhi-1051005.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Ubuntu MinGW&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ubuntu 16.04 與 Windows 10&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Leo Editor IDE&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;Ubuntu MinGW&lt;/h2&gt;
&lt;p&gt;用 apt-get 安裝 MinGW，以在 Ubuntu 編譯 Windows 的可執行檔 &lt;code&gt;.exe&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
$sudo apt-get install mingw-w64
&lt;/pre&gt;

&lt;p&gt;編譯時使用下列指令（相當於 GNU 工具）：&lt;/p&gt;
&lt;pre&gt;
$x86_64-w64-mingw32-gcc
$x86_64-w64-mingw32-g++
&lt;/pre&gt;

&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1005_01.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;不過若要使用在 Pyslvs，Qt 方面仍要做相應的調整。&lt;/p&gt;
&lt;h1&gt;Ubuntu 16.04 與 Windows 10&lt;/h1&gt;
&lt;p&gt;目前研究室沒有實體機使用這兩個系統，所以打算使用一台學校的電腦安裝 Virtualbox，模擬兩個系統的環境。&lt;/p&gt;
&lt;p&gt;該電腦由於安裝雙系統，Ubuntu 不使用時 Virtualbox 不會佔用 Windows 7 的記憶體，所以應該能提供較流暢的模擬環境。&lt;/p&gt;
&lt;p&gt;明天早上會裝好 Virtualbox 的設定。&lt;/p&gt;
&lt;h1&gt;Leo Editor IDE&lt;/h1&gt;
&lt;p&gt;目前觀察利用 Python 3 的程式碼編譯 Solvespace 是沒有問題的，不過在 14.04 與 16.04 的 Python 3.4 和 3.5 之間需要切換 Makefile。不然會沒有 include 或 lib 位置。&lt;/p&gt;
&lt;pre&gt;
slvs_wrap.cxx:14:23: fatal error: Python.h: 沒有此一檔案或目錄
&lt;/pre&gt;

&lt;p&gt;而若是編譯給 Windows 使用，也是要改一些設定。&lt;/p&gt;
&lt;p&gt;除了之前無法輸入中文的問題以外，測試執行 Button 的 Script 是沒問題。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/10/04</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051004.html" rel="alternate"></link><published>2016-10-04T21:00:00+08:00</published><updated>2016-10-04T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-10-04:blog/40323230ri-zhi-1051004.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;Pyslvs 編譯進度&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;DXF 輸出&lt;/h2&gt;
&lt;p&gt;使用 dxfwrite 模組進行建檔，成功轉出 DXF 檔，可以在其他 CAD 軟體使用。&lt;/p&gt;
&lt;p&gt;dxfwrite 可以使用 pip 安裝。&lt;/p&gt;
&lt;p&gt;不過這個模組的讀取功能似乎不太能支援直接取得 DXF 的數據。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1004_01.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;dxfwrite documentation:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pythonhosted.org/dxfwrite/" title="pythonhosted.org"&gt;http://pythonhosted.org/dxfwrite/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;設定功能&lt;/h2&gt;
&lt;p&gt;規劃了一些自訂功能，想使用 QSettings 功能製作使用者的偏好選項。&lt;/p&gt;
&lt;p&gt;預計會有面板位置、顏色等等選項可以調整。&lt;/p&gt;
&lt;p&gt;不過還在研究 QSettings，可能屬於次要項目。&lt;/p&gt;
&lt;h2&gt;SLVS 輸出&lt;/h2&gt;
&lt;p&gt;將 &lt;code&gt;.slvs&lt;/code&gt; 輸出功能分離出來做調整，希望以後可以單獨使用。&lt;/p&gt;
&lt;p&gt;類似一般撰寫的功能，輸入點或線後可以寫成 &lt;code&gt;.slvs&lt;/code&gt; 檔。&lt;/p&gt;
&lt;p&gt;不過還有一些問題待調整，仍要測試一些項目。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/10/02</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051002.html" rel="alternate"></link><published>2016-10-02T21:00:00+08:00</published><updated>2016-10-02T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-10-02:blog/40323230ri-zhi-1051002.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OCE Kernel&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;p&gt;Log：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;圖片格式選擇&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按照機構寬度或高度縮放視角功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表格提示文字&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表格右鍵複製數據&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;遮罩修正&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;OCE Kernel&lt;/h1&gt;
&lt;p&gt;Open CASCADE Community Edition:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/tpaviot/oce" title="https://github.com"&gt;https://github.com/tpaviot/oce&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;pythonocc:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/tpaviot/pythonocc-core" title="https://github.com"&gt;https://github.com/tpaviot/pythonocc-core&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;找到官方 Open CASCADE 的 C++ 核心，還有 Python 的接口 pythonocc。&lt;/p&gt;
&lt;p&gt;另外 pythonocc 有一個附加模組 aocxchange 可以幫忙轉換 3D 檔案格式。&lt;/p&gt;
&lt;p&gt;預想在 Pyslvs 設計草圖後，可以利用模組轉出簡單的 3D 零件樣式（例如連桿），供 3D CAD 軟體編修。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/30</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050930.html" rel="alternate"></link><published>2016-09-30T21:00:00+08:00</published><updated>2016-09-30T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-30:blog/40323230ri-zhi-1050930.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;Pyslvs 編譯進度&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;p&gt;Log：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;格式加入路徑儲存功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;原點初始值改變&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;驅動軸面板輸入精確角度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重置顯示區按鈕&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;滑塊計算功能（未驗證）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;滑塊路徑追蹤功能（未驗證）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/28</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050928.html" rel="alternate"></link><published>2016-09-28T21:00:00+08:00</published><updated>2016-09-28T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-28:blog/40323230ri-zhi-1050928.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;Pyslvs 編譯進度&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;輔助線面板&lt;/h2&gt;
&lt;p&gt;增加標示極限功能，開啟顯示標註的話，會顯示極限的數值（最大 6 位小數）。&lt;/p&gt;
&lt;p&gt;這個面板在關閉後仍會保留上次的資料（歸類在畫布的參數中），不過切換到其他機構點時就會清掉極限紀錄。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0928_01.jpg" /&gt;&lt;/p&gt;
&lt;h2&gt;模擬面板改進&lt;/h2&gt;
&lt;p&gt;這次調整過模擬功能的面板，更明確易懂。&lt;/p&gt;
&lt;p&gt;另外新增開關路徑圖的功能，之前要刪掉才會消失。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0928_02.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;路徑圖最後會加入存檔中，這部份功能會之後做。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/27</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050927.html" rel="alternate"></link><published>2016-09-27T21:00:00+08:00</published><updated>2016-09-27T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-27:blog/40323230ri-zhi-1050927.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Release v0.1.0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Release v0.1.0&lt;/h1&gt;
&lt;p&gt;穩定版本釋出，開發中的功能有標示「Alpha」的字樣，未做出的功能鈕已經 disable。&lt;/p&gt;
&lt;p&gt;目前更動的部份都是 GUI 相關，動態模擬的部份可能會整合進圖形界面。&lt;/p&gt;
&lt;p&gt;之後的編譯進度更新的是第二版號，第三版號是單純修正 bug，第一版號是大功能的整合。&lt;/p&gt;
&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;輔助線&lt;/h2&gt;
&lt;p&gt;新增輔助線面板，可以觀察機構點的水平或垂直位置，之後會加入最大最小位置紀錄的功能。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0927_01.jpg" /&gt;&lt;/p&gt;
&lt;h2&gt;主動軸標示&lt;/h2&gt;
&lt;p&gt;圖中會標示主動軸的相對點連線，使用橘色虛線表示，之後自訂功能做好後就能改別的顏色了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0927_02.jpg" /&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;今天花時間在輔助線的功能上，還沒做滑塊的計算。&lt;/p&gt;
&lt;p&gt;滑塊可能會和主動軸分開面板控制。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>WebGL_three.js</title><link href="http://project.mde.tw/blog/webgl_threejs.html" rel="alternate"></link><published>2016-09-25T22:00:00+08:00</published><updated>2016-09-25T22:00:00+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2016-09-25:blog/webgl_threejs.html</id><summary type="html">&lt;p&gt;研究WebGL的框架three.js ,嘗試建立和Onshape同性質的網頁繪圖系統 
&lt;/p&gt;
&lt;p&gt;經過討論後 ,我比較想要嘗試網頁方面的繪圖 ,然後上網找到了一些對岸製作的有關於WebGL、three.js的介紹&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.hewebgl.com/article/getarticle/27"&gt;WebGL中文网&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;因為之前也沒有很深入的了解 ,所以可能要接觸一些範例來加深印象 ,假如可行 便能加入30號同學的核心進行2D線上繪圖 ,這樣資源也會更加豐富&lt;/p&gt;</summary><category term="WebGL"></category></entry><entry><title>40323230日誌 - 105/09/24</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050924.html" rel="alternate"></link><published>2016-09-24T21:00:00+08:00</published><updated>2016-09-24T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-24:blog/40323230ri-zhi-1050924.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;安裝 bullet-2.81 程式庫&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;安裝 bullet 程式庫&lt;/h1&gt;
&lt;p&gt;Bullet 其中一個用途為 Blender 的物理運算。&lt;/p&gt;
&lt;p&gt;由於找到了一些 Python 相關的端口，所以想先安裝來讓 Python 使用。&lt;/p&gt;
&lt;p&gt;＊先確認已安裝 OpenCL。&lt;/p&gt;
&lt;p&gt;從官方網站下載 Bullet Physics Library。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bulletphysics.org/Bullet/phpBB3/viewtopic.php?t=8490" title="bulletphysics.org"&gt;http://bulletphysics.org/Bullet/phpBB3/viewtopic.php?t=8490&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;載點為 bullet-2.81-rev2613.tgz：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://code.google.com/archive/p/bullet/downloads" title="bullet"&gt;https://code.google.com/archive/p/bullet/downloads&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用 CMake 設定系統參數，並安裝：&lt;/p&gt;
&lt;pre&gt;
$cmake . -G "Unix Makefiles" -DBUILD_SHARED_LIBS=ON
$sudo make
$sudo make install
&lt;/pre&gt;

&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0924_01.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;預設會安裝於 &lt;code&gt;/usr/loca/lib/&lt;/code&gt; 中。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/21</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050921.html" rel="alternate"></link><published>2016-09-21T21:00:00+08:00</published><updated>2016-09-21T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-21:blog/40323230ri-zhi-1050921.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.slvs&lt;/code&gt; 格式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;速度計算&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;&lt;code&gt;.slvs&lt;/code&gt; 格式&lt;/h1&gt;
&lt;p&gt;簡述進度：&lt;/p&gt;
&lt;p&gt;輸出功能做了之後就測試 Pyslvs 產生的檔案是否能給 Solvespace 讀取，但是發現其實 16 進位編號是有順序的，如果跳號或對錯位就會導致閃退。&lt;/p&gt;
&lt;p&gt;測試之後，目前基本的點輸入一切正常，但是當有連接線時就會產生錯誤，可能是數值對錯位，轉檔紀錄時應該必須和現在的算點功能分離。&lt;/p&gt;
&lt;p&gt;目前轉出點成功：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0921_01.jpg" /&gt;&lt;/p&gt;
&lt;h1&gt;速度計算功能&lt;/h1&gt;
&lt;p&gt;想做一個有關速度計算的功能，從轉的角度轉換距離，用自訂 RPM 速度轉換當前線速度。&lt;/p&gt;
&lt;p&gt;可能會結合路徑追蹤使用。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/19</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050919.html" rel="alternate"></link><published>2016-09-19T21:00:00+08:00</published><updated>2016-09-19T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-19:blog/40323230ri-zhi-1050919.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.slvs&lt;/code&gt; 格式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3D Printer 模擬&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;&lt;code&gt;.slvs&lt;/code&gt; 格式&lt;/h1&gt;
&lt;p&gt;其實 &lt;code&gt;.slvs&lt;/code&gt; 格式只是將 Solvespace 的暫存數據記錄下來，若有缺失就會使用預設數據，存檔時會刷新而非只修改部份。&lt;/p&gt;
&lt;p&gt;參考的部份是空白文件的數據（包含預設平面、向量、原點等等），當有增加實體時就會追加內容。&lt;/p&gt;
&lt;p&gt;特別注意的是這些代碼皆為 16 進位，&lt;code&gt;True&lt;/code&gt; 的部份用 1 表示，&lt;code&gt;False&lt;/code&gt; 則用 0 表示。&lt;/p&gt;
&lt;p&gt;總共分為 5 個部份：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;群組：群組，類似圖層的概念。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;參數：之後會用到的幾何數據，會用編號歸納關係，基本上無法共用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;回應：圖形化界面的回應，包含滑鼠能點擊到的所有物件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;實體：點線的構成，包含實體建構時的參考副本，例如 point[0] 到 point[1] 的內容會被歸納到線條的從屬下。&lt;em&gt;未閉合的端點會有重複的紀錄，不過實驗過刪除多餘的紀錄仍可正常開啟。&lt;/em&gt;不同實體有不同屬性可調整。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;約束：用來約束實體，不同約束有不同屬性可調整。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;參照下列格式：&lt;/p&gt;
&lt;pre&gt;
辨識標頭（使用 ISO-8859-15）：
±²³SolveSpaceREVa

參考群組（00000001）：
Group.h.v=00000001
Group.type=5000
Group.name=#references
...
AddGroup

加入群組：
Group.h.v=00000002
Group.type=5001
Group.order=1
Group.name=sketch-in-plane
...
AddGroup

參考參數（00010010~00030023）：
Param.h.v.=00010010
AddParam

加入參數：00030020
Param.h.v.=00040010
Param.val=40.00000000000000000000
AddParam

參考回應（00000001~00000003）：
Request.h.v=00000001
Request.type=100
Request.group.v=00000001
Request.construction=0
AddRequest

加入回應：
Request.h.v=00000004
Request.type=101
Request.workplane.v=80020000
Request.group.v=00000002
Request.construction=0
AddRequest

參考實體（00010000~00030020）：
Entity.h.v=00010000
Entity.type=10000
Entity.construction=0
Entity.point[0].v=00010001
Entity.normal.v=00010020
Entity.actVisible=1
AddEntity

加入實體：
Entity.h.v=00040000
Entity.type=2001
Entity.construction=0
Entity.workplane.v=80020000
Entity.actPoint.x=40.00000000000000000000
Entity.actPoint.y=30.00000000000000000000
Entity.actVisible=1
AddEntity

複製項（80020000~80020002）：
Entity.h.v=80020000
Entity.type=10000
Entity.construction=0
Entity.point[0].v=80020002
Entity.normal.v=80020001
Entity.actVisible=1
AddEntity

加入約束：
Constraint.h.v=00000001
Constraint.type=30
Constraint.group.v=00000002
Constraint.workplane.v=80020000
Constraint.valA=50.00000000000000000000
Constraint.ptA.v=00040000
Constraint.ptB.v=80020002
Constraint.other=0
Constraint.other2=0
Constraint.reference=0
AddConstraint
&lt;/pre&gt;

&lt;p&gt;研究花了一些時間，可能得後天才能加入匯出功能。&lt;/p&gt;
&lt;p&gt;Pyslvs 的群組應該只會有一個，用點之間的線架構就好了。&lt;/p&gt;
&lt;p&gt;應該只有 3D Mode 才有 STL 支援的功能。&lt;/p&gt;
&lt;p&gt;剩下 3D Mode 將 2D 的功能加過去，另外新增線條鉛錘與水平的約束、應該就能結束了。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;3D Printer 模擬&lt;/h1&gt;
&lt;p&gt;關於 3D Printer 模擬的部份，可能必須寫一個新的軟體來應對。&lt;/p&gt;
&lt;p&gt;因為一些定義如果直接套用目前的範本，可能會無法模擬。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0919_01.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;畫了個模型，之後套範本應該比較快。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/17</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050917.html" rel="alternate"></link><published>2016-09-17T21:00:00+08:00</published><updated>2016-09-17T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-17:blog/40323230ri-zhi-1050917.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PyOpenGL&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;h2&gt;3D 模式&lt;/h2&gt;
&lt;p&gt;在另鏈個分頁新增相同的面板，不過拿掉了呆鍊約束。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/9GEGPzD.png" &gt;&lt;/p&gt;
&lt;p&gt;新的 Widget 名稱都改成 &lt;code&gt;_3d&lt;/code&gt; 字尾以供辨識。&lt;/p&gt;
&lt;p&gt;不過上方的 QMenuBar 必須應對這個改變，估計製作 3D 的 QAction 後，會根據當前頁籤隱藏另一邊的 QAction。&lt;/p&gt;
&lt;h2&gt;記憶體釋放&lt;/h2&gt;
&lt;p&gt;由於初學時的寫法沒優化觀念，Qt 的視窗物件必須用 &lt;code&gt;setAttribute()&lt;/code&gt; 設定屬性，其中的 &lt;code&gt;Qt.WA_DeleteOnClose&lt;/code&gt; 會在關閉後刪除物件，以免開過太多視窗會導致速度降低。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;.slvs&lt;/code&gt; 格式&lt;/h2&gt;
&lt;p&gt;今天還是沒時間研究詳細的用法，但是可以確定 2D 圖面的初步內容（基準面之類的），用 Python 程式碼存成 &lt;code&gt;.slvs&lt;/code&gt; 附檔名的 &lt;code&gt;ISO-8859-15&lt;/code&gt; 編碼文字檔。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
with open(fileName, 'w', encoding="iso-8859-15", newline="") as f:
    f.write(self.Slvs_Script)
print("Successful Save: "+fileName)
&lt;/pre&gt;

&lt;hr&gt;

&lt;h1&gt;PyOpenGL&lt;/h1&gt;
&lt;p&gt;找了一下之前為何無法使用 OpenGL 範例的原因，似乎是因為那些範例無法支援新的 OpenGL 了。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/38645674/issues-with-pyqt5s-opengl-module-and-versioning-calls-for-incorrect-qopenglfu" title="stackoverflow.com"&gt;http://stackoverflow.com/questions/38645674/issues-with-pyqt5s-opengl-module-and-versioning-calls-for-incorrect-qopenglfu&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所以按照建議，安裝了 PyOpenGL（License: BSD） ，不過它的開發期較長。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pyopengl.sourceforge.net/documentation/installation.html" title="pyopengl.sourceforge.net"&gt;http://pyopengl.sourceforge.net/documentation/installation.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;執行過上面文章的範例，可以成功使用（不過那個範例 code 忘記匯入 sys 和 math）。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/hZf6lu2.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;明天可能會利用時間放圖片。&lt;/p&gt;
&lt;p&gt;Mark Down 圖片的語法（其實和超連結很像）：&lt;/p&gt;
&lt;pre&gt;
![替代文字](近端或遠端連結"滑鼠提示文字")
&lt;/pre&gt;

&lt;p&gt;只是無法調整圖片大小。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/15</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050915.html" rel="alternate"></link><published>2016-09-15T21:00:00+08:00</published><updated>2016-09-15T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-15:blog/40323230ri-zhi-1050915.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;現時 Ubuntu 版 Solvespace 安裝&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.slvs&lt;/code&gt; 檔案格式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 3D 模式&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Solvespace 編譯&lt;/h1&gt;
&lt;p&gt;確保下列事項：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;GNU 5.3 以上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CMake 3.0 以上&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下載後進入資料夾。&lt;/p&gt;
&lt;pre&gt;
$git submodule update --init extlib/libdxfrw
$mkdir build
$cd build
$cmake .. -DENABLE_TESTS=OFF
&lt;/pre&gt;

&lt;p&gt;若出現 &lt;code&gt;GCC 5.0+ is required&lt;/code&gt; 問題，請使用下列指令更改優先權：&lt;/p&gt;
&lt;pre&gt;
$sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 1
$sudo update-alternatives --config gcc
替代項目 gcc（提供 /usr/bin/gcc）有 2 個選擇。

  選項       路徑            優先權  狀態
------------------------------------------------------------
* 0            /usr/bin/gcc-4.8   48        自動模式
  1            /usr/bin/gcc-4.8   48        手動模式
  2            /usr/bin/gcc-5     1         手動模式

按 [enter] 保留目前選項 [*]，或輸入選項編號：2   
update-alternatives: 以 /usr/bin/gcc-5 提供 手動模式 中的 /usr/bin/gcc (gcc)
&lt;/pre&gt;

&lt;p&gt;若出現這個警告：&lt;/p&gt;
&lt;pre&gt;
The CMAKE_CXX_COMPILER:

/usr/bin/c++

is not a full path to an existing compiler tool.
&lt;/pre&gt;

&lt;p&gt;請更改 CMake List 的參數（注意不要指到軟連結，必須是執行檔本體）：&lt;/p&gt;
&lt;pre&gt;
$sudo cmake -D CMAKE_C_COMPILER="/usr/bin/gcc-5" -D CMAKE_CXX_COMPILER="/usr/bin/g++-5" ../CMakeLists.txt
&lt;/pre&gt;

&lt;p&gt;最後 build 檔案出來後，使用下列指令：&lt;/p&gt;
&lt;pre&gt;
$cd ..
$sudo make
&lt;/pre&gt;

&lt;p&gt;編譯完畢後，可以在 &lt;code&gt;src&lt;/code&gt; 資料夾中找到 &lt;code&gt;solvespace&lt;/code&gt; 執行檔，點兩下就能執行了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/rgW87Ao.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;&lt;code&gt;.slvs&lt;/code&gt; 檔案格式&lt;/h1&gt;
&lt;p&gt;為了瞭解 Solvespace 的運作流程，也以便之後跟它溝通，想知道 &lt;code&gt;.slvs&lt;/code&gt; 的儲存方式。&lt;/p&gt;
&lt;p&gt;觀察檔案格式，用文字編輯軟體開啟之前存的範例。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/7E2onBk.png" &gt;&lt;/p&gt;
&lt;p&gt;Solvespace 是用西歐語系 &lt;code&gt;ISO-8859-15&lt;/code&gt; 編碼儲存圖檔的，以這點來說，Python 要輸出成 &lt;code&gt;.slvs&lt;/code&gt; 應該是輕而易舉。&lt;/p&gt;
&lt;p&gt;之後觀察一下每種圖形的變化式，應該就能理解如何將 Pyslvs 的表格 Output 給 Solvespace 開啟了。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;Pyslvs 3D 模式&lt;/h1&gt;
&lt;p&gt;在想 Pyslvs 之後會加入 3D 模式，採用 Qt OpenGL 繪圖（可以控制鏡頭），且和 2D 模式並存，參考這裡的文章：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://doc.qt.io/qt-5/topics-graphics.html#2d-graphics-with-qpainter" title="doc.qt.io"&gt;http://doc.qt.io/qt-5/topics-graphics.html#2d-graphics-with-qpainter&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之前好像看過 QPainter 和 QOpenglWidgets 重疊渲染錯誤的問題，不過只要分開 Widget，應該是不會造成太大衝突。&lt;/p&gt;
&lt;p&gt;而 2D 和 3D 共存不知道是否會吃太多資源，還有待觀察。&lt;/p&gt;
&lt;p&gt;另外在成功大學的文件裡找到關於 STL 格式的說明：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://vr.me.ncku.edu.tw/courses/cg99/Download/STL.pdf" title="vr.me.ncku.edu.tw"&gt;http://vr.me.ncku.edu.tw/courses/cg99/Download/STL.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;想要大約瞭解一下，畢竟大部分的 3D CAD 軟體應該都支援 STL 檔。&lt;/p&gt;
&lt;p&gt;亦找到一篇 C++ 讀取 STL 並用 OpenGL 顯示的範例 code，值得研究一下。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cnblogs.com/xds1224/p/3565280.html" title="www.cnblogs.com"&gt;http://www.cnblogs.com/xds1224/p/3565280.html&lt;/a&gt;&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/14</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050914.html" rel="alternate"></link><published>2016-09-14T21:00:00+08:00</published><updated>2016-09-14T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-14:blog/40323230ri-zhi-1050914.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Qt OpenGL 教學資料&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PySide 2 安裝問題&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Qt OpenGL&lt;/h1&gt;
&lt;p&gt;Qt 的官方頁面還沒有撰寫說明，只看函式與格式不太能了解其用途。&lt;/p&gt;
&lt;p&gt;所以去找其他 QtOpenGLWidgets 的教學，找到滿多資料的。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/cly116/article/details/47184729" title="blog.csdn.net"&gt;http://blog.csdn.net/cly116/article/details/47184729&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PyQt 的詳細說明比較少，不過找到幾篇範例後，可以對照著看。由於是高階語言，Python 使用 C++ 函式滿容易的，省略不少步驟。&lt;/p&gt;
&lt;h1&gt;PySide 2 安裝問題&lt;/h1&gt;
&lt;p&gt;今天將 Qt 版本改成 5.6，並重新下載官方倉儲安裝。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/PySide/pyside2-setup" title="github.com/PySide"&gt;https://github.com/PySide/pyside2-setup&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用的參數：&lt;/p&gt;
&lt;pre&gt;
$sudo python3 setup.py install --qmake=/usr/bin/qmake --cmake=/usr/bin/cmake
&lt;/pre&gt;

&lt;p&gt;剛開始遇到 Makelist 找不到指定檔案的問題，如下圖：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/hougrQE.png" &gt;&lt;/p&gt;
&lt;p&gt;必須安裝以下套件：&lt;/p&gt;
&lt;pre&gt;
$sudo apt-get install libqt5xmlpatterns5-dev
&lt;/pre&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/7OnYdB8.png" &gt;&lt;/p&gt;
&lt;p&gt;不過接下來遇到編譯 shiboken 的問題，編到一半就中斷了。&lt;/p&gt;
&lt;p&gt;上網查了下結果，是因為函式未回傳值，可是不知道什麼原因。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/957Qjp3.png" &gt;&lt;/p&gt;
&lt;p&gt;到官方的倉儲找 Issue，不過好像都沒遇到這種情況。&lt;/p&gt;
&lt;p&gt;所以另外從非官方倉儲下載 wheel 來用。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/fredrikaverpil/pyside2-wheels" title="github.com/fredrikaverpil"&gt;https://github.com/fredrikaverpil/pyside2-wheels&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下載了編譯完成的 wheel (Python 3.4) 後，按照下方 Readme 的說明安裝。&lt;/p&gt;
&lt;p&gt;這個套件提供者是將 Qt 版本分開裝的，所以會和 PyQt 使用的資料庫不一樣。&lt;/p&gt;
&lt;p&gt;不過不須擔心這個問題，因為包好的 wheel 會直接讀安裝的 Qt 資料庫，可以不用裝說明裡的套件。&lt;/p&gt;
&lt;p&gt;以下連結有 4 個平台的 PySide 2 載點，只需使用 &lt;code&gt;pip install&lt;/code&gt; 或 &lt;code&gt;pip3 install&lt;/code&gt; 就能裝成功。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://bintray.com/fredrikaverpil/pyside2-wheels/pyside2/2.0.0.dev0#files/" title="bintray.com"&gt;https://bintray.com/fredrikaverpil/pyside2-wheels/pyside2/2.0.0.dev0#files/&lt;/a&gt;&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/13</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050913.html" rel="alternate"></link><published>2016-09-13T21:00:00+08:00</published><updated>2016-09-13T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-13:blog/40323230ri-zhi-1050913.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 版本子倉儲&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PySide 2 一些資料&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;子倉儲&lt;/h1&gt;
&lt;p&gt;將資料夾重新命名後，建立新的倉儲，將 Pyslvs 的程式碼放入。&lt;/p&gt;
&lt;p&gt;再用指令將子倉儲嵌入 Python-solvespace 的倉儲：&lt;/p&gt;
&lt;pre&gt;
git submodule add https://github.com/40323230/Pyslvs-PyQt5 Pyslvs-PyQt5
&lt;/pre&gt;

&lt;p&gt;重新 push 一次，這樣就將子倉儲放在主倉儲中了。&lt;/p&gt;
&lt;p&gt;而 &lt;code&gt;.gitmodules&lt;/code&gt; 檔案中也會紀錄子倉儲的文件。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/lnJGtQs.png" &gt;&lt;/p&gt;
&lt;p&gt;只是在切換分支時要特別小心，以免造成衝突。&lt;/p&gt;
&lt;p&gt;參考的是 Git 官方英文網站的說明，不過這裡有中文版的：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://git-scm.com/book/zh-tw/v1/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E7%B5%84-Submodules" title="git-scm.com"&gt;https://git-scm.com/book/zh-tw/v1/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E7%B5%84-Submodules&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;PySide 2&lt;/h1&gt;
&lt;p&gt;找了 PySide 的相關資料，發現目前支援 Qt5 的是 PySide 2，是去年開始開發的，仍在努力追上 PyQt 的腳步。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://wiki.qt.io/PySide2" title="wiki.qt.io"&gt;https://wiki.qt.io/PySide2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在開發紀錄中提到還在克服 Qt 5.7 中 shiboken 失去 C++ 11 的支援，所以暫不支援 Qt 5.7。&lt;/p&gt;
&lt;p&gt;也因為如此，今天試圖 build 出 PySide 2 的安裝檔時發生 shiboken 的錯誤，應該就是這個問題，明天會將 Qt 改成 5.6，以裝上 PySide 2。&lt;/p&gt;
&lt;p&gt;另外也先預習 PyQt 轉 PySide 時需要注意的事項，不過目前看下來頂多是信號槽的名稱需要去掉 &lt;code&gt;pyqt&lt;/code&gt; 的字頭。&lt;/p&gt;
&lt;p&gt;其他因為是用 Python 3 開發的關係，內建標準的 String 與 List 格式，不須煩憂 QString 或 QList 的問題。&lt;/p&gt;
&lt;p&gt;而還有用 Super 繼承的問題，在 PySide 中也有 Qt Designer，&lt;code&gt;.ui&lt;/code&gt; 轉換 &lt;code&gt;.py&lt;/code&gt; 上使用 PySide 的程式（或是 Eric 可以自己應變）就行了。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/12</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050912.html" rel="alternate"></link><published>2016-09-12T21:00:00+08:00</published><updated>2016-09-12T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-12:blog/40323230ri-zhi-1050912.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二對連桿腳&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;h2&gt;參數式界面&lt;/h2&gt;
&lt;p&gt;大部分的界面都統整好了，剩下遮罩沒設定。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/yz2lXJN.png" &gt;&lt;/p&gt;
&lt;p&gt;這些參數確定可用，不過角度格式還不支援。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/PKUskgY.png" &gt;&lt;/p&gt;
&lt;h2&gt;滑鼠加入點&lt;/h2&gt;
&lt;p&gt;在畫布上使用滑鼠右鍵選單就可以在該位置加入座標。&lt;/p&gt;
&lt;p&gt;加入後會出現在左側的表格裡，亦可供編輯。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/GYnvhQz.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;連桿組範例&lt;/h1&gt;
&lt;p&gt;用新的繪圖系統加入了第二組連桿腳。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/G4VXlZe.png" &gt;&lt;/p&gt;
&lt;p&gt;模擬了一下動作，效果還不錯。&lt;/p&gt;
&lt;p&gt;之後會改試試 OpenGL 的模組功能，之前執行範例時會出錯，要找辦法解決。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;另外在 imgur.com 的圖片載了一個副本下來，找時間會移到倉儲上。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/11</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050911.html" rel="alternate"></link><published>2016-09-11T21:00:00+08:00</published><updated>2016-09-11T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-11:blog/40323230ri-zhi-1050911.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度 - 參數式架構核心完成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;p&gt;簡略 log：&lt;/p&gt;
&lt;p&gt;大改核心，寫了一條函式將表格轉為 list 型態，並自動儲存成相應的類型。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/1hV4XYP.png" &gt;&lt;/p&gt;
&lt;p&gt;整修後的計算式乾淨多了，沒有型態問題，從對應 list 取出來就行。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/DBaMWdj.png" &gt;&lt;/p&gt;
&lt;p&gt;這次大改是因應新的參數表加入，圖中的項目配置方便使用者直接選取後打入新數值。&lt;/p&gt;
&lt;p&gt;而 Commit 的部份沒多加限制，點擊兩下就能修改。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/yz2lXJN.png" &gt;&lt;/p&gt;
&lt;p&gt;執行全部功能正常。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/yX0WKvb.png" &gt;&lt;/p&gt;
&lt;p&gt;不過輸入界面部份還沒做轉換，Point 的加入可能會出問題，所以目前是讀範例做測試。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/10</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050910.html" rel="alternate"></link><published>2016-09-10T21:00:00+08:00</published><updated>2016-09-10T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-10:blog/40323230ri-zhi-1050910.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;參數式架構&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;測試影片&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;p&gt;今天將所有的視窗都用圖層或 Widget 固定化，免得編譯後位置出現落差。&lt;/p&gt;
&lt;p&gt;不過也花了許多時間，之後主要是為參數式編輯做架構。&lt;/p&gt;
&lt;p&gt;最後決定使用單行文字框做輸入。&lt;/p&gt;
&lt;p&gt;未來的輸入界面大約像這樣：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/tqvi7j1.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;參數式界面改良&lt;/h1&gt;
&lt;p&gt;在點座標分頁中新增參數表，使用右鍵可以新增或刪除項目，點擊兩下就能編輯數據與註解。&lt;/p&gt;
&lt;p&gt;而下方加入點的欄位中，可以打入新增的代碼。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/4AWc7cw.png" &gt;&lt;/p&gt;
&lt;p&gt;雖然整體改換還需要段時間，但是重要的功能已經有雛型了。&lt;/p&gt;
&lt;h2&gt;輸入遮罩&lt;/h2&gt;
&lt;p&gt;遮罩設定存於主視窗中，對話方塊生成時會複製內容，給其所有需要的單行文字框。&lt;/p&gt;
&lt;p&gt;有了這個設定，就能避免使用者亂輸入文字了，基本概念如下：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
X_coordinate = QLineEdit()
X_coordinate.setValidator(QRegExpValidator(QRegExp(mask)))
&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;mask&lt;/code&gt; 是字串，也是篩選的條件。&lt;/p&gt;
&lt;p&gt;基本規則如下：&lt;/p&gt;
&lt;pre&gt;
[ 任何文字 ]{ 必要出現次數 , 在接下來的長度內 }
&lt;/pre&gt;

&lt;p&gt;中括弧中是打允許使用者的字元。&lt;/p&gt;
&lt;p&gt;如 &lt;code&gt;[a]&lt;/code&gt;，使用者必須打入 1 個小寫的 a 才能再繼續之後的規則，可以使用 &lt;code&gt;[0-9]&lt;/code&gt; 表示 0 至 9 的數字，&lt;code&gt;[a-z]&lt;/code&gt; 表示小寫的 26 個英文字母等等。&lt;/p&gt;
&lt;p&gt;大括弧是篩選條件，默認是 &lt;code&gt;{1, 1}&lt;/code&gt;，第一項是必須打的數量，第二項是這個規則最大的數量。&lt;/p&gt;
&lt;p&gt;小括弧是邏輯順序，跟其他程式語言差不多，如 &lt;code&gt;([a] | [b]{3, 5})&lt;/code&gt; 就是在這個位置可以選擇打入 1 個 a，或是 3 個到 5 個 b。&lt;/p&gt;
&lt;p&gt;至於 &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt; 則是標示貼緊字頭與字尾的符號，能夠比較明確，但是要注意是否會導致字頭設下太多規則，而讓使用者打不了半個字。&lt;/p&gt;
&lt;p&gt;基本規則容易搞混的話，可以使用簡語，如 &lt;code&gt;?&lt;/code&gt; 符號代表 &lt;code&gt;{0, 1}&lt;/code&gt;，就是能選擇要不要輸入的意思，可以省略它打入下個規則的字串。&lt;/p&gt;
&lt;p&gt;其他簡語可以參考&lt;a href="http://doc.qt.io/qt-5/qregexp.html" title="doc.qt.io"&gt;官方網站&lt;/a&gt;的說明。&lt;/p&gt;
&lt;p&gt;以下是 Pyslvs的遮罩：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#超過10個參數
param_10 = '[1-'+str(int(self.Parameter_list.rowCount()/10))+']?' if self.Parameter_list.rowCount()&gt;=10 else ''
#有參數
param_use = '(^[n]'+param_10+'[0-'+str(int(self.Parameter_list.rowCount())-1)+']$|' if self.Parameter_list.rowCount()&gt;=1 else ''
#最小值 -9999.9999 最大值 9999.9999 的數字
mask = param_use+'^[-]?([1-9][0-9]{1,2})?[0-9][.][0-9]{1,4}$'
if param_use: mask += ')'
self.Mask = QRegExpValidator(QRegExp(mask))
self.X_coordinate.setValidator(self.Mask)
self.Y_coordinate.setValidator(self.Mask)
&lt;/pre&gt;

&lt;p&gt;如果參數表長度超過 1，只要開頭打入 &lt;code&gt;n&lt;/code&gt; 這個字母，就會啟用參數規則，而且只能打入目前長度設入的參數代號。&lt;/p&gt;
&lt;p&gt;如果沒有設定參數，文字欄內只能填入最大 9999.9999 的數字。&lt;/p&gt;
&lt;p&gt;因為要讀表的長度，上述設定在參數表新增或移除項目時就會更新。&lt;/p&gt;
&lt;p&gt;另一方面，因為變成了文字欄，為了偵測是否為空值，做了一些小篩選：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
x = self.X_coordinate.text() if not self.X_coordinate.text()=="" else self.X_coordinate.placeholderText()
y = self.Y_coordinate.text() if not self.Y_coordinate.text()=="" else self.Y_coordinate.placeholderText()
&lt;/pre&gt;

&lt;p&gt;至於空的欄位上的淡色文字（Place Holder Text）部份地方只是寫好看的，之後可能就直接讀淡色文字來用。例如編輯視窗中只需要改動 X 軸座標，不小心動到 Y 軸座標時直接刪成空欄位，系統可以填回原本的數值。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;測試影片&lt;/h1&gt;
&lt;p&gt;錄製一段粗糙的影片展示目前基本功能。&lt;/p&gt;
&lt;p&gt;之後會找一個比較好的軟體剪接。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;路徑追蹤&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程式碼和路徑座標展示&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;動態模擬&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;距離量測&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;iframe src="https://player.vimeo.com/video/182206176" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;a href="https://vimeo.com/182206176"&gt;Pyslvs preview&lt;/a&gt; from &lt;a href="https://vimeo.com/user56487696"&gt;Union000&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/09</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050909.html" rel="alternate"></link><published>2016-09-09T21:00:00+08:00</published><updated>2016-09-09T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-09:blog/40323230ri-zhi-1050909.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;近似直線機構問題&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;活塞 → 動力源而非被動元件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;參數式設計？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;測量能力待加強&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;h2&gt;Fusion 主題&lt;/h2&gt;
&lt;p&gt;使用 QApplication 的主題選擇功能指定主題。&lt;/p&gt;
&lt;p&gt;這樣在 Ubuntu 執行時會強制使用該元件外觀，而非之前節圖的鐵灰色。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
QApplication.setStyle("fusion")
app = QApplication(argv)
run  = MainWindow()
run.show()
exit(app.exec())
&lt;/pre&gt;

&lt;p&gt;Qt 的說明文件提及，雖然 Qt 程式庫擁有 5 種主題，但是所有平台共通的是 &lt;code&gt;fusion&lt;/code&gt; 和 &lt;code&gt;windows&lt;/code&gt;（傳統佈景）主題。&lt;/p&gt;
&lt;p&gt;只在有在特定平台才能正常顯示特定主題，如在麥金塔上使用 &lt;code&gt;macintosh&lt;/code&gt;，Windows XP 上使用 &lt;code&gt;windowsxp&lt;/code&gt;，Windows Vista 以上的作業系統使用 &lt;code&gt;windowsvista&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/AuNkVl3.png" &gt;&lt;/p&gt;
&lt;h2&gt;編輯視窗提取舊資料&lt;/h2&gt;
&lt;p&gt;編輯視窗會在下拉選單變更對象時提取該項目資料，以供參考。&lt;/p&gt;
&lt;p&gt;使用右鍵選單時，亦會嘗試讀取選中的欄位，自動選到該項目。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/hHMwFx7.png" &gt;&lt;/p&gt;
&lt;p&gt;刪除功能的右鍵選單也會將選中的欄位對應下拉式選單。&lt;/p&gt;
&lt;h2&gt;移除驅動軸面板的暫停功能&lt;/h2&gt;
&lt;p&gt;由於暫停的功能也不算是非常必須，所以將停止的功能拿掉。&lt;/p&gt;
&lt;p&gt;若要中止動畫，直接將面板關掉就好了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Qj26wE2.png" &gt;&lt;/p&gt;
&lt;h1&gt;直線機構問題&lt;/h1&gt;
&lt;p&gt;今天嘗試了 Peaucellier 直線機構的模擬，但是在輸入軸轉動的時候碰到一些障礙。&lt;/p&gt;
&lt;p&gt;直線機構無法立即得知其極限，而之前做的路徑追蹤功能只支援&lt;strong&gt;知道範圍&lt;/strong&gt;的圓周運動。&lt;/p&gt;
&lt;p&gt;不過按理說頂多會回傳約束錯誤的訊息，但是沒想到連一度都無法搖擺，不知道是機構卡死還是什麼問題。&lt;/p&gt;
&lt;p&gt;所以想正視這個情況，讓直線機構也可以在 Pyslvs 上模擬。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/wRWDQ3x.png" &gt;&lt;/p&gt;
&lt;p&gt;應該做一個能夠解極限的功能。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;活塞動力源&lt;/h1&gt;
&lt;p&gt;由於程式庫的技術問題，可能無法計算可以改變長度的被動元件，所以將活塞功能改成直線驅動的連桿，可以嘗試讓一活動點進行固定直線運動。&lt;/p&gt;
&lt;p&gt;構成是由節點、兩固定點構成的直線上作動，跟滑塊不同的是，這個項目是無極限的主動元件，利用增量進行移動（使用者可設定範圍），遇到約束衝突會強制結束。&lt;/p&gt;
&lt;p&gt;預計這個功能要加入驅動面板中，讓這個面板能管理主動軸與活塞動力。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;參數式設計&lt;/h1&gt;
&lt;p&gt;想讓 Pyslvs 加入新的參數設計表，紀錄所有使用者使用的參數，支援使用者自行註解、在表內進行交叉運算。&lt;/p&gt;
&lt;p&gt;這樣修改更快，達成機械設計的目的，跟上大部分 CAD 軟體一樣的功能。&lt;/p&gt;
&lt;p&gt;表格會跟點座標和連桿約束等等的項目存入 Data Sheet 中。&lt;/p&gt;
&lt;p&gt;不過這樣所有新增和編輯界面就得做調整。&lt;/p&gt;
&lt;h1&gt;測量能力&lt;/h1&gt;
&lt;p&gt;測量面板目前只有計算點之間的距離，無法測量角度之類，有些不方便。&lt;/p&gt;
&lt;p&gt;有大量現成的數學公式求解，拿來用在點座標結果上是再好不過了。&lt;/p&gt;
&lt;p&gt;預計之後測量、驅動面板會增強許多，上面提到的解極限的功能或許也會歸類在面板類。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/08</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050908.html" rel="alternate"></link><published>2016-09-08T21:00:00+08:00</published><updated>2016-09-08T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-08:blog/40323230ri-zhi-1050908.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs Demo 功能介紹 錄影準備中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;h2&gt;模擬功能按鈕調整&lt;/h2&gt;
&lt;p&gt;路徑追蹤功能區隔出來，其他兩個面板類的歸在下方。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/le7waBe.png" &gt;&lt;/p&gt;
&lt;p&gt;面板同時只能開啟一個，必須關掉前一個才能切換。&lt;/p&gt;
&lt;p&gt;而開啟新檔時會自動關閉已開啟的面板。&lt;/p&gt;
&lt;h2&gt;路徑座標輸出&lt;/h2&gt;
&lt;p&gt;路徑追蹤功能啟動時做一些小改變，會自動開啟顯示標註。&lt;/p&gt;
&lt;p&gt;現在會將運算後的路徑保留，會顯示在畫面上，使用者可以決定其去留，若是沒刪除，再次執行追蹤功能時結果將覆蓋當前數據。&lt;/p&gt;
&lt;p&gt;因應新增兩個按鈕，分別為清除鈕和結果預覽。&lt;/p&gt;
&lt;p&gt;座標表格亦可匯出成 CSV 表格。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/XQwvacu.png" &gt;&lt;/p&gt;
&lt;p&gt;而不同點的路徑現在會用不同顏色呈現了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/VFH69Nr.png" &gt;&lt;/p&gt;
&lt;p&gt;點外觀的分頁中可以調整路徑粗細。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/BgkLaSS.png" &gt;&lt;/p&gt;
&lt;h2&gt;量測面板&lt;/h2&gt;
&lt;p&gt;量測面板可以計算機構任意兩點間的距離，並且顯示滑鼠座標位置，以供滑鼠附近點的座標參考，座標單位已經為縮放調整了。&lt;/p&gt;
&lt;p&gt;面板開啟時會自動開啟顯示標註。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/36wGlPe.png" &gt;&lt;/p&gt;
&lt;h2&gt;驅動軸面板&lt;/h2&gt;
&lt;p&gt;這個面板可以選擇任意設定好的主動軸調整角度，並且還有慢速播放的功能，不過暫停後等待延遲的缺陷還在找方法修正。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/lBrMQBA.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;影片簡介&lt;/h1&gt;
&lt;p&gt;當初預想的功能大部分都快完成了，剩下一些輸出和防呆的細節處理。&lt;/p&gt;
&lt;p&gt;之後想錄製一點說明影片，介紹基本功能之類的，算是專題資料的一部分。&lt;/p&gt;
&lt;p&gt;而如果找不到輸出給其他 CAD 軟體的方式的話，網頁版可能得沿用目前 Data Sheet 的儲存方式。&lt;/p&gt;
&lt;p&gt;網頁版在這學期學習 Java Script 之後，配合專題所學得的技能，應該有能力做一個圖形化界面出來。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/07</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050907.html" rel="alternate"></link><published>2016-09-07T21:00:00+08:00</published><updated>2016-09-07T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-07:blog/40323230ri-zhi-1050907.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;路徑計算解決&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程式碼功能簡介&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PyQt5 線程 QThread 教學&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PyQt5 信號槽教學&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PyQt5 進度條教學&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;書籤：&lt;/p&gt;
&lt;p&gt;&lt;a href="#QThread"&gt;PyQt 線程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#pyqtSlot"&gt;PyQt 信號槽&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#QProgressBar"&gt;PyQt 進度條&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;路徑計算解決&lt;/h1&gt;
&lt;p&gt;煩惱多日的路徑問題解決了，是靠觀察程式碼產生結果觀察出判斷式有問題。&lt;/p&gt;
&lt;p&gt;在 Qt 表格的回傳值中&lt;strong&gt;不可以這樣用&lt;/strong&gt;，因為永遠不會發生：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
if table_point.item(i, 3).checkState()==True:
    ...
&lt;/pre&gt;

&lt;p&gt;必須這樣用：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
if table_point.item(i, 3).checkState():
    ...
&lt;/pre&gt;

&lt;hr&gt;

&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;h2&gt;程式碼 Demo&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/7C2HXYY.png" &gt;&lt;/p&gt;
&lt;p&gt;這個程式碼使用 matplotlib 繪出圖形，最上端可以設定運算的對象。&lt;/p&gt;
&lt;p&gt;按下「Copy」鈕可以複製到剪貼簿，「Help」鈕會連到之前寫的程式庫網頁。&lt;/p&gt;
&lt;p&gt;PyQt 的剪貼簿用法很簡單：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
clipboard = QApplication.clipboard()
clipboard.setText(self.script.toPlainText())
&lt;/pre&gt;

&lt;p&gt;「Save」可以存成 Python 程式碼，執行過確認沒問題。&lt;/p&gt;
&lt;h2&gt;路徑追蹤&lt;/h2&gt;
&lt;p&gt;追加解析度功能，預設 5 度，最大 45 度，最小到 0.5 度。&lt;/p&gt;
&lt;p&gt;表單也經過篩選，不會加入固定點了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/oorux4u.png" &gt;&lt;/p&gt;
&lt;p&gt;按下「Apply」鈕後會開始執行運算，而且進度條會顯示運算進度（進度無誤）。&lt;/p&gt;
&lt;p&gt;中途隨時可以停止執行，只是一旦停止就會關閉小視窗且刪除暫存資料，要重新計算。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/VRNWAbp.png" &gt;&lt;/p&gt;
&lt;p&gt;執行完畢後，就會自動關閉視窗，呈現路徑圖。&lt;/p&gt;
&lt;p&gt;接著就能調整畫布，用內建的存檔功能存成圖片！&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Uvud38L.png" &gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/MPRQtB5.png" &gt;&lt;/p&gt;
&lt;p&gt;關於路徑追蹤的視窗，其實花了不少功夫研究 Qt 的功能，將 Python 的教學寫在下面。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;&lt;a name="QThread"&gt;&lt;/a&gt;PyQt 線程&lt;/h1&gt;
&lt;p&gt;需要執行序的原因是，程式語言通常會將複雜運算的程序優先度提高，相對畫面的處理較簡單，因此會將「複雜運算」處理完後才會更新畫面顯示。&lt;/p&gt;
&lt;p&gt;若是不想讓視窗凍結，使用排程功能就十分重要，提醒使用者正在運算，亦可以避免輸入過多指令時，因為正在處理「複雜運算」，而無法理會使用者的呼叫。&lt;/p&gt;
&lt;p&gt;線程功能並非平行運算，而是拖慢所有進度，在執行序之間來回處理，以因應多方面需求。&lt;/p&gt;
&lt;p&gt;Python3 雖然有內建 &lt;code&gt;threading&lt;/code&gt; 和 &lt;code&gt;_thread&lt;/code&gt; 的模組，但是還滿難使用與管理的，所以利用 Qt 的功能來替代之。&lt;/p&gt;
&lt;p&gt;可以想像成 QThread 是另一個元件，也是使用 class的方式繼承，基本架構如下：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
class WorkerThread(QThread):
    #這裡是信號（括弧中填入傳出參數類型，沒有就不用）
    #必須擺外面
    done = pyqtSignal(list)

    #初始化
    def __init__(self, parent = None):
        QThread.__init__(self, parent)
        self.stoped = False
        self.mutex = QMutex()

    #執行序（可以很多個）
    def run(self):
        ...
        #完成，發出信號（帶一個 list 參數）
        self.done.emit(nPath)

    #中止序
    def stop(self):
        with QMutexLocker(self.mutex): self.stoped = True
&lt;/pre&gt;

&lt;p&gt;QThread 跟外界溝通的方式是靠信號跟從外部定值（這樣可以從 self 直接讀值）。&lt;/p&gt;
&lt;p&gt;Window 或 Widget 可以如下使用：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
class Path_Track_show(QDialog, Ui_Dialog):
    def __init__(self, parent=None):
        super(Path_Track_show, self).__init__(parent)
        ...
        #定義線程
        self.work = WorkerThread()
        #連接啟動信號
        self.buttonBox.button(QDialogButtonBox.Apply).clicked.connect(self.start)
        #連接強制結束訊號
        self.buttonBox.button(QDialogButtonBox.Cancel).clicked.connect(self.stop)
        #連接完成信號
        self.work.done.connect(self.finish)

    #啟動
    def start(self):
        #傳入值（或任何前置作業）
        self.work.Run_list = self.Run_list
        ...
        #啟動
        self.work.start()
        #關閉按鈕（有關GUI項目）
        #會同時執行work和之後的項目
        self.buttonBox.button(QDialogButtonBox.Apply).setEnabled(False)
        ...

    #強制結束
    def stop(self): self.work.stop()

    #完成
    #信號槽接收值（帶一個 list 參數）
    @pyqtSlot(list)
    def finish(self, Path):
        self.Path_data = Path
        #接收後關閉
        self.accept()
&lt;/pre&gt;

&lt;hr&gt;

&lt;h1&gt;&lt;a name="pyqtSlot"&gt;&lt;/a&gt;PyQt 信號槽&lt;/h1&gt;
&lt;p&gt;信號是 Qt 元件用來溝通的方式，通常是「函式」使用「信號物件」發送訊息給連結的「信號槽」，而配戴此信號槽的函式就會在接收訊息的時候開始執行。&lt;/p&gt;
&lt;p&gt;特別注意 PyQt4 和 PyQt5 的信號連接方式有所不同。&lt;/p&gt;
&lt;p&gt;在一個 class 配置「信號物件」：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
class a(parentA):
    done = pyqtSignal()
&lt;/pre&gt;

&lt;p&gt;這個物件必須擺在 class 中，不過不行在任何函式裡（包括初始化函式 &lt;code&gt;__init__&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;呼叫方式是跟其他同 class 底下的函式同個位階（如 &lt;code&gt;self&lt;/code&gt;.&lt;code&gt;done&lt;/code&gt; 或 &lt;code&gt;a&lt;/code&gt;.&lt;code&gt;done&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;接著在一個函式配置一個信號槽：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
class b(parentB):
    @pyqtSlot()
    def b_1(self):
        ...
&lt;/pre&gt;

&lt;p&gt;然後在需要連接的時段連結它們（亦可以在時機內斷開連結），例如 class b 的初始化：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
class b(parentB):
    def __init__(self, parent=None):
        ...
        self.Come_from_A = a()
        self.Come_from_A.done.connect(self.b_1)
&lt;/pre&gt;

&lt;p&gt;最後就是發送信號的時機，剛才的信號物件是 class a 內的函式都可調用的：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
class a(parentA):
    def a_1(self):
        ...
        self.done.emit()
&lt;/pre&gt;

&lt;p&gt;這樣 class b 內的 b_1 就會執行了。&lt;/p&gt;
&lt;p&gt;這些括弧內都是可以帶入參數的，由於 Qt 是 C++ 寫成的，&lt;code&gt;@pyqtSlot()&lt;/code&gt; 的括弧中是填參數類型。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;&lt;a name="QProgressBar"&gt;&lt;/a&gt;PyQt 進度條&lt;/h1&gt;
&lt;p&gt;知道線程和信號槽的利用後，處理時控制進度條物件就易如反掌了。&lt;/p&gt;
&lt;p&gt;首先在執行前算一下進度條跑滿後的格數（若是迴圈，會在執行一次時加 1，加到滿）：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
self.progressBar.setRange(0, limit)
&lt;/pre&gt;

&lt;p&gt;接著在線程的初始化中設置一個整數 &lt;code&gt;progress_Signal&lt;/code&gt;，從零開始。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
self.progress = 0
&lt;/pre&gt;

&lt;p&gt;執行時的迴圈，用另一個函式發送訊息與增加進度值：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def run(self):
    for i in range(_range_):
        self.progress_going()

def progress_going(self):
        self.progress = self.progress+1
        self.progress_Signal.emit(self.progress)
&lt;/pre&gt;

&lt;p&gt;接收端函式（也許是另一個 class）：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
@pyqtSlot(int)
def progressbar_change(self, val): self.progressBar.setValue(val)
&lt;/pre&gt;

&lt;p&gt;連接（在初始化就可以了）：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
self.work = WorkerThread()
self.work.progress_Signal.connect(self.progressbar_change)
&lt;/pre&gt;

&lt;hr&gt;

&lt;p&gt;最重要的功能做完了，最終也學會了難懂的信號槽（以前都是編譯器幫忙產生的），剩下的功能應該也能順利做完。&lt;/p&gt;
&lt;p&gt;雖然最終沒有在暑假內完成專題的項目，但是也學會許東西，培養出快速統整資料並架構化的能力。&lt;/p&gt;
&lt;p&gt;覺得自己需要多練習語言表達的部份，因為可能統整資料十分明瞭，在口語上卻節奏太快，順著聽者的思路呈現才是最重要的方向。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;p&gt;P.S Roger 用 wordpress 架了一個存文章的網站：&lt;a href="http://roger-blog.tk/" title="roger-blog.tk"&gt;http://roger-blog.tk/&lt;/a&gt;&lt;/p&gt;</summary><category term="Pyslvs"></category><category term="PyQt5"></category></entry><entry><title>40323230日誌 - 105/09/06</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050906.html" rel="alternate"></link><published>2016-09-06T21:00:00+08:00</published><updated>2016-09-06T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-06:blog/40323230ri-zhi-1050906.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;表格管理與程式碼&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;路徑計算問題&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;h2&gt;表格管鏈&lt;/h2&gt;
&lt;p&gt;新增調整連桿和呆鍊順序的功能。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/c5lH4lb.png" &gt;&lt;/p&gt;
&lt;p&gt;但是 slvs 程式庫處理的結果似乎和約束順序無關。&lt;/p&gt;
&lt;p&gt;不論是調整表格順序，還是調動範例 code 裡的順序，結果都一樣。&lt;/p&gt;
&lt;p&gt;點座標的表格現在多了當前座標欄位，和初始座標區隔開。&lt;/p&gt;
&lt;p&gt;運算時是使用初始座標，當前座標是繪圖用的。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/1X4Tfu7.png" &gt;&lt;/p&gt;
&lt;p&gt;這樣按理說產生的點座標和約束條件就和範例一樣了，但是仍然沒解決。&lt;/p&gt;
&lt;h2&gt;程式碼輸出&lt;/h2&gt;
&lt;p&gt;將字串和文字區塊作合併，存成一個 object，但是還未回傳主程式。&lt;/p&gt;
&lt;p&gt;以下是加入點座標的範例。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Script = ""
#初始化
Script += """
sys = System(1000)
p0 = sys.add_param(0.0)
p1 = sys.add_param(0.0)
p2 = sys.add_param(0.0)
Point0 = Point3d(p0, p1, p2)
qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0)
p3 = sys.add_param(qw)
p4 = sys.add_param(qx)
p5 = sys.add_param(qy)
p6 = sys.add_param(qz)
Normal1 = Normal3d(p3, p4, p5, p6)
Workplane1 = Workplane(Point0, Normal1)

p7 = sys.add_param(0.0)
p8 = sys.add_param(0.0)
Point1 = Point2d(Workplane1, p7, p8)
Constraint.dragged(Workplane1, Point1)
"""
...
#加入點
Script += """p"""+str(i+7)+""" = sys.add_param("""+str(float(table_point.item(i, 1).text()))+""")
p"""+str(i+8)+""" = sys.add_param("""+str(float(table_point.item(i, 2).text()))+""")
Point"""+str(i+1)+""" = Point2d(Workplane1, p"""+str(i+8)+""", p"""+str(i+9)+""")
"""
#如果點固定
Script += """Constraint.dragged(Workplane1, Point"""+str(i+1)+""")
"""
&lt;/pre&gt;

&lt;hr&gt;

&lt;h1&gt;路徑計算&lt;/h1&gt;
&lt;p&gt;今天嘗試過許多方法，但是未能讓路徑運算功能的結果與 Python 3 執行範例的結果一樣。&lt;/p&gt;
&lt;p&gt;逐步將其他功能做起來，也許能幫助檢查為何無法算出正確的結果。&lt;/p&gt;
&lt;p&gt;以下是直接將執行範例的結果畫在圖層上，違和感滿大的。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/baYNsJv.png" &gt;&lt;/p&gt;
&lt;p&gt;接著會先著重於程式碼輸出的部份，拿來和範例比對，希望能找出錯誤。&lt;/p&gt;
&lt;p&gt;如果必要的話，也許有些複雜的能會暫時移除。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/05</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050905.html" rel="alternate"></link><published>2016-09-05T21:00:00+08:00</published><updated>2016-09-05T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-05:blog/40323230ri-zhi-1050905.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;小細節修正&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程式碼顯示功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;路徑計算問題&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;h2&gt;繪圖選項&lt;/h2&gt;
&lt;p&gt;新增顯示尺度和反黑背景的選項。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/GR2XV7W.png" &gt;&lt;/p&gt;
&lt;h2&gt;佈署面板&lt;/h2&gt;
&lt;p&gt;由於碰到一些小障礙，所以就先作模擬面板的部份。&lt;/p&gt;
&lt;p&gt;之所以使用嵌入的 Widget，是因為必須一面看著畫布作調整，所以都放在主視窗作業會比較好。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/mzzttQV.png" &gt;&lt;/p&gt;
&lt;p&gt;不過之間的傳輸功能還在研究，和視窗設定的形式不一樣，不能在關閉的瞬間偵測。&lt;/p&gt;
&lt;h2&gt;右鍵選單&lt;/h2&gt;
&lt;p&gt;由於發現會受表格標頭欄厚度的影響，微調了一下右鍵選單的位置，不過這些定值會因為字體大小而改變。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/i1HaiEu.png" &gt;&lt;/p&gt;
&lt;p&gt;拆開滑鼠游標的 X Y 位置作像素調整：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def on_point_context_menu(self, point):
    pos = QPoint(point.x()+43, point.y()+23)
    action = self.popMenu_point.exec_(self.Entiteis_Point.mapToGlobal(pos))
    ...
&lt;/pre&gt;

&lt;p&gt;以及偵測加入項目後出現欄的寬度：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def on_link_context_menu(self, point):
    if self.Entiteis_Link.rowCount()==0: pos = QPoint(point.x()+3, point.y()+23)
    else: pos = QPoint(point.x()+15, point.y()+23)
&lt;/pre&gt;

&lt;h2&gt;存檔提示&lt;/h2&gt;
&lt;p&gt;視窗標題會在修改後，未存檔時多出星號。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/vu3IpEj.png" &gt;&lt;/p&gt;
&lt;p&gt;讀檔、開新檔案、存檔後星號會消失。&lt;/p&gt;
&lt;p&gt;在沒有星號的情形下，關閉程式時不會提示是否存檔。&lt;/p&gt;
&lt;h2&gt;圖形顏色對應&lt;/h2&gt;
&lt;p&gt;利用 Python 的 dict 鍵值功能作顏色對應表，基本概念如下：&lt;/p&gt;
&lt;pre&gt;
dict = {key1 : value1, key2 : value2}
dict[key1] 得 value1
dict[key2] 得 value2
&lt;/pre&gt;

&lt;p&gt;可以使用 zip 來將兩個 list 縫合，顏色代碼對應 Qt 的 Name space。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
self.Color = dict(zip(self.re_Color, val_Color))
&lt;/pre&gt;

&lt;p&gt;這樣就可得（無定義則用綠色）：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
try: pen.setColor(self.Color[self.table_style.item(i, 1).text()])
except KeyError: pen.setColor(Qt.green)
&lt;/pre&gt;

&lt;p&gt;以下是目前支援的顏色表：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/difDk5c.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;Print 程式碼&lt;/h1&gt;
&lt;p&gt;新增一個功能，會在監視窗中 Print 所有迴圈呈現的程式碼。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/IaWfQ3B.png" &gt;&lt;/p&gt;
&lt;p&gt;這個功能目前僅只於 print，之後會做成顯示在視窗中、存成文字的功能。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;路徑計算問題&lt;/h1&gt;
&lt;p&gt;將約束帶入後似乎出現了問題，還在研究如何解決。&lt;/p&gt;
&lt;p&gt;路徑計算功能能夠畫出指定點（可複數）的移動軌跡，設定視窗中使用兩個表單達成這個功能。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/vAZJs5i.png" &gt;&lt;/p&gt;
&lt;p&gt;結果計算後變成 180° 之後的軌跡出現錯亂。&lt;/p&gt;
&lt;p&gt;下圖繪製 Point2 和 Point3 的軌跡，Point3 的圓周運動是一切正常，但是 Point2 在繞回來時運算不知道為何出了嚴重的錯誤，畫在不可能出現的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/VYzwVFZ.png" &gt;&lt;/p&gt;
&lt;p&gt;由於這部份功能的程式滿大的，也是用自己的邏輯手寫的，可能會漏一些沒注意的地方，檢查費了不少功夫。&lt;/p&gt;
&lt;p&gt;原理是用一整個 list object 傳送座標群的，包含選擇的點，從 start angle 到 end angle 的範圍，理論上是三維的。&lt;/p&gt;
&lt;p&gt;不過迴圈迭代時有點小毛病，所以改成 object[0] 是第一個點的 X 軸，object[1] 是 Y 軸，object[2] 是第二個點的 X 軸，以此類推。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#取鏈用的迴圈
for i in range(0, len(self.Path), 2):
    X_path = self.Path[i]
    Y_path = self.Path[i+1]
&lt;/pre&gt;

&lt;p&gt;可能是 slvs 程式庫的約束處理問題，因為我是先將「呆鍊」組成三角形後才約束「連桿」接起，因而動到主動軸的點，產生了這個問題。&lt;/p&gt;
&lt;p&gt;相反地，「客製化」零件的約束順序採用最保險的方式，所以沒有這個問題。&lt;/p&gt;
&lt;p&gt;歸納幾個解決方式，是製作以下功能（都會加入）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;調整表格順序的功能（決定優先權，比較好知道原因）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;優先偵測主動軸的參照點，優先定義與其相關的連桿約束。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之前提到的，因為這部份程式碼滿大的，跨了3個檔案，所以可能要一些時間處理。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/03</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050903.html" rel="alternate"></link><published>2016-09-03T21:00:00+08:00</published><updated>2016-09-03T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-03:blog/40323230ri-zhi-1050903.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;QPaint 繪圖&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模擬功能-目標&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;QPaint&lt;/h1&gt;
&lt;p&gt;其實 QPaint 繪圖就跟 slvs 程式庫滿像的，只需要擔心順序（圖層）問題。&lt;/p&gt;
&lt;p&gt;用 QPaint 繪圖的話，想辦法將最新的座標 copy 進去就行了。&lt;/p&gt;
&lt;p&gt;把繪圖的 Widget 和處理 list 的副程式獨立出來，名為 &lt;code&gt;canvas.py&lt;/code&gt; 和 &lt;code&gt;list_process&lt;/code&gt;，沒什麼影響，讓主程式不會太雜亂。&lt;/p&gt;
&lt;p&gt;Class 中宣告一個名為 &lt;code&gt;update_figure&lt;/code&gt; 的函式，主程式要刷新時就會呼叫，並填進主程式的表單，這個函式就會將所有表單填進 &lt;code&gt;self&lt;/code&gt; 的 object 裡，讓 &lt;code&gt;paintEvent&lt;/code&gt; 函式讀取。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def update_figure(self, table_point, table_line,
        table_chain, table_shaft,
        table_slider, table_rod,
        table_style, zoom_rate):
    self.Xval = []
    self.Yval = []
    zoom = float(zoom_rate.replace("%", ""))/100
    self.table_point = table_point
    ...
    self.update()
&lt;/pre&gt;

&lt;p&gt;之所以這樣寫，是因為 &lt;code&gt;paintEvent&lt;/code&gt; 函式和所有 Qt 的 &lt;code&gt;Event&lt;/code&gt; 函式都不能輸入 &lt;code&gt;event&lt;/code&gt; 以外的參數。&lt;/p&gt;
&lt;p&gt;而且 Qt 有規定 QPainter 只能畫在 &lt;code&gt;paintEvent&lt;/code&gt; 函式中，不然會出錯。而這個函式也同時決定重新繪製的時機（視窗縮放，改變大小時）。&lt;/p&gt;
&lt;p&gt;若想手動刷新，對 Widget 物件下 &lt;code&gt;self.update()&lt;/code&gt; 或 &lt;code&gt;self.repaint()&lt;/code&gt;（不建議，閃爍頻率高）就行了。&lt;/p&gt;
&lt;p&gt;而 &lt;code&gt;event&lt;/code&gt; 參數是專門傳入事件發生相關的數據，如滑鼠座標：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def mouseMoveEvent(self, event):
    if self.drag:
        self.origin_x = event.x()
        self.origin_y = event.y()
        self.update()
&lt;/pre&gt;

&lt;p&gt;能夠繪圖後，必須校正視圖的大小和位置，由於大小要看這個機構的基本尺寸是多少，所以給使用者自己調整是最好的方法了。&lt;/p&gt;
&lt;p&gt;預設是將座標尺度放大兩倍後定義為畫布的一倍，所以剛才的 &lt;code&gt;update_figure&lt;/code&gt; 中有下列轉換式：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
for i in range(table_point.rowCount()):
    self.Xval += [float(table_point.item(i, 1).text())*zoom*rate_all]
    self.Yval += [float(table_point.item(i, 2).text())*zoom*rate_all*(-1)]
&lt;/pre&gt;

&lt;p&gt;Y 軸座標乘上負號是因為不論 Window 和 Widget，兩者都是從「標題欄」往下延伸的，所以向下是負值。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/tqzbuxp.png" &gt;&lt;/p&gt;
&lt;p&gt;上次更新中加入沒用到的 QSlider 滑桿，這次讓它能夠定義放大的倍率，從 50％ 到 500％，應該都能夠支援幾乎所有尺度的機構了。&lt;/p&gt;
&lt;p&gt;另外調整畫布大小可以用 &lt;kbd&gt;Ctrl&lt;/kbd&gt; + 滑鼠滾輪調整，&lt;kbd&gt;Ctrl&lt;/kbd&gt; + 左鍵按住拖移或雙擊可以定義原點位置。&lt;/p&gt;
&lt;p&gt;這樣設定是讓使用者不會亂拉將圖面移走，也更能知道機構樣貌。&lt;/p&gt;
&lt;p&gt;而這次顏色設定暫時只有 R、G、B 三色，其他色碼的加入還要看下說明文件，原本的顏色都偏亮或太黯淡，所以會整合後加入其他顏色。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;＊上次的 mpl 畫布就有加入存成 png 圖片的功能了，想不到現在 QPainter 也能如法炮製。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;好像大部分 Widget 都能用這個方式截圖，不過 OpenGL 不知道可不可行。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
fileName, sub = QFileDialog.getSaveFileName(self, 'Save file...', '../', 'PNG file(*.png)')
if fileName:
    fileName = fileName.replace(".png", "")
    fileName += ".png"
    pixmap = self.mplWindow.grab()
    pixmap.save(fileName)
&lt;/pre&gt;

&lt;hr&gt;

&lt;h1&gt;模擬功能&lt;/h1&gt;
&lt;p&gt;主要關鍵都在 Drive Shaft （驅動軸）的清單上，太多驅動軸就會有很多組解，可能要慢慢代入；活塞部份還沒想到怎做。&lt;/p&gt;
&lt;p&gt;期望模擬的部份有如下效果：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;畫出機構運動時指定點（可複數）路徑，路徑可以用線條或打點的方式繪出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相關動畫的展示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用者觀看自訂角度（滑鼠在圖面上拖拉最佳）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;測量工具（指定點距離）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/02</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050902.html" rel="alternate"></link><published>2016-09-02T21:00:00+08:00</published><updated>2016-09-02T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-02:blog/40323230ri-zhi-1050902.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;改換 Qt 5.7 與 PyQt 5.7&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一些操作重點&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Qt 5.3 -&amp;gt; 5.7&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Qt 5.8 預計今年11月29日釋出穩定版&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;一些繪圖功能需要較高的 Qt 版本才支援，所以選擇升級了當前的函式庫。&lt;/p&gt;
&lt;p&gt;將需要的 Qt 版本載下來，不須舊版的話可以刪掉。&lt;/p&gt;
&lt;p&gt;要切換 Qt 的版本，必須修改之前的 &lt;code&gt;.bashrc&lt;/code&gt; 的目錄至切換的版本，並重新建立 QMake 的軟連結，這樣就可以了（對 C++ 的使用者來說）。&lt;/p&gt;
&lt;pre&gt;
$sudo rm -f /usr/bin/qmake
$sudo ln -s /opt/Qt/5.7/gcc_64/bin/qmake /usr/bin/qmake
&lt;/pre&gt;

&lt;p&gt;但是對其他語言的使用者來說，必須將接口套件的設定一起切換版本，所以得重新安裝 Python 的 PyQt（亦或 PySide）。&lt;/p&gt;
&lt;p&gt;使用下列指令刪除 PyQt：&lt;/p&gt;
&lt;pre&gt;
$sudo rm -r -f /usr/lib/python3/dist-packages/PyQt5
&lt;/pre&gt;

&lt;p&gt;然後從&lt;a href="https://riverbankcomputing.com/software/pyqt/download5" title="riverbankcomputing.com"&gt;官方載點&lt;/a&gt;下載 Linux 版本。&lt;/p&gt;
&lt;p&gt;照著之前的範例重新安裝 PyQt、QScintilla2、Eric6，並修改 Eric6 的相關設定。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/CAdFahb.png" &gt;&lt;/p&gt;
&lt;p&gt;裝完後，若 Eric 安裝時出現版本過低的狀況，就必須完全刪除 PyQt 再重新安裝。&lt;/p&gt;
&lt;p&gt;若是出現缺少一些套件的狀況，請使用 &lt;code&gt;apt-get&lt;/code&gt; 下載安裝，相關名稱如下網站所示。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://packages.ubuntu.com/search?keywords=python3-pyqt5" title="packages.ubuntu.com"&gt;http://packages.ubuntu.com/search?keywords=python3-pyqt5&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;安裝後檢查&lt;/h1&gt;
&lt;p&gt;即使安裝完成，都能啟動或匯入相關套件，因為是重新安裝，還是得檢查一下是否載到舊版的檔案。&lt;/p&gt;
&lt;p&gt;在 Python3 的直譯器中檢查：&lt;/p&gt;
&lt;pre&gt;
&gt;&gt;&gt;from PyQt5.QtCore import qVersion
&gt;&gt;&gt;print("Qt Version: {0}".format(qVersion.strip()))
#顯示 Qt 版本

&gt;&gt;&gt;from PyQt5.QtCore import PYQT_VERSION_STR as pyqtVersion
&gt;&gt;&gt;print("PyQt Version:", pyqtVersion.strip())
#顯示 PyQt 版本
&lt;/pre&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/MBTakmh.png" &gt;&lt;/p&gt;
&lt;p&gt;在 Eric6 的 Settings -&amp;gt; Show extermal tools 選項中，載入所有相關的工具版本。&lt;/p&gt;
&lt;p&gt;下圖中的 Qt 工具版本均要一致，選擇的部份是 PyQt，非常重要，因為和 Python 中顯示的版本是一樣的。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/KtevLeH.png" &gt;&lt;/p&gt;
&lt;p&gt;另一個就是觀察 Qt 附的相關工具，不過只要載對版本應該都是對的，僅供參考。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/rbnu8Gy.png" &gt;&lt;/p&gt;
&lt;p&gt;新版的 Qt 工具也會支援新功能。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/nyrxK7y.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;稍微看過上次範例倉儲的程式碼，QPainter 是可以和 QOpenGL 的元件組合使用的，不過如果直接插入空的圖形化元件，會造成程式視窗內黑屏，應該要另外設定。&lt;/p&gt;
&lt;p&gt;新版的 Qt 支援 OpenGL3D 的嵌入，會找一些範例，作到和之前 bokeh 套件相仿的功能，再把其他運算功能補齊（或許之後會做銜接其他 CAD 軟體的格式），本機解題+繪圖專案就完成了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/LuIz34p.png" &gt;
&lt;img src="http://i.imgur.com/tKoNPIx.png" &gt;&lt;/p&gt;
&lt;p&gt;專題在 Python Solvespace 的部份在想要如何結構化，因為尚未圖形化的編譯部份比較難呈現，如果將現成的程式理論搬上報告又有點太「資訊系」和發散了些。&lt;/p&gt;
&lt;p&gt;預計報告中會包含一部分原版 Solvespace 的解說，還有 SWIG 相關的原始碼呈現。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/01</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050901.html" rel="alternate"></link><published>2016-09-01T21:00:00+08:00</published><updated>2016-09-01T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-01:blog/40323230ri-zhi-1050901.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一些 QPainter 及 OpenGL 的資料連結&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;p&gt;今天花時間在整修細節的部份（包括讀寫檔和繪圖時機），所以只有暫時將 matplotlib 的畫布隱藏到參數 &lt;code&gt;-mpl&lt;/code&gt; 裡。&lt;/p&gt;
&lt;p&gt;想要用 matplotlib 繪圖時要加上上述參數，不然只會使用 QPainter 的 Widget。&lt;/p&gt;
&lt;p&gt;不過這個地方還沒做好，還沒研究 QPainter 上的細節。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/uX1kSGK.png" &gt;&lt;/p&gt;
&lt;p&gt;另外將 crank_rocker 範例存成 Pyslvs 可用的 CSV 表格，可以隨時讀進來 Demo。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/ulsX1Jl.png" &gt;&lt;/p&gt;
&lt;p&gt;至於繪圖時機，採用的是 resizeEvent，當偵測到 Widget 大小改變時會觸發。&lt;/p&gt;
&lt;p&gt;原先想使用 paintEvent，但是不知道為何改用在主視窗後就會一直重新整理，很吃資源，所以只好改用相近的 resizeEvent。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;QPainter 及 OpenGL 參考資料&lt;/h1&gt;
&lt;p&gt;官方 Qt 文件： &lt;a href="http://doc.qt.io/qt-5/qpainter.html" title="doc.qt.io"&gt;http://doc.qt.io/qt-5/qpainter.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;OpenGL 範例： &lt;a href="https://github.com/baoboa/pyqt5/tree/master/examples/opengl" title="github.com"&gt;https://github.com/baoboa/pyqt5/tree/master/examples/opengl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;還沒深入看過介紹，只看過一些簡單的 QPainter 範例。&lt;/p&gt;
&lt;p&gt;另外 PyQt5 的 QOpenGLWidget 要另外安裝：&lt;/p&gt;
&lt;pre&gt;
$sudo apt-get install python3-pyqt5.qtopengl
$sudo apt-get install libqt5opengl5
&lt;/pre&gt;

&lt;p&gt;不過安裝套件一直有麻煩，已經是最新版可是 import 還是找不到，在想是不是安裝位置問題。&lt;/p&gt;
&lt;p&gt;網際應用程式方面只查到 PHP 與 OpenGL 整合的範例，Qt 的部份貌似只能在本機端執行。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/08/31</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050831.html" rel="alternate"></link><published>2016-08-31T21:00:00+08:00</published><updated>2016-08-31T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-31:blog/40323230ri-zhi-1050831.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度 - 繪圖功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;畫布嵌入&lt;/h1&gt;
&lt;p&gt;成功嵌入畫布，使用另一個繼承自 &lt;code&gt;matplotlib&lt;/code&gt;.&lt;code&gt;backends&lt;/code&gt;.&lt;code&gt;backend_qt5agg&lt;/code&gt;.&lt;code&gt;FigureCanvasQTAgg&lt;/code&gt;（更名為&lt;code&gt;FigureCanvas&lt;/code&gt;）的 class 函式 &lt;code&gt;DynamicMplCanvas&lt;/code&gt;來繪製點座標。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/lRrnk7z.png" &gt;&lt;/p&gt;
&lt;p&gt;這個 class 只包含三個功能，初始化圖形、清除畫布、更新畫布。&lt;/p&gt;
&lt;p&gt;而在主視窗的 &lt;code&gt;__init__&lt;/code&gt; 中初始在預設的 Layout 中嵌入一個 Widget（名稱為「mplWindow」），複製 &lt;code&gt;DynamicMplCanvas()&lt;/code&gt; 的格式來用。&lt;/p&gt;
&lt;p&gt;當初 &lt;code&gt;DynamicMplCanvas()&lt;/code&gt; 是參考自網站範例：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://matplotlib.org/examples/user_interfaces/embedding_in_qt4.html" title="matplotlib.org"&gt;http://matplotlib.org/examples/user_interfaces/embedding_in_qt4.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;後來改寫成可以匯入鏈格代參數的功能。&lt;/p&gt;
&lt;p&gt;鏈目前畫布只有支援繪製節點、連桿和呆鍊，以下是繪製未約束的呆鍊。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/XZfsLGI.png" &gt;&lt;/p&gt;
&lt;p&gt;而另外也修正一些程式庫帶入重疊點的問題，會自動增加偏移量。&lt;/p&gt;
&lt;p&gt;表格在畫布重新繪製時也會作修改，重新繪製的功能目前是&lt;em&gt;手動的&lt;/em&gt;，所以還待改進。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/08/30</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050830.html" rel="alternate"></link><published>2016-08-30T21:00:00+08:00</published><updated>2016-08-30T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-30:blog/40323230ri-zhi-1050830.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;p&gt;寫了算點程式（&lt;code&gt;calculation.py&lt;/code&gt;）的雛型，目前只 &lt;code&gt;print&lt;/code&gt; 出來結果，還沒直接寫進表格。&lt;/p&gt;
&lt;p&gt;而以後模擬的路徑座標功能會寫在同個檔案裡。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/SIZhCiM.png" &gt;&lt;/p&gt;
&lt;p&gt;由於 Python 在記憶體中的物件名稱不能撞名，所以如果是用 launch 腳本來帶動整個程式執行的話，若其中有部件互相 &lt;code&gt;import&lt;/code&gt; ，會造成暫存檔重疊而無法載入，這種方法只適用啟動一端的腳本。&lt;/p&gt;
&lt;p&gt;所以在 class 中寫了一條指令 &lt;code&gt;Reload_Canvas&lt;/code&gt;，讓它將表格物件代入 &lt;code&gt;calculation.py&lt;/code&gt; 的 &lt;code&gt;table_process&lt;/code&gt; 中，回傳點座標的 list 回來。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Reload_Canvas&lt;/code&gt; 打算也會有判斷 Solve 成功或失敗的功能，會跳出警告，亦不會覆寫到原本的表格上。&lt;/p&gt;
&lt;p&gt;程式碼大約的樣子：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Ayh1BHm.png" &gt;&lt;/p&gt;
&lt;p&gt;執行結果（加入 Point2 後回傳第三組點座標）：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/o8iA22K.png" &gt;&lt;/p&gt;
&lt;p&gt;目前加入 Link 的表單，約束距離的功能正常。&lt;/p&gt;
&lt;p&gt;不過碰到無法對重合點作距離約束的情況，可能要提前作座標修正（增加間隙）。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;Reload_Canvas 函式應當是在表格增刪或是編輯後執行，不過如果顯示失敗的話相當麻煩，可能之後會做1步復原功能之類的。&lt;/p&gt;
&lt;p&gt;而繪圖功能比較沒那麼繁瑣，會拖比較後面。&lt;/p&gt;
&lt;p&gt;隔天要回虎尾搬遷宿舍，所以能利用時間較少，預計下午後做好 &lt;code&gt;table_process&lt;/code&gt; 整體功能，包括座標修正的判斷。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/08/29</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050829.html" rel="alternate"></link><published>2016-08-29T21:00:00+08:00</published><updated>2016-08-29T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-29:blog/40323230ri-zhi-1050829.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SQLite 資料&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;p&gt;新增一個類似活塞／彈簧的連結器，可以自訂最大和最小拉伸長度。&lt;/p&gt;
&lt;p&gt;造型方面應該只會改線段顏色。&lt;/p&gt;
&lt;p&gt;不過不知道程式方面怎寫，因為程式庫中沒有類似約束，可能要寫在外部，帶入最大值／最小值／範圍內（不須約束）的結果。&lt;/p&gt;
&lt;p&gt;至於彈簧的彈性效果可能作不太出來，所以目前是朝活塞桿設計。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/uZrfXYx.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;SQLite 資料庫&lt;/h1&gt;
&lt;p&gt;上網找了一些有關寫入寫出 Data Base 的範例，主要是 Python 官方的解說。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://docs.python.org/3.4/library/sqlite3.html" title="docs.python.org"&gt;https://docs.python.org/3.4/library/sqlite3.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://www.runoob.com/sqlite/sqlite-python.html" title="runoob.com"&gt;http://www.runoob.com/sqlite/sqlite-python.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/UwwvSQ5.png" &gt;&lt;/p&gt;
&lt;p&gt;不過主要還是研究 peewee 套件的功能。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://docs.peewee-orm.com/en/latest/peewee/quickstart.html" title="docs.peewee-orm.com"&gt;http://docs.peewee-orm.com/en/latest/peewee/quickstart.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;peewee 的用法比較直覺化一些，畢竟不用對 C++ 資料庫下指令。&lt;/p&gt;
&lt;p&gt;不過上網找了一下 FreeCAD 的技術文件，沒有提到關於 Data Base 如何匯入 2D 圖形的解說，只有模擬材料表的格式。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.freecadweb.org/wiki/index.php?title=Material" title="freecadweb.org"&gt;http://www.freecadweb.org/wiki/index.php?title=Material&lt;/a&gt;&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/08/28</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050828.html" rel="alternate"></link><published>2016-08-28T21:00:00+08:00</published><updated>2016-08-28T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-28:blog/40323230ri-zhi-1050828.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;測試程式庫能否支援 Python 的 list 型態&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;h2&gt;旋轉軸及滑鏈清單&lt;/h2&gt;
&lt;p&gt;和點、連桿、呆鍊一樣都有增刪功能，不過還沒支援右鍵選單。&lt;/p&gt;
&lt;p&gt;一些細節也可能還沒做好，需要一些時間修正。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/rWzmiDc.png" &gt;&lt;/p&gt;
&lt;h2&gt;CSV 匯出入功能調整&lt;/h2&gt;
&lt;p&gt;現在可以支援匯出整個工作簿存檔，並能完整載入所有表格。&lt;/p&gt;
&lt;p&gt;意味著可以保留工作階段而不會遺失。&lt;/p&gt;
&lt;p&gt;在每個表格間插入的是 &lt;code&gt;Next_table&lt;/code&gt; 這個欄位來辨識。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/obOpMJz.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;算點程式測試&lt;/h1&gt;
&lt;p&gt;打算使用 Python 的 list 來存 SLVS 程式庫的 &lt;code&gt;Point&lt;/code&gt; 或 &lt;code&gt;Line&lt;/code&gt;，對迴圈的相性比較好。&lt;/p&gt;
&lt;p&gt;所以建立了一個清單物件 &lt;code&gt;draw&lt;/code&gt;，來測試看看能不能存入後提出來給約束函式用。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/IoRqjaT.png" &gt;&lt;/p&gt;
&lt;p&gt;結果是可行的。&lt;/p&gt;
&lt;p&gt;上面測試寫法有點累贅，應該直接用 &lt;code&gt;draw += [Point]&lt;/code&gt; 加入清單就可以了。&lt;/p&gt;
&lt;p&gt;這樣支援迴圈讀取就十分不錯了，只是在 &lt;code&gt;import&lt;/code&gt; 的部份還需要另外測試。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/08/27</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050827.html" rel="alternate"></link><published>2016-08-27T21:00:00+08:00</published><updated>2016-08-27T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-27:blog/40323230ri-zhi-1050827.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Linkage 的參考心得&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;運動約束類型&lt;/h1&gt;
&lt;p&gt;打算使用主動旋轉軸和滑塊用在繪製動態圖或是移動路徑上。&lt;/p&gt;
&lt;p&gt;旋轉軸可以在定義的角度範圍中旋轉，滑塊則是一個被約束在直線上的點（至於滑動範圍不知道程式庫是否能辦得到）。&lt;/p&gt;
&lt;p&gt;在模擬選項中可以調整：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;靜態移動 - 所有旋轉軸待在某個角度時，整體機構的外觀狀態。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;移動路徑 - 指定一點位置，轉動所有旋轉軸（或自訂），畫出移動路徑。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目前旋轉軸和滑塊的新增方式都和其他實體一樣。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;字型大小&lt;/h1&gt;
&lt;p&gt;系統會因為字型大小的問題而跑出外框，只能調整多一點的空間給太大的字。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/mE1vIkO.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;Linkage&lt;/h1&gt;
&lt;p&gt;參考了技術手冊的介紹和使用說明，Linkage 有一些滿複雜的功能，也支援彈簧計算之類的。&lt;/p&gt;
&lt;p&gt;應該能夠在 Pyslvs 中加入一些值得使用的優點，不過實作性要先評估。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/08/26</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050826.html" rel="alternate"></link><published>2016-08-26T21:00:00+08:00</published><updated>2016-08-26T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-26:blog/40323230ri-zhi-1050826.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一些後續寫法想法&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;圖層統整&lt;/h1&gt;
&lt;p&gt;重新編排了圖層，以在縮放視窗時還能對齊調整大小，不過空間判定上還需要調整參數，才能達到理想的結果。&lt;/p&gt;
&lt;p&gt;另外有研究下 PyQt 嵌入 matpoltlib 繪圖的資料，大約知道該如何嵌入繪出的結果了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/DyQCMsS.png" &gt;&lt;/p&gt;
&lt;h2&gt;右鍵選單&lt;/h2&gt;
&lt;p&gt;嘗試寫了表格的右鍵選單，功能等同於叫出新增、刪除和編輯的對話方塊。&lt;/p&gt;
&lt;p&gt;不過位置無法置中，參數可能還要看一下。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Qdu2JpG.png" &gt;
鏈
從屬項目刪除&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;刪除點時會將包含這個點的連桿或呆鍊一起刪除。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/viCG92Z.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;程式結構&lt;/h1&gt;
&lt;p&gt;之後大約會將 import 程式庫的程式碼放在 &lt;code&gt;main.py&lt;/code&gt; 同層的資料夾下，互相載入。&lt;/p&gt;
&lt;p&gt;而 &lt;code&gt;main.py&lt;/code&gt; 中會有一個專門的 def 放在主視窗的 class 外，好讓算點的程式可以讀表格的資料。&lt;/p&gt;
&lt;p&gt;以下是原始碼結構，括弧中還待建構。&lt;/p&gt;
&lt;pre&gt;
Pyslvs
    launch_pyslvs.py（啟動檔）
    icons_rc.py（圖示資源）
    +icons（讀取用圖示）
    +core
        main.py（主程式-待加入）
        （算點程式.py）
        slvs.py
        _slvs.so
        libslvs.so
        +draw（繪圖表管理視窗-已完成）
        +info（提示與說明視窗-待加入）
        +warning（警告視窗-待加入）
        +（模擬表管理視窗）
        +（一些給使用者的設定檔）
&lt;/pre&gt;

&lt;hr&gt;

&lt;p&gt;今天由於花了些時間更新 Ubuntu 版的顯示卡驅動，所以拖了一些時間。&lt;/p&gt;
&lt;p&gt;之後會快點將核心的算點功能做好。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/08/24</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050824.html" rel="alternate"></link><published>2016-08-24T21:00:00+08:00</published><updated>2016-08-24T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-24:blog/40323230ri-zhi-1050824.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;p&gt;鏈鏈新增了管理物件（點、連線、呆鍊）的功能。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/ItXXzqt.png" &gt;&lt;/p&gt;
&lt;h2&gt;刪除物件&lt;/h2&gt;
&lt;p&gt;在選單中選取名稱即可刪除。&lt;/p&gt;
&lt;p&gt;不過還沒為刪除點的連帶影響作調整。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/83q2bA7.png" &gt;&lt;/p&gt;
&lt;h2&gt;編輯物件&lt;/h2&gt;
&lt;p&gt;可以重新複寫物件的狀態而不用刪除。&lt;/p&gt;
&lt;p&gt;包括重新調整點的位置和固定狀態。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/IUbVmBj.png" &gt;&lt;/p&gt;
&lt;h2&gt;點外觀&lt;/h2&gt;
&lt;p&gt;紀錄點的外觀，包括用環圈起來，並能讓使用者直接調整其大小和顏色。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/pVwY0sP.png" &gt;&lt;/p&gt;
&lt;h2&gt;CSV匯入功能&lt;/h2&gt;
&lt;p&gt;後來有把匯出功能調整一下，可以用 &lt;code&gt;Fixed&lt;/code&gt; 和 &lt;code&gt;noFixed&lt;/code&gt; 紀錄點的固定狀態了。&lt;/p&gt;
&lt;p&gt;所以在讀值時，可以將每列的物件精準填入點的列表中。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/qL1OB6X.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;因為要讓其他 &lt;code&gt;.py&lt;/code&gt; 檔讀值，又要回傳回 &lt;code&gt;main.py&lt;/code&gt; 中，想要可以浮動創造 Point 並新增約束的功能，所以在思考執行的可行性。&lt;/p&gt;
&lt;p&gt;有嘗試過兩個檔案互相 &lt;code&gt;import&lt;/code&gt;，不過出錯的機率很大，上網尋找的建議是 import 兩邊的檔名就好，需要該物件才會特別指定。&lt;/p&gt;
&lt;p&gt;也就是說直接指定 def 或 class 就會出錯，之後會試試看。&lt;/p&gt;
&lt;p&gt;想要找一個比較保險的方式計算，不然只能盡量避開會衝突的地方。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/08/23</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050823.html" rel="alternate"></link><published>2016-08-23T21:00:00+08:00</published><updated>2016-08-23T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-23:blog/40323230ri-zhi-1050823.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;p&gt;Pyslvs 的界面大致上完成，表單的增加功能都寫好了。&lt;/p&gt;
&lt;h2&gt;主界面&lt;/h2&gt;
&lt;p&gt;右側打算作為繪圖區，只要左邊表單有更動就會更新。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/6X6JNKO.png" &gt;&lt;/p&gt;
&lt;h2&gt;增加線條選單&lt;/h2&gt;
&lt;p&gt;讀取既有兩點來規定距離，若為重複點或是點的數目不足就會警告。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i鏈imgur.com/RpYilr鏈.png" &gt;&lt;/p&gt;
&lt;p&gt;增加呆鍊選單鏈鏈---&lt;/p&gt;
&lt;p&gt;只能新增三角形呆鍊，不過以解連桿的工具而言，三角形呆鍊已經夠實用。&lt;/p&gt;
&lt;p&gt;同樣會在違反規則時警告。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/m9a1JTe.png" &gt;&lt;/p&gt;
&lt;h2&gt;匯出CSV能力&lt;/h2&gt;
&lt;p&gt;成功撰寫將點座標匯出成CSV的功能。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/zziWbkn.png" &gt;&lt;/p&gt;
&lt;p&gt;在其他工作表軟體的匯入畫面。&lt;/p&gt;
&lt;p&gt;以後會在動態模擬那裡針對點座標作相同的功能。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Unis1dy.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;大部分的功能由於都沒接觸過，每換一種元件都要上網搜尋它們取值、設值的用法，Qt 的相關介紹又都是以 C++ 撰寫的，為此研究了一下 Python 物件導向的說明。&lt;/p&gt;
&lt;p&gt;由於再過 2 天就要回去家裡了，所以會盡量將需要整合的工作完成，回去後仍會繼續整理資料。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/08/21</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050821.html" rel="alternate"></link><published>2016-08-21T21:00:00+08:00</published><updated>2016-08-21T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-21:blog/40323230ri-zhi-1050821.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Leo editor 輸入法問題&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;p&gt;目前編譯的圖形化界面使用常見的功能表做命令設定。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/6iqBDFs.png" &gt;&lt;/p&gt;
&lt;p&gt;不過只有外表，實際功能還需要連結。&lt;/p&gt;
&lt;p&gt;目前只有控制視窗縮放，結束執行，連結說明網頁的功能。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;Leo Editor&lt;/h1&gt;
&lt;p&gt;自從安裝過新版的 Qt 5.3 和 5.7 後 Leo Editor 就怪怪的，無法切換英文以外的輸入法，啟動時 Leo Editor 是使用 5.3 版。&lt;/p&gt;
&lt;p&gt;而使用 Python 2 啟動是使用 Qt 4，所以沒這個問題，但是就無法使用 Pelican。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/08/20</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050820.html" rel="alternate"></link><published>2016-08-20T21:00:00+08:00</published><updated>2016-08-20T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-20:blog/40323230ri-zhi-1050820.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安裝 eric 6 成功&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;圖形介面計畫：Pyslvs&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Eric 6&lt;/h1&gt;
&lt;p&gt;透過一些安裝教學的資料，成功將 Eric 6.1.8 安裝於 Ubuntu 上。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/idber/article/details/40076821" title="blog.csdn.net"&gt;http://blog.csdn.net/idber/article/details/40076821&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/t7NXOkq.png" &gt;&lt;/p&gt;
&lt;p&gt;不過由於安裝位置及主程式運作的關係，執行時必須給予 Root 權限。&lt;/p&gt;
&lt;pre&gt;
$sudo  eric6
&lt;/pre&gt;

&lt;p&gt;若是沒給予權限，會造成 Eric 顯示一系列錯誤後關閉。&lt;/p&gt;
&lt;p&gt;而透過 Eric 建立的目錄，會被轉為 Root 的所有權，所以必須改回給其他使用者使用。&lt;/p&gt;
&lt;pre&gt;
$sudo chmod -c 777 目錄名稱
mode of ‘目錄名稱’ changed from 0755 (rwxr-xr-x) to 0777 (rwxrwxrwx)
&lt;/pre&gt;

&lt;p&gt;目前還在摸索 Qt 相關的教學，發現有許多自訂功能，包括圖示界面和呼叫傳輸之類，稍作了解應該就能達成相關效果。&lt;/p&gt;
&lt;p&gt;Eric 的語言問題在於外部程式（Qt 設計師之類的），會偵測系統語言作變更，但是主程式卻不會如此，所以本體改成英文後，附屬的程式仍然是繁體中文。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Xv34qIx.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;Pyslvs&lt;/h1&gt;
&lt;p&gt;將圖形化包裝的 Python Solvespace 程式暫定名為 Pyslvs，如果覺得定名不妥就之後再變更。&lt;/p&gt;
&lt;p&gt;當界面有基本雛型之後會上傳至倉儲，之後會陸續更新表單按鈕的功能連結。&lt;/p&gt;
&lt;p&gt;Pyslvs 目前在 Ubuntu 系統上開發，因為 Ubuntu 目前好像沒有一個如 Linkage 之類的模擬程式，使用 LibreCAD 或是 FreeCAD 又會太佔資源，所以想做這個工具給 Ubuntu 系統用。&lt;/p&gt;
&lt;p&gt;剛開始評估的困難點可能是如何呈現 2D 圖形在 Qt 界面上吧。其他如輸出成程式碼之類的應該用普通的 &lt;code&gt;.py&lt;/code&gt; 程式就能辦到了。&lt;/p&gt;</summary><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/08/19</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050819.html" rel="alternate"></link><published>2016-08-19T21:00:00+08:00</published><updated>2016-08-19T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-19:blog/40323230ri-zhi-1050819.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;紀錄 GCC 和 CMake 在 Ubuntu 上安裝的方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;紀錄 Ubuntu 網誌編譯環境&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;為推廣學員使用 Ubuntu 作業系統，紀錄一些安裝軟體的方式。&lt;/p&gt;
&lt;p&gt;紀錄如何建構 Ubuntu (ezgo) 的作業環境。&lt;/p&gt;
&lt;p&gt;官方版本的 Ubuntu 更新較快，已經到了 &lt;code&gt;16.04&lt;/code&gt;，教育部的 ezgo 使用 Ubuntu 14.04，使用上較多推薦工具，不用再自己尋找，不過也會安裝一些可能不會用到的套件。&lt;/p&gt;
&lt;p&gt;目前使用感想是 ezgo 的 KDE 界面還滿方便的，終端機能提供比 Windows 更多的功能，而且硬體支援度非常良好，即使使用非官方驅動程式，運作甚至會比任何版本的 Windows 更加流暢。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;GNU 工具&lt;/h1&gt;
&lt;p&gt;完整版的 ezgo 預設沒有安裝 g++，使用精簡版的 Ubuntu 亦必須自己安裝這兩套編譯工具。&lt;/p&gt;
&lt;p&gt;使用下列指令安裝 GCC。&lt;/p&gt;
&lt;pre&gt;
$sudo apt-get install gcc
$sudo apt-get install g++
&lt;/pre&gt;

&lt;p&gt;使用下列指令安裝 CMake，不過由於提供者版本的問題，可以稍候安裝。&lt;/p&gt;
&lt;pre&gt;
$sudo apt-get install cmake
&lt;/pre&gt;

&lt;p&gt;在沒使用其他提供者的情況下，gcc 的最新版本只會到 &lt;code&gt;4.9&lt;/code&gt;，所以想安裝 gcc 5.0 以上的版本，必須加入信任來源。&lt;/p&gt;
&lt;p&gt;同樣地，在沒使用其他提供者的情況下，CMake 的最新版本無法到 &lt;code&gt;3.x&lt;/code&gt;，也要另一個信任來源。&lt;/p&gt;
&lt;p&gt;加入信任來源後，使用 &lt;code&gt;apt-get update&lt;/code&gt; 指令或是圖形界面的 Ubuntu 管理中心時，就會將你的提供者也加入搜尋。&lt;/p&gt;
&lt;pre&gt;
$sudo add-apt-repository ppa:ubuntu-toolchain-r/test #gcc 的提供者
$sudo add-apt-repository ppa:george-edison55/cmake-3.x #cmake 的提供者
$sudo apt-get update
$sudo apt-get install gcc-5
$sudo apt-get install g++-5
$sudo apt-get install cmake
&lt;/pre&gt;

&lt;p&gt;這時只能使用 &lt;code&gt;gcc-5&lt;/code&gt; 指令啟動 gcc 5.x，使用一般的 &lt;code&gt;gcc&lt;/code&gt; 指令只會啟動最新的 &lt;code&gt;4.x&lt;/code&gt; 的版本。&lt;/p&gt;
&lt;p&gt;因此必須將指令連結過去。&lt;/p&gt;
&lt;pre&gt;
$alias gcc='gcc-5'
$alias g++='g++-5'
&lt;/pre&gt;

&lt;p&gt;下圖是完成畫面，用 &lt;code&gt;gcc --version&lt;/code&gt; 指令來檢查編譯器的版本（g++ 的版本應該也會相同）。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/8Di87en.png" &gt;&lt;/p&gt;
&lt;p&gt;附註：想移除提供者也很簡單，只要加上 &lt;code&gt;--remove&lt;/code&gt; 參數就行。&lt;/p&gt;
&lt;pre&gt;
$sudo add-apt-repository --remove ppa:提供者來源
&lt;/pre&gt;

&lt;hr&gt;

&lt;h1&gt;Leo Editor&lt;/h1&gt;
&lt;p&gt;注意：Leo Editor 在 Python 3.5 中的 Pelican 會產生錯誤，所以請使用 Python 3.4 以下的 Python3 版本。&lt;/p&gt;
&lt;p&gt;使用下列指令從官方倉儲下載 Leo Editor。&lt;/p&gt;
&lt;pre&gt;
$cd "安裝位置"
$git clone https://github.com/leo-editor/leo-editor.git
&lt;/pre&gt;

&lt;p&gt;直接使用下列指令啟動 Leo Editor。&lt;/p&gt;
&lt;p&gt;啟動後如果關閉這個終端機，將會結束 Leo Editor，請注意是否有存檔。&lt;/p&gt;
&lt;pre&gt;
$cd "安裝位置"/leo-editor
$python3 launchLeo.py
&lt;/pre&gt;

&lt;p&gt;寫網誌的必要週邊模組：&lt;/p&gt;
&lt;pre&gt;
$sudo pip3 install pelican -U
$sudo pip3 install markdown -U
$sudo pip3 install bs4 -U
&lt;/pre&gt;

&lt;p&gt;圖中是 Leo 5.3 的版本。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/7VA7EXg.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;未來若有必要軟體的特殊安裝方式，會更新在此。&lt;/p&gt;</summary><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/08/18</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050818.html" rel="alternate"></link><published>2016-08-18T21:00:00+08:00</published><updated>2016-08-18T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-18:blog/40323230ri-zhi-1050818.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;CentOS 的 Python 3.3 版本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;glibc 版本問題&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;GLIBC&lt;/h1&gt;
&lt;p&gt;編譯好的 CentOS 版程式庫放入 Openshift 後，回傳了錯誤：&lt;/p&gt;
&lt;pre&gt;
libc.so.6: version `GLIBC_2.14' not found
&lt;/pre&gt;

&lt;p&gt;是執行系統的 GLIBC 版本較舊所引起的，最簡單的解決方法是升級執行系統的 GLIBC，但是不知道如何命令 Openshift 的倉儲升級。&lt;/p&gt;
&lt;p&gt;用指令檢查了一下虛擬機上的 GLIBC 版本，是 &lt;code&gt;2.17&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/6JSlDKG.png" &gt;&lt;/p&gt;
&lt;p&gt;不過 gcc 應該用了 &lt;code&gt;2.14&lt;/code&gt; 做編譯，而 Openshift 的版本沒到 &lt;code&gt;2.14&lt;/code&gt; 所致。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;今天在 &lt;code&gt;python.log&lt;/code&gt; 注意到 Openshift 使用的 Python 版本是 3.3.2，所以剛開始懷疑是小版號不合所致，但是並非如此。&lt;/p&gt;
&lt;p&gt;從官方的連結下載了 GLIBC &lt;code&gt;2.14&lt;/code&gt; 版：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://ftp.gnu.org/gnu/glibc/" title="ftp.gnu.org"&gt;http://ftp.gnu.org/gnu/glibc/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上網找到的方法大約都是要執行端主機下命令，但是不知道如何對 Openshift 做出要求，所以先在編譯用的虛擬機做調整。&lt;/p&gt;
&lt;p&gt;但是不知道如何在同一台電腦上取代或是安裝兩個版本的 GLIBC，而虛擬機的效能還滿不彰的。&lt;/p&gt;</summary><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/08/17</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050817.html" rel="alternate"></link><published>2016-08-17T21:00:00+08:00</published><updated>2016-08-17T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-17:blog/40323230ri-zhi-1050817.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;距離約束 Bug 解決&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CentOS 的 Python 3.3 版本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;slvs_python.hpp&lt;/h1&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/tl8Nkk3.jpg" &gt;&lt;/p&gt;
&lt;p&gt;修改 &lt;code&gt;slvs_python.hpp&lt;/code&gt; 標頭檔，讓 value 的值等於 0 時自動轉換成重合約束。&lt;/p&gt;
&lt;p&gt;不過點與線的重合約束還沒調整，稍後會做更新。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;CentOS 編譯&lt;/h1&gt;
&lt;p&gt;在 CentOS 上重新編譯 Python 3.3，在執行configure時添加了 &lt;code&gt;--enable-shared&lt;/code&gt; 參數，這樣make時會產生可用的共享資料庫 &lt;code&gt;libpython3.3m.so&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/2d8tkYE.png" &gt;&lt;/p&gt;
&lt;p&gt;另外還把 Makefile 修正到 Python 3.3 的 &lt;code&gt;include&lt;/code&gt; 和共享資料庫的目錄。&lt;/p&gt;
&lt;p&gt;執行時會找不到 &lt;code&gt;libpython3.3m.so&lt;/code&gt;，可能是 CentOS 的 Python 3.3 是安裝在自訂的位置，所以環境變數沒對到。&lt;/p&gt;
&lt;p&gt;後來想調整，但是虛擬機因為記憶體太少而卡住了，不過 Redhat 的 Python 是原生的，應該是沒問題。&lt;/p&gt;
&lt;p&gt;目前還未搬上 Openshift 測試。&lt;/p&gt;</summary><category term="Python-Solvespace"></category></entry><entry><title>SLVS Library Functions</title><link href="http://project.mde.tw/blog/slvs-library-functions.html" rel="alternate"></link><published>2016-08-17T12:00:00+08:00</published><updated>2016-08-17T12:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-17:blog/slvs-library-functions.html</id><summary type="html">&lt;p&gt;This article is an API file for Python-Solvespace.&lt;/p&gt;


&lt;h1&gt;Table of Contents&lt;/h1&gt;</summary><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/08/16</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050816.html" rel="alternate"></link><published>2016-08-16T21:00:00+08:00</published><updated>2016-08-16T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-16:blog/40323230ri-zhi-1050816.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Jupyterhub 繪圖 - 漸開線範例（已儲存8888.kmol.info）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CentOS 安裝 Python 3.3&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;漸開線範例&lt;/h1&gt;
&lt;p&gt;嘗試使用純 &lt;code&gt;slvs&lt;/code&gt; 程式庫（而非使用 matlab 的公式）的方式畫出漸開線。&lt;/p&gt;
&lt;p&gt;雖然程式庫中有比較弧長和線段長的公式，但是無法因應多圈的狀況，所以使用內建math的 &lt;code&gt;pi&lt;/code&gt; 來計算弧長。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Dgdmbxm.jpg" &gt;&lt;/p&gt;
&lt;p&gt;越多圈的漸開線計算越久，角度參照是基圓而非漸開線尾。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
%matplotlib inline
#漸開線解題
#由端點Point3畫出圖形
from slvs import *
import matplotlib.pyplot as plt
from math import *

#參數
r = 10.0#基圓半徑

def Involute(degree):
    #角度換算：degree去除重複圈數
    d = r*(degree*pi/180)
    n = degree//360
    degree -= 360*n

    #開始繪圖
    sys = System(500)
    g = 1

    #3D原點Point0
    p0 = sys.add_param(0.0)
    p1 = sys.add_param(0.0)
    p2 = sys.add_param(0.0)
    Point0 = Point3d(p0, p1, p2)

    #XY法線
    qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0)
    p3 = sys.add_param(qw)
    p4 = sys.add_param(qx)
    p5 = sys.add_param(qy)
    p6 = sys.add_param(qz)
    Normal1 = Normal3d(p3, p4, p5, p6)

    #工作平面
    Workplane1 = Workplane(Point0, Normal1)

    #2D原點Point1
    p7 = sys.add_param(0.0)
    p8 = sys.add_param(0.0)
    Point1 = Point2d(Workplane1, p7, p8)
    Constraint.dragged(Workplane1, Point1)

    #Angle約束判斷
    if degree &gt;= 180:
        other = -1
    else:
        other = 1

    #Point2繞行圓周，距離r
    p9 = sys.add_param(0.0)
    p10 = sys.add_param(10.0*other)
    Point2 = Point2d(Workplane1, p9, p10)
    Constraint.distance(r, Workplane1, Point1, Point2)
    Line1 = LineSegment2d(Workplane1, Point1, Point2)

    #Point3距離Point2為目前圓周長
    #並且連線d會垂直半徑連線r
    p11 = sys.add_param(10.0*other)
    p12 = sys.add_param(10.0*other)
    Point3 = Point2d(Workplane1, p11, p12)
    if d == 0:
        Constraint.on(Workplane1, Point2, Point3)
    else:
        Line2 = LineSegment2d(Workplane1, Point2, Point3)
        Constraint.distance(d, Workplane1, Point2, Point3)
        Constraint.perpendicular(Workplane1, Line1, Line2, False)

    #輔助基線Line0
    p13 = sys.add_param(10.0)
    p14 = sys.add_param(0.0)
    Point4 = Point2d(Workplane1, p13, p14)
    Constraint.dragged(Workplane1, Point4)
    Line0 = LineSegment2d(Workplane1, Point1, Point4)

    #約束角度
    Constraint.angle(Workplane1, degree, Line1, Line0, False)

    #以下解題
    sys.solve()
    if (sys.result == SLVS_RESULT_OKAY):
        #回傳Point7
        x = sys.get_param(11).val
        y = sys.get_param(12).val
        return x, y
    elif (sys.result == SLVS_RESULT_INCONSISTENT):
        print ("solve failed")
        print ("SLVS_RESULT_INCONSISTENT")
        print ("%d DOF" % sys.dof)
    elif (sys.result == SLVS_RESULT_DIDNT_CONVERGE):
        print ("solve failed")
        print ("SLVS_RESULT_DIDNT_CONVERGE")
        print ("%d DOF" % sys.dof)
    elif (sys.result == SLVS_RESULT_TOO_MANY_UNKNOWNS):
        print ("solve failed")
        print ("SLVS_RESULT_TOO_MANY_UNKNOWNS")
        print ("%d DOF" % sys.dof)

#主程式
Xval  = []
Yval  = []
degree = 720
for i in range(0, degree+1, 1):
    x, y = Involute(i)
    Xval += [x]
    Yval += [y]
print ("Solve Completed")

plt.plot(Xval, Yval)
plt.xlabel('x coordinate')
plt.ylabel('y coordinate')
plt.title("Involute - "+str(degree)+" deg")
plt.show()
&lt;/pre&gt;

&lt;p&gt;由於 &lt;code&gt;Point2&lt;/code&gt; 是逆時針旋轉，必須保持 &lt;code&gt;Point3&lt;/code&gt; 在它的後方，之間的連線也必須相切基圓，即與其半徑垂直。&lt;/p&gt;
&lt;p&gt;然而 &lt;code&gt;slvs&lt;/code&gt; 程式庫無法解決距離為 &lt;code&gt;0&lt;/code&gt; 的情況，必須自己改成重合約束，目前在程式庫說明中加上註解，不過應該有辦法透過原始碼的標頭檔避開這個問題，晚點會修正這個情況，如果情況順利，明天的網誌中會更新。&lt;/p&gt;
&lt;p&gt;結果圖形：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/nbCrMjE.png" &gt;&lt;/p&gt;
&lt;p&gt;Jupyter 運行結果（計算時間較長）：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/QjE2qEl.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;CentOS 7&lt;/h1&gt;
&lt;p&gt;為虛擬機（研究室的電腦）安裝官方的 Everything 版本（ISO映像檔），但是電腦效能只能同時跑一個程式，所以安裝很緩慢。&lt;/p&gt;
&lt;p&gt;最後還是灌好了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/BfVtw6K.png" &gt;&lt;/p&gt;
&lt;p&gt;但是安裝完後之前選的 Python 工具包中竟然只有 Python 2.7，所以上網找了一下資料，用手動make的方式安裝 Python 3.3.6。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://tecadmin.net/install-python-3-4-on-centos-rhel-fedora/" title="tecadmin.net"&gt;http://tecadmin.net/install-python-3-4-on-centos-rhel-fedora/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/OVS9mZ2.png" &gt;&lt;/p&gt;
&lt;p&gt;CentOS 相較於 Ubuntu 操作方式不太一樣，而雖然安裝畫面是寫 KDE 圖形介面，但卻是 GNOME 包著 KDE 的附屬程式，而且它們的介面還比 Ubuntu 陽春。&lt;/p&gt;
&lt;p&gt;慶幸的是 CentOS 的開發者工具包十分完善，應該是不用 Netbeans 了，可以直接用終端機make。&lt;/p&gt;</summary><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/08/15</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050815.html" rel="alternate"></link><published>2016-08-15T21:00:00+08:00</published><updated>2016-08-15T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-15:blog/40323230ri-zhi-1050815.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Jupyterhub 繪圖&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多連桿機構的程式及註解&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Jupyterhub&lt;/h1&gt;
&lt;p&gt;用學校 Gmail 登入後用 notebook 進行運算，程式碼開頭只要加上 &lt;code&gt;%matplotlib inline&lt;/code&gt; 就能使用 matplotlib 了。&lt;/p&gt;
&lt;p&gt;不過 notebook 目前是唯獨模式，無法建立檔案或是編輯。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/MyRvGoJ.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;程式碼&lt;/h1&gt;
&lt;p&gt;這次將畫圖順序統整了一下。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/s8rsywg.jpg" &gt;&lt;/p&gt;
&lt;pre class="brush: python"&gt;
%matplotlib inline
#多連桿機構端點（Point7）路徑圖形
#主動軸為［曲柄］Point1-Point2
#圖形將在程式中解釋
from slvs import *
import matplotlib.pyplot as plt

def Multi_link(degree):
    #開始繪圖
    sys = System(500)
    g = 1

    #3D原點Point0
    p0 = sys.add_param(0.0)
    p1 = sys.add_param(0.0)
    p2 = sys.add_param(0.0)
    Point0 = Point3d(p0, p1, p2)

    #XY法線
    qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0)
    p3 = sys.add_param(qw)
    p4 = sys.add_param(qx)
    p5 = sys.add_param(qy)
    p6 = sys.add_param(qz)
    Normal1 = Normal3d(p3, p4, p5, p6)

    #工作平面
    Workplane1 = Workplane(Point0, Normal1)

    #2D原點Point1
    p7 = sys.add_param(0.0)
    p8 = sys.add_param(0.0)
    Point1 = Point2d(Workplane1, p7, p8)
    Constraint.dragged(Workplane1, Point1)

    #Angle約束判斷
    if degree &gt;= 180:
        other = -1
    else:
        other = 1

    #［曲柄］Point1-Point2長15mm
    p9 = sys.add_param(0.0)
    p10 = sys.add_param(20.0*other)
    Point2 = Point2d(Workplane1, p9, p10)
    Constraint.distance(15.0, Workplane1, Po鏈nt1, Point2)
    Line1 = LineSegment2d(Workplane1, Point1, Point2)

    #第一組［呆鍊］Point3-Point4-Point5（Point3固定）
    #長度41.5-55.8-40.1mm
    p11 = sys.add_param(-38.0)
    p12 = sys.add_param(-7.8)
    Point3 = Point2d(Workplane1, p11, p12)
    Constraint.dragged(Workplane1, Point3)
    p13 = sys.add_param(-50.0)
    p14 = sys.add_param(30.0)
    Point4 = Point2d(Workplane1, p13, p14)
    p15 = sys.add_param(-70.0)
    p16 = sys.add_param(-15.0)
    Point5 = Point2d(Workplane1, p15, p16)
    Constraint.distance(41.5, Workplane1, Point3, Point4)
    Constraint.distance(55.8, Wo鏈kplane1, Point4, Point5)
    Constraint.distance(40.1, Workplane1, Point3, Point5)

    #第二組［呆鍊］Point6-Point7-Point8
    #長度65.7-49.0-36.7mm
    p17 = sys.add_param(-50.0)
    p18 = sys.add_param(-50.0)
    Point6 = Point2d(Workplane1, p17, p18)
    p19 = sys.add_param(-10.0)
    p20 = sys.add_param(-90.0)
    Point7 = Point2d(Workplane1, p19, p20)
    p21 = sys.add_param(-20.0)
    p22 = sys.add_param(-40.0)
    Point8 = Point2d(Workplane1, p21, p22)
    Constraint.distance(65.7, Workplane1, Point6, Point7)
    Constraint.d鏈st鏈nce(49.0, Workplane1, Point7, Point8)
    Constraint.distance(36.7, Workplane1, Point6, Point8)

    #兩段［呆鍊-呆鍊］連接桿
    #Point5-Point6長39.4mm
    #Point3-Point8長39.3mm
    Constrain鏈.distance(39.4, Workplane1, Point5, Point6)
    Constraint.distance(39.3, Workplane1, Point3, Point8)

    #兩段［區柄-呆鍊］連接桿
    #Point2-Point4長50.0mm
    #Point2-Point8長61.9mm
    Constraint.distance(50.0, Workplane1, Point2, Point4)
    Constraint.distance(61.9, Workplane1, Point2, Point8)

    #水平輔助Line0
    p23 = sys.add_param(20.0)
    p24 = sys.add_param(0.0)
    Point9 = Point2d(Workplane1, p23, p24)
    Constraint.dragged(Workplane1, Point9)
    Line0 = LineSegment2d(Workplane1, Point1, Point9)

    #區柄角度（手動項目務必放最後）
    Constraint.angle(Workplane1, degree, Line1, Line0, False)

    #以下解題
    sys.solve()
    if (sys.result == SLVS_RESULT_OKAY):
        #回傳Point7
        x = sys.get_param(19).val
        y = sys.get_param(20).val
        return x, y
    elif (sys.result == SLVS_RESULT_INCONSISTENT):
        print ("solve failed")
        print ("SLVS_RESULT_INCONSISTENT")
        print ("%d DOF" % sys.dof)
    elif (sys.result == SLVS_RESULT_DIDNT_CONVERGE):
        print ("solve failed")
        print ("SLVS_RESULT_DIDNT_CONVERGE")
        print ("%d DOF" % sys.dof)
    elif (sys.result == SLVS_RESULT_TOO_MANY_UNKNOWNS):
        print ("solve failed")
        print ("SLVS_RESULT_TOO_MANY_UNKNOWNS")
        print ("%d DOF" % sys.dof)

#主程式
Xval  = []
Yval  = []

for i in range(0, 361, 1):
    x, y = Multi_link(i)
    Xval += [x]
    Yval += [y]
print ("Solve Completed")

plt.plot(Xval, Yval)
plt.xlabel('x coordinate')
plt.ylabel('y coordinate')
plt.show()
&lt;/pre&gt;

&lt;p&gt;因為是變速機構，如果將精度調成5度的話，圖形會比較粗糙，目前用1度的精度會比較平滑，不過相對運算時間會比較久。&lt;/p&gt;
&lt;h2&gt;執行結果（5度）&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/CvjRTBI.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;執行結果（1度）&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/xHnFqdE.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;經過多次範例，若要使用 slvs 程式庫畫圖，要先看一下機構節點的大約位置，尤其是運動範圍跨象限的主動節點（即參數控制約束的點）。&lt;/p&gt;
&lt;p&gt;機構中會360度繞軸旋轉的區柄端點，起始位置要定在90度（輸入值在0～180）或-90度（輸入值在181～359），要用 &lt;code&gt;if&lt;/code&gt; 函式判斷。&lt;/p&gt;</summary><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/08/14</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050814.html" rel="alternate"></link><published>2016-08-14T21:00:00+08:00</published><updated>2016-08-14T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-14:blog/40323230ri-zhi-1050814.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用研究室網路設定&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;架站問題&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Python 3.3 版本製作中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;網路設定&lt;/h1&gt;
&lt;p&gt;由於之前上網是用手機網路，為了取得固定IP，使用的是原本給新電腦用的網路 &lt;code&gt;140.130.17.117&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Su0D9Oc.png" &gt;&lt;/p&gt;
&lt;p&gt;Windows 和 Ubuntu 中的設定是一樣的，兩個OS都能連到網際網路。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;Oauthenticator&lt;/h1&gt;
&lt;p&gt;參考 Cadlab 有關 Jupyterhub 的安裝，在 Python 中安裝了 jupyterhub、notebook 和 oauthenticator。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://cadlab.mde.tw/post/jupyterhub-oauth2-deng-ru-she-ding.html" title="cadlab.mde.tw"&gt;http://cadlab.mde.tw/post/jupyterhub-oauth2-deng-ru-she-ding.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://cadlab.mde.tw/post/chun-ipv6-huan-jing-xia-an-zhuang-jupyterhub.html" title="cadlab.mde.tw"&gt;http://cadlab.mde.tw/post/chun-ipv6-huan-jing-xia-an-zhuang-jupyterhub.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;利用指令產生 &lt;code&gt;key&lt;/code&gt; 和 &lt;code&gt;crt&lt;/code&gt; 兩個憑證檔案。&lt;/p&gt;
&lt;pre&gt;sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout jupyterhub.key -out jupyterhub.crt&lt;/pre&gt;

&lt;p&gt;起動指令是：&lt;/p&gt;
&lt;pre&gt;jupyterhub --ip 140.130.17.117 --port 9443 --ssl-key jupyterhub.key --ssl-cert jupyterhub.crt&lt;/pre&gt;

&lt;p&gt;從&lt;a href="https://github.com/jupyterhub/oauthenticator/tree/master/example" title="github.com"&gt;https://github.com/jupyterhub/oauthenticator/tree/master/example&lt;/a&gt;下載了範例資料夾，不過 &lt;code&gt;jupyterhub_config.py&lt;/code&gt; 結構跟說明不太一樣，所以把他的指令碼改成 Cadlab 的方式，只是白名單和使用者清單的檔案可能不一樣，改一下資料夾或連結名稱就能對應。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/AkO0IE6.png" &gt;&lt;/p&gt;
&lt;p&gt;接著進 Github 註冊新的app，取得 Client ID 和 Client Secret，不過不知道網域名稱該填甚麼，只能填上電腦IP名稱。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/l4FqQ1c.jpg" &gt;&lt;/p&gt;
&lt;p&gt;而 Google 方面也是一樣，但是重新導向 callback 的方面要使用頂層網域，就是包含 &lt;code&gt;.com&lt;/code&gt; 或 &lt;code&gt;.org&lt;/code&gt; 的名稱，這樣就沒辦法導向給 IP 名稱的網站用了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/u5TFwgH.png" &gt;&lt;/p&gt;
&lt;p&gt;另外就是檔案瀏覽器沒有權限在 &lt;code&gt;etc&lt;/code&gt; 或 &lt;code&gt;srv&lt;/code&gt; 目錄裡編輯或是建立檔案，要自動啟動就必須用終端機設定了。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;pyenv&lt;/h1&gt;
&lt;p&gt;裝了 pyenv 來管理 Python 版本。&lt;/p&gt;
&lt;p&gt;安裝時還需要 Mercurial。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/yZbLONl.png" &gt;&lt;/p&gt;
&lt;p&gt;Python 3.3 dev 下載和安裝時都比較久，等了一段時間才弄好。&lt;/p&gt;
&lt;p&gt;接下來會編譯 3.3 的版本來測試。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;由於對網路方面不熟悉，所以可能設定方面有所缺失，還要花一些時間檢查。&lt;/p&gt;</summary><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/08/13</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050813.html" rel="alternate"></link><published>2016-08-13T21:00:00+08:00</published><updated>2016-08-13T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-13:blog/40323230ri-zhi-1050813.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Ubuntu 版本與 Openshift 不合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Openshift 的 cartridge 自訂？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;版本不合&lt;/h1&gt;
&lt;p&gt;後來發現為何找不到 &lt;code&gt;_slvs.so&lt;/code&gt; 的檔案了，因為 &lt;code&gt;.gitignore&lt;/code&gt; 中包含了 &lt;code&gt;*.so&lt;/code&gt;，而不會上傳這兩個檔案，註解掉就行了。&lt;/p&gt;
&lt;p&gt;但是上傳後仍無法執行，回報的訊息為：&lt;/p&gt;
&lt;pre&gt;
Traceback (most recent call last):
  File "/var/lib/openshift/57182def7628e1988e00002a/app-root/runtime/repo/wsgi.py", line 5, in &lt;module&gt;
    import myflaskapp
  File "/var/lib/openshift/57182def7628e1988e00002a/app-root/runtime/repo/myflaskapp.py", line 18, in &lt;module&gt;
    import users.b.g9.bg9_40323230
  File "/var/lib/openshift/57182def7628e1988e00002a/app-root/runtime/repo/users/b/g9/bg9_40323230.py", line 2, in &lt;module&gt;
    from slvs import *
  File "/var/lib/openshift/57182def7628e1988e00002a/app-root/runtime/repo/slvs.py", line 28, in &lt;module&gt;
    _slvs = swig_import_helper()
  File "/var/lib/openshift/57182def7628e1988e00002a/app-root/runtime/repo/slvs.py", line 24, in swig_import_helper
    _mod = imp.load_module('_slvs', fp, pathname, description)
  File "/opt/rh/python33/root/usr/lib64/python3.3/imp.py", line 183, in load_module
    return load_dynamic(name, filename, file)
ImportError: libpython3.4m.so.1.0: cannot open shared object file: No such file or directory
&lt;/pre&gt;

&lt;p&gt;看來開發時使用 Python 3.4 dev 會造成 Python 3.3 無法讀取。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/jUsRUi4.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;Openshift custom cartridge&lt;/h1&gt;
&lt;p&gt;上網找了一下文章，找到有人問能不能建立其他版本的 cartridge。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/34073473/openshift-custom-cartridge-with-python-3-4" title="stackoverflow.com"&gt;http://stackoverflow.com/questions/34073473/openshift-custom-cartridge-with-python-3-4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而回應的是如果使用 s2i-python-container 這個工具，可以建立一個名為 Python 3.3 的其他版本 Python 鏡像檔，甚至有支援 Python 3.5。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/sclorg/s2i-python-container" title="github.com"&gt;https://github.com/sclorg/s2i-python-container&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不過這個工具只能給 Fedora 類型的 Linux 作業系統使用，看起來是沒有 Debian 的版本。&lt;/p&gt;
&lt;p&gt;要解決 Linux 相容的問題，Ubuntu 上可能要裝 3.3 版本的 Python 了，會先研究看看 Openshift 方可以安裝和執行的指令。&lt;/p&gt;
&lt;p&gt;不知道如果其他 Ubuntu 沒安裝 Python-dev（或版本不同）的話能不能執行這些檔案。&lt;/p&gt;
&lt;p&gt;Windows 的 Python 連結庫是自己做的，而非安裝 Python-dev，所以沒這個問題。&lt;/p&gt;</summary><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/08/12</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050812.html" rel="alternate"></link><published>2016-08-12T21:00:00+08:00</published><updated>2016-08-12T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-12:blog/40323230ri-zhi-1050812.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Ubuntu 版本編譯完畢&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Ubuntu 執行成功&lt;/h1&gt;
&lt;p&gt;後來將 &lt;code&gt;slvs_python.hpp&lt;/code&gt; 的 &lt;code&gt;__mingw_vasprintf&lt;/code&gt; 暫時改為 &lt;code&gt;vasprintf&lt;/code&gt; 就沒問題了，不過若要使用MinGW編譯的話要再改回來。&lt;/p&gt;
&lt;p&gt;編譯出來的檔案名稱為 &lt;code&gt;_slvs.so&lt;/code&gt;，類型是共享連結庫。&lt;/p&gt;
&lt;p&gt;在終端機中使用python3執行所有範例檔都沒問題。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/gcEM8h0.png" &gt;&lt;/p&gt;
&lt;p&gt;Windows 用的 &lt;code&gt;_slvs.pyd&lt;/code&gt; ，在檔案瀏覽器中被視為 Windows 可執行檔，而非共享連結庫。&lt;/p&gt;
&lt;p&gt;將 Makefile 存成兩個版本（加上次檔名），不同平台間用 &lt;code&gt;-f&lt;/code&gt; 參數切換make就行了。&lt;/p&gt;
&lt;p&gt;不過目前手邊沒有虛擬機，所以還沒測試是否所有使用 Python 3.4 的 Ubuntu 都能使用程式庫。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;倉儲更新&lt;/h1&gt;
&lt;p&gt;統一將make完畢的 Library 放在 Windows 和 Ubuntu 資料夾。&lt;/p&gt;
&lt;p&gt;將倉儲清理了一下，讓原始碼回到 make clean 狀態。&lt;/p&gt;
&lt;p&gt;將原本 Windows 的範例code複製一份到 Ubuntu 資料夾中。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/nIY73qM.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;不過將 &lt;code&gt;_slvs.so&lt;/code&gt; 和編譯好的附屬文件上傳到 Openshift 後仍然找不到 &lt;code&gt;_slvs&lt;/code&gt; 模組。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/juGSqv4.jpg" &gt;&lt;/p&gt;
&lt;p&gt;接著會測試看看小型的pyd能不能用。&lt;/p&gt;</summary><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/08/11</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050811.html" rel="alternate"></link><published>2016-08-11T21:00:00+08:00</published><updated>2016-08-11T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-11:blog/40323230ri-zhi-1050811.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安裝 Linux 版工具&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ubuntu 版本編譯&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;工作環境&lt;/h1&gt;
&lt;p&gt;用以前安裝的雙系統做 Ubuntu 版本的編譯。&lt;/p&gt;
&lt;p&gt;作業系統是基於 Ubuntu 14.04 的 ezgo 12，圖形介面為KDE。&lt;/p&gt;
&lt;p&gt;原本 ezgo 中的python3版本為 3.4.0，安裝python3.4-dev後升級到最新的3.4.5。&lt;/p&gt;
&lt;p&gt;而原版的GNU工具沒有裝入g++，所以就用apt安裝了。&lt;/p&gt;
&lt;p&gt;在 Ubuntu 上運行 Netbeans 和 gcc 比 Windows 流暢，make的速度更快。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;產生問題&lt;/h1&gt;
&lt;p&gt;因為作業系統換了環境，所以Makefile的位置研究並調整了一下。&lt;/p&gt;
&lt;p&gt;不過在編譯&lt;code&gt;slvs_python.hpp&lt;/code&gt;時出現&lt;code&gt;‘__mingw_vasprintf’ was not declared in this scope&lt;/code&gt;的訊息。&lt;/p&gt;
&lt;p&gt;這個函式應該是&lt;code&gt;stdio.h&lt;/code&gt;的，不知道為何無法找到它。&lt;/p&gt;
&lt;p&gt;檢查了系統目錄，這個檔案應該都在&lt;code&gt;include&lt;/code&gt;的範圍內，所以應該是使用GNU和原本MinGW兩種版本gcc的問題。&lt;/p&gt;
&lt;p&gt;不過這次並非在虛擬機測試，所以使用上會更小心。&lt;/p&gt;</summary><category term="Python-Solvespace"></category></entry><entry><title>SLVS 程式庫函式</title><link href="http://project.mde.tw/blog/slvs-cheng-shi-ku-han-shi.html" rel="alternate"></link><published>2016-08-11T12:00:00+08:00</published><updated>2016-08-11T12:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-11:blog/slvs-cheng-shi-ku-han-shi.html</id><summary type="html">&lt;p&gt;這篇文章為 Python-Solvespace 的 API 文件。&lt;/p&gt;


&lt;h1&gt;目錄&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#Param"&gt;Param&lt;/a&gt; Class&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#Entity"&gt;Entity&lt;/a&gt; Class&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#Point"&gt;Point&lt;/a&gt; Class&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#Point3d"&gt;Point3d&lt;/a&gt; Class&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#Point2d"&gt;Point2d&lt;/a&gt; Class&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#Normal3d"&gt;Normal3d&lt;/a&gt; Class&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#Workplane"&gt;Workplane&lt;/a&gt; Class&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#Distance"&gt;Distance&lt;/a&gt; Class&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#LineSegment"&gt;LineSegment&lt;/a&gt; Class&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#LineSegment3d"&gt;LineSegment3d&lt;/a&gt; Class&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#LineSegment2d"&gt;LineSegment2d&lt;/a&gt; Class&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#Circular"&gt;Circular&lt;/a&gt; Class&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#ArcOfCircle"&gt;ArcOfCircle&lt;/a&gt; Class&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#Circle"&gt;Circle&lt;/a&gt; Class&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#Cubic"&gt;Cubic&lt;/a&gt; Class&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#Constraint"&gt;Constraint&lt;/a&gt; Class&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#System"&gt;System&lt;/a&gt; Class&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他函式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;額外變數&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;div class="section"&gt;&lt;span id="Param" class="anchor"&gt;&lt;/span&gt;&lt;/div&gt;

&lt;h1&gt;Param Class&lt;/h1&gt;
&lt;p&gt;這個類型用來儲存參數值。&lt;/p&gt;
&lt;h2&gt;繼承自&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Object Class&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;被繼承&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;無&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;屬性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#Param-sys"&gt;sys&lt;/a&gt;: System*&lt;/li&gt;
&lt;li&gt;&lt;a href="#Param-handle"&gt;handle&lt;/a&gt;: Slvs_hParam&lt;/li&gt;
&lt;li&gt;&lt;a href="#Param-group"&gt;group&lt;/a&gt;: Slvs_hGroup&lt;/li&gt;
&lt;li&gt;&lt;a href="#Param-value"&gt;value&lt;/a&gt;: double&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;公開函式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#Param-init"&gt;Param&lt;/a&gt;(double value)&lt;/li&gt;
&lt;li&gt;&lt;a href="#Param-del"&gt;__del__&lt;/a&gt;()&lt;/li&gt;
&lt;li&gt;Slvs_hParam &lt;a href="#Param-handle"&gt;GetHandle&lt;/a&gt;()&lt;/li&gt;
&lt;li&gt;Slvs_hGroup &lt;a href="#Param-group"&gt;GetGroup&lt;/a&gt;()&lt;/li&gt;
&lt;li&gt;System * &lt;a href="#Param-sys"&gt;GetSystem&lt;/a&gt;()&lt;/li&gt;
&lt;li&gt;double &lt;a href="#Param-value"&gt;GetValue&lt;/a&gt;()&lt;/li&gt;
&lt;li&gt;void &lt;a href="#Param-value"&gt;SetValue&lt;/a&gt;(double value)&lt;/li&gt;
&lt;li&gt;void &lt;a href="#Param-prepareFor"&gt;prepareFor&lt;/a&gt;(System* system, Slvs_hGroup group)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section"&gt;&lt;span id="Param-sys" class="anchor"&gt;&lt;/span&gt;&lt;/div&gt;

&lt;h2&gt;sys: &lt;a href="#System"&gt;System&lt;/a&gt;*&lt;/h2&gt;
&lt;p&gt;這個屬性為此類型所在的系統。&lt;/p&gt;
&lt;p&gt;這個屬性可以直接呼叫。&lt;/p&gt;
&lt;p&gt;取得函式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;System * GetSystem()&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section"&gt;&lt;span id="Param-handle" class="anchor"&gt;&lt;/span&gt;&lt;/div&gt;

&lt;h2&gt;handle: Slvs_hParam&lt;/h2&gt;
&lt;p&gt;這個屬性為此類型的句柄。&lt;/p&gt;
&lt;p&gt;這個屬性可以直接呼叫。&lt;/p&gt;
&lt;p&gt;取得函式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Slvs_hParam GetHandle()&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section"&gt;&lt;span id="Param-group" class="anchor"&gt;&lt;/span&gt;&lt;/div&gt;

&lt;h2&gt;group: Slvs_hGroup&lt;/h2&gt;
&lt;p&gt;這個屬性為此類型所在的群組。&lt;/p&gt;
&lt;p&gt;這個屬性可以直接呼叫。&lt;/p&gt;
&lt;p&gt;取得函式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Slvs_hGroup GetGroup()&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section"&gt;&lt;span id="Param-value" class="anchor"&gt;&lt;/span&gt;&lt;/div&gt;

&lt;h2&gt;value: double&lt;/h2&gt;
&lt;p&gt;這個屬性為此類型的參數值。&lt;/p&gt;
&lt;p&gt;這個屬性可以直接呼叫。&lt;/p&gt;
&lt;p&gt;取得函式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;double &lt;a href="#Param-GetValue"&gt;GetValue&lt;/a&gt;()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;設定函式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#Param-init0"&gt;Param&lt;/a&gt;(double value)&lt;/li&gt;
&lt;li&gt;void SetValue(double value)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section"&gt;&lt;span id="Param-init" class="anchor"&gt;&lt;/span&gt;&lt;/div&gt;

&lt;h2&gt;Param(double value)&lt;/h2&gt;
&lt;p&gt;初始化此類型。&lt;/p&gt;
&lt;p&gt;給定 value 屬性。&lt;/p&gt;
&lt;div class="section"&gt;&lt;span id="Param-del" class="anchor"&gt;&lt;/span&gt;&lt;/div&gt;

&lt;h2&gt;Param.__del__()&lt;/h2&gt;
&lt;p&gt;刪除此類型的函式。&lt;/p&gt;
&lt;div class="section"&gt;&lt;span id="Param-prepareFor" class="anchor"&gt;&lt;/span&gt;&lt;/div&gt;

&lt;h2&gt;void prepareFor(&lt;a href="#System"&gt;System&lt;/a&gt;* system, Slvs_hGroup group)&lt;/h2&gt;
&lt;p&gt;此函式可以&lt;/p&gt;
&lt;hr /&gt;
&lt;div class="section"&gt;&lt;span id="Entity" class="anchor"&gt;&lt;/span&gt;&lt;/div&gt;

&lt;h1&gt;Entity Class&lt;/h1&gt;
&lt;p&gt;這個類型協助建構所有實體。&lt;/p&gt;
&lt;p&gt;請不要直接使用這個類型，因為它無法代表任何實體。&lt;/p&gt;
&lt;h2&gt;繼承自&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Object Class&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;被繼承&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#Point"&gt;Point&lt;/a&gt; Class&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#Point3d"&gt;Point3d&lt;/a&gt; Class&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#Point2d"&gt;Point2d&lt;/a&gt; Class&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#Normal3d"&gt;Normal3d&lt;/a&gt; Class&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#Workplane"&gt;Workplane&lt;/a&gt; Class&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#Distance"&gt;Distance&lt;/a&gt; Class&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#LineSegment"&gt;LineSegment&lt;/a&gt; Class&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#LineSegment3d"&gt;LineSegment3d&lt;/a&gt; Class&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#LineSegment2d"&gt;LineSegment2d&lt;/a&gt; Class&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#Circular"&gt;Circular&lt;/a&gt; Class&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#ArcOfCircle"&gt;ArcOfCircle&lt;/a&gt; Class&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#Circle"&gt;Circle&lt;/a&gt; Class&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#Cubic"&gt;Cubic&lt;/a&gt; Class&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;屬性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#Entity-handle"&gt;handle&lt;/a&gt;: Slvs_hParam&lt;/li&gt;
&lt;li&gt;&lt;a href="#Entity-group"&gt;group&lt;/a&gt;: Slvs_hGroup&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;公開函式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#Entity-init"&gt;Entity&lt;/a&gt;()&lt;/li&gt;
&lt;li&gt;&lt;a href="#Entity-del"&gt;__del__&lt;/a&gt;()&lt;/li&gt;
&lt;li&gt;Slvs_hEntity &lt;a href="#Entity-handle"&gt;GetHandle&lt;/a&gt;()&lt;/li&gt;
&lt;li&gt;Slvs_hGroup &lt;a href="#Entity-group"&gt;GetGroup&lt;/a&gt;()&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section"&gt;&lt;span id="Entity-handle" class="anchor"&gt;&lt;/span&gt;&lt;/div&gt;

&lt;h2&gt;handle: Slvs_hParam&lt;/h2&gt;
&lt;p&gt;這個屬性為此類型的句柄。&lt;/p&gt;
&lt;p&gt;取得函式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Slvs_hParam GetHandle()&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section"&gt;&lt;span id="Entity-group" class="anchor"&gt;&lt;/span&gt;&lt;/div&gt;

&lt;h2&gt;group: Slvs_hGroup&lt;/h2&gt;
&lt;p&gt;這個屬性為此類型所在的群組。&lt;/p&gt;
&lt;p&gt;取得函式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Slvs_hGroup GetGroup()&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section"&gt;&lt;span id="Entity-init" class="anchor"&gt;&lt;/span&gt;&lt;/div&gt;

&lt;h2&gt;Entity()&lt;/h2&gt;
&lt;p&gt;初始化此類型。&lt;/p&gt;
&lt;p&gt;直接使用此函式會回傳 AttributeError 錯誤。&lt;/p&gt;
&lt;div class="section"&gt;&lt;span id="Entity-del" class="anchor"&gt;&lt;/span&gt;&lt;/div&gt;

&lt;h2&gt;Entity.__del__()&lt;/h2&gt;
&lt;p&gt;刪除此類型的函式。&lt;/p&gt;
&lt;hr /&gt;
&lt;div class="section"&gt;&lt;span id="Point" class="anchor"&gt;&lt;/span&gt;&lt;/div&gt;

&lt;h1&gt;Point Class&lt;/h1&gt;
&lt;p&gt;這個類型協助建構點實體。&lt;/p&gt;
&lt;p&gt;請不要直接使用這個類型，因為它無法代表任何實體。&lt;/p&gt;
&lt;h2&gt;繼承自&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#Entity"&gt;Entity&lt;/a&gt; Class&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;被繼承&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#Point3d"&gt;Point3d&lt;/a&gt; Class&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#Point2d"&gt;Point2d&lt;/a&gt; Class&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;公開函式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#Point-init"&gt;Point&lt;/a&gt;()&lt;/li&gt;
&lt;li&gt;&lt;a href="#Point-del"&gt;__del__&lt;/a&gt;()&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section"&gt;&lt;span id="Point-init" class="anchor"&gt;&lt;/span&gt;&lt;/div&gt;

&lt;h2&gt;Point()&lt;/h2&gt;
&lt;p&gt;初始化此類型。&lt;/p&gt;
&lt;p&gt;直接使用此函式會回傳 AttributeError 錯誤。&lt;/p&gt;
&lt;div class="section"&gt;&lt;span id="Point-del" class="anchor"&gt;&lt;/span&gt;&lt;/div&gt;

&lt;h2&gt;Point.__del__()&lt;/h2&gt;
&lt;p&gt;刪除此類型的函式。&lt;/p&gt;
&lt;hr /&gt;
&lt;div class="section"&gt;&lt;span id="Point3d" class="anchor"&gt;&lt;/span&gt;&lt;/div&gt;

&lt;h1&gt;Point3d Class&lt;/h1&gt;
&lt;p&gt;這個類型代表 3D 空間中的點。&lt;/p&gt;
&lt;p&gt;建立這個類型可以&lt;/p&gt;
&lt;h2&gt;繼承自&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#Point"&gt;Point&lt;/a&gt; Class&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;被繼承&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;無&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;屬性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#Point3d-x"&gt;x&lt;/a&gt;: Param&lt;/li&gt;
&lt;li&gt;&lt;a href="#Point3d-x"&gt;y&lt;/a&gt;: Param&lt;/li&gt;
&lt;li&gt;&lt;a href="#Point3d-x"&gt;z&lt;/a&gt;: Param&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;公開函式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#Point3d-init0"&gt;Point3d&lt;/a&gt;(Param x, Param y, Param z, System* system = NULL, Slvs_hGroup group = USE_DEFAULT_GROUP)&lt;/li&gt;
&lt;li&gt;&lt;a href="#Point3d-init1"&gt;Point3d&lt;/a&gt;(double x, double y, double z, System* system = NULL, Slvs_hGroup group = USE_DEFAULT_GROUP)&lt;/li&gt;
&lt;li&gt;&lt;a href="#Point3d-del"&gt;__del__&lt;/a&gt;()&lt;/li&gt;
&lt;li&gt;list&amp;lt;double&amp;gt; &lt;a href="#Point3d-to_openscad"&gt;to_openscad&lt;/a&gt;()&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section"&gt;&lt;span id="Point3d-init0" class="anchor"&gt;&lt;/span&gt;&lt;/div&gt;

&lt;h2&gt;Point3d(&lt;a href="#Param"&gt;Param&lt;/a&gt; x, &lt;a href="#Param"&gt;Param&lt;/a&gt; y, &lt;a href="#Param"&gt;Param&lt;/a&gt; z, &lt;a href="#System"&gt;System&lt;/a&gt;* system = NULL, Slvs_hGroup group = &lt;a href="#USE_DEFAULT_GROUP"&gt;USE_DEFAULT_GROUP&lt;/a&gt;)&lt;/h2&gt;
&lt;p&gt;初始化此類型。&lt;/p&gt;
&lt;div class="section"&gt;&lt;span id="Point3d-init1" class="anchor"&gt;&lt;/span&gt;&lt;/div&gt;

&lt;h2&gt;Point3d(double x, double y, double z, &lt;a href="#System"&gt;System&lt;/a&gt;* system = NULL, Slvs_hGroup group = &lt;a href="#USE_DEFAULT_GROUP"&gt;USE_DEFAULT_GROUP&lt;/a&gt;)&lt;/h2&gt;
&lt;p&gt;初始化此類型。&lt;/p&gt;
&lt;div class="section"&gt;&lt;span id="Point3d-del" class="anchor"&gt;&lt;/span&gt;&lt;/div&gt;

&lt;h2&gt;Point3d.__del__()&lt;/h2&gt;
&lt;p&gt;刪除此類型的函式。&lt;/p&gt;
&lt;div class="section"&gt;&lt;span id="Point3d-to_openscad" class="anchor"&gt;&lt;/span&gt;&lt;/div&gt;

&lt;h2&gt;list&amp;lt;double&amp;gt; Point3d.to_openscad()&lt;/h2&gt;
&lt;p&gt;此函式將回傳一組含有三個浮點數的 list 類型，分別為 x、y、z 屬性的值。&lt;/p&gt;
&lt;style&gt;
p a {
    color : green;
}
li a {
    color : green;
}
h2 a {
    color : green;
}
.section {
    position: relative;
}
.anchor {
    display: block;
    position: absolute;
    width: 0;
    height: 0;
    z-index: -1;
    top: -70px;
    left: 0;
    visibility: hidden;
}
&lt;/style&gt;</summary><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/08/10</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050810.html" rel="alternate"></link><published>2016-08-10T21:00:00+08:00</published><updated>2016-08-10T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-10:blog/40323230ri-zhi-1050810.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;檢視python.log的錯誤&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Python Solvespace 的介紹圖&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;FileZilla 登入&lt;/h1&gt;
&lt;p&gt;用FileZilla進入網站查看和下載檔案。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/oXaiwCp.jpg" &gt;&lt;/p&gt;
&lt;p&gt;在Openshift的網頁中按下"Want to log in to your application?"連結，能取得一個字串，形式如下。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ssh 使用者名稱@主機&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/dpua4rp.jpg" &gt;&lt;/p&gt;
&lt;p&gt;將其內容填入FileZilla的站台設定中，協定選擇SFTP，登入形式選擇交談式。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/nmtCVUg.jpg" &gt;&lt;/p&gt;
&lt;p&gt;然後連線後，在&lt;code&gt;/var/lib/openshift/使用者名稱/app-root/logs&lt;/code&gt;資料夾中可以找到python.log，下載後開啟。&lt;/p&gt;
&lt;p&gt;最下方是最新的執行紀錄和連線紀錄。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/l8Xoe0b.jpg" &gt;&lt;/p&gt;
&lt;p&gt;看到問題是錯在模組導入錯誤，雖然訊息跟之前模組匯入的問題一樣，但是造成原因應該不一樣。&lt;/p&gt;
&lt;p&gt;不知道是python版本還是openshift不使用anaconda的關係。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;slvs.py&lt;/code&gt;無法像先前一般將&lt;code&gt;_slvs.pyd&lt;/code&gt;的名稱傳給python用。&lt;/p&gt;
&lt;h1&gt;介紹圖&lt;/h1&gt;
&lt;p&gt;用免費軟體XMind做兩張Python Solvespace的概念圖。&lt;/p&gt;
&lt;p&gt;軟體中不能調整解析度，目前的比例還能符合網頁或文件中的說明。&lt;/p&gt;
&lt;h2&gt;&lt;em&gt;製作過程&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/e6JWCWW.png" &gt;&lt;/p&gt;
&lt;h2&gt;&lt;em&gt;利用規劃&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/62SVuDT.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;在想是否要將slvs的檔案做成模組的方式裝入Python，再裝到Openshift的python上。&lt;/p&gt;
&lt;p&gt;做成模組後用途應該會增加。&lt;/p&gt;
&lt;p&gt;近期將整理網誌內容改成書面格式，先存成Markdown檔，再另外參照學長的目錄做分類排序成章節。&lt;/p&gt;</summary><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/08/08</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050808.html" rel="alternate"></link><published>2016-08-08T21:00:00+08:00</published><updated>2016-08-08T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-08:blog/40323230ri-zhi-1050808.html</id><summary type="html">&lt;p&gt;將bokeh繪圖搬入Flask，使用的是上學期的倉儲。&lt;/p&gt;


&lt;h1&gt;bokeh網頁原始碼&lt;/h1&gt;
&lt;p&gt;bokeh在使用後，可以不選擇存檔，而是變成網頁原始碼的型態，讓程式利用。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#不使用from bokeh.plotting import figure, output_file, show, save

#而導入：
from bokeh.plotting import figure
from bokeh.resources import CDN
from bokeh.embed import file_html

#照常畫圖
plot = figure(...)
plot.line(...)

#最後傳出給outstring
outstring = str(file_html(plot, CDN, "網頁視窗標題"))
&lt;/pre&gt;

&lt;p&gt;變成這樣的形態後，會先讓SLVS程式庫和bokeh計算完原始碼後才使用，算是靜態結果，這樣會產生一個缺點，稍後會提到。&lt;/p&gt;
&lt;p&gt;bokeh也有自己的附加功能"JavaScript Callbacks"，屬於動態運算，讓圖形能及時更新，不用重新整理。&lt;/p&gt;
&lt;p&gt;參考連結：&lt;a href="http://bokeh.pydata.org/en/latest/docs/user_guide/interaction/callbacks.html#customjs-for-widgets" title="bokeh.pydata.org"&gt;http://bokeh.pydata.org/en/latest/docs/user_guide/interaction/callbacks.html#customjs-for-widgets&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;試過了範例Slider的方法（最接近需求：給角度求機構當前狀態），在JavaScript中卻不知所以然，不知道要如何把callback的內容帶入我的函式中。&lt;/p&gt;
&lt;p&gt;上網看過別人的範例，不同利用方式都不一樣，但是不知道如何修改JS迴圈中的內容。因為機構的圖形要回傳所有的點，可能要了解一下這些物件的關係。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;Flask&lt;/h1&gt;
&lt;p&gt;和上學期的專案一樣，用&lt;code&gt;python wsgi.py&lt;/code&gt;啟動後就能呼叫程式並帶入變數求解。&lt;/p&gt;
&lt;p&gt;不同的是用到新模組和自己的程式庫。&lt;/p&gt;
&lt;p&gt;在自己的檔案中再插入一段&lt;code&gt;Mango(k)&lt;/code&gt;來嵌入bokeh的圖形，並希望能控制機構的角度狀態。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/jTqqiDg.jpg" &gt;&lt;/p&gt;
&lt;p&gt;稍微調整了bokeh的選項，隱藏工具、取消預設工具、不可拖移、放大介面等等。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
@bg9_40323230.route('/crank_rock/＜k&gt;')
def Mango(k):
    outstring = ""
    #相關參數
    d0 = 90 #基線長度(mm)
    n1 = 35 #短連桿長度(mm)
    n2 = 70 #長連桿長度(mm)
    t1 = 40 #三角形第一邊(mm)
    t2 = 40 #三角形第二邊(mm)
    t3 = 70 #三角形第三邊(mm)

    #迴圈求路徑用
    def crank_rock(degree):
        ...
    #當前機構狀態用
    def crank_rock_M(degree):
        ...
    #主程式
    X1val  = []
    Y1val  = []
    for i in range(0, 361):
        x, y = crank_rock(i)
        X1val += [x]
        Y1val += [y]
    x1, y1, x2, y2, x3, y3, x4, y4, x5, y5 = crank_rock_M(float(k))
    X2val = [x1, x4, x3, x5, x4, x5, x2]
    Y2val = [y1, y4, y3, y5, y4, y5, y2]
    X3val = [x1, x2]
    Y3val = [y1, y2]
    #bokeh
    plot = figure(title="simple line example", x_axis_label='x', y_axis_label='y', toolbar_location=None, plot_width=700, plot_height=700)
    plot.line(X1val, Y1val, legend="Path.", line_width=2, line_color="blue")
    plot.line(X2val, Y2val, legend="Mechanism.", line_width=4, line_color="red")
    plot.line(X3val, Y3val, line_width=3, line_dash=[4, 4], line_color="orange")
    plot.toolbar.active_drag = None

    outstring = str(file_html(plot, CDN, "Crank Rocker: "+str(k)+" degree"))

    return outstring
&lt;/pre&gt;

&lt;p&gt;這樣子程式會計算出HTML的原始碼給網頁，而bokeh的網頁中不會用到python程式。&lt;/p&gt;
&lt;p&gt;在這裡&lt;code&gt;k&lt;/code&gt;是以&lt;strong&gt;字串&lt;/strong&gt;的方式帶進來的，所以必須轉成Float才能計算。&lt;/p&gt;
&lt;p&gt;但是如果預先設置了&lt;code&gt;defaults&lt;/code&gt;值時（例如&lt;code&gt;120&lt;/code&gt;），這裡的&lt;code&gt;120&lt;/code&gt;可以代表字串或整數或浮點數，python會搶先認定&lt;code&gt;defaults&lt;/code&gt;值能用，儘管自訂的&lt;code&gt;k&lt;/code&gt;值後來轉成浮點數，結果仍然會是&lt;code&gt;defaults&lt;/code&gt;值。&lt;/p&gt;
&lt;p&gt;所以最後不得以把&lt;code&gt;defaults&lt;/code&gt;值捨棄。&lt;/p&gt;
&lt;p&gt;最後結果：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/kuaUOnR.jpg" &gt;&lt;/p&gt;
&lt;p&gt;建立了一支Openshift程式，但是上傳後卻無法使用，不知道是Python 3.3還是其他的問題，整個程式都跑不了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/tSmySff.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;最近因為有點感冒，研究bokeh的互動功能函式滿久的。&lt;/p&gt;
&lt;p&gt;嘗試過用3D的方式解手臂極限範圍，但是程式庫有些盲點。&lt;/p&gt;
&lt;p&gt;SLVS似乎會認定4個約束在同平面的3D點，他們之間的2條連線如果約束為平行，是重複約束，目前不知道要怎麼辦。&lt;/p&gt;</summary><category term="bokeh"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/08/05</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050805.html" rel="alternate"></link><published>2016-08-05T21:00:00+08:00</published><updated>2016-08-05T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-05:blog/40323230ri-zhi-1050805.html</id><summary type="html">&lt;p&gt;使用bokeh繪圖&lt;/p&gt;


&lt;h1&gt;bokeh&lt;/h1&gt;
&lt;p&gt;由於mpld3沒有支援Python 3.5，測試過執行產生的頁面是空白頁，所以選擇使用bokeh來繪製，但是後者不支援3D繪圖。&lt;/p&gt;
&lt;p&gt;使用Anaconda的指令安裝bokeh。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ana install bokeh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img src="http://i.imgur.com/mjv0nNb.jpg" &gt;&lt;/p&gt;
&lt;p&gt;參照了一下官方的說明頁：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://bokeh.pydata.org/en/latest/docs/installation.html" title="bokeh.pydata.org"&gt;http://bokeh.pydata.org/en/latest/docs/installation.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://bokeh.pydata.org/en/latest/docs/reference/io.html" title="bokeh.pydata.org"&gt;http://bokeh.pydata.org/en/latest/docs/reference/io.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://bokeh.pydata.org/en/latest/docs/user_guide/notebook.html" title="bokeh.pydata.org"&gt;http://bokeh.pydata.org/en/latest/docs/user_guide/notebook.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;

&lt;h1&gt;Exercise&lt;/h1&gt;
&lt;p&gt;將之前的Crank Rocker改寫一下鏈&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#一三角形呆鍊，由一長一短的連桿固定在水平基線上。
#短連桿鎖固在原點上，長連鏈鎖固在距原點90mm處。
#短連桿長度35mm；長連桿長度70mm。
#三角形呆鍊邊長分別為40mm、40mm、70mm
from slvs import *
from math import *
from bokeh.plotting import figure, output_file, show

#相關參數
d0 = 90 #基線長度(mm)
n1 = 35 #短連桿長度(mm)
n2 = 70 #長連桿長度(mm)
t1 = 40 #三角形第一邊(mm)
t2 = 40 #三角形第二邊(mm)
t3 = 70 #三角形第三邊(mm)

#開始繪圖

def crank_rock(degree):

    sys = System(500)
    g = 1
    #原點Point0
    p0 = sys.add_param(0.0)
    p1 = sys.add_param(0.0)
    p2 = sys.add_param(0.0)
    Point0 = Point3d(p0, p1, p2)

    #XY法線
    qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0)
    p3 = sys.add_param(qw)
    p4 = sys.add_param(qx)
    p5 = sys.add_param(qy)
    p6 = sys.add_param(qz)
    Normal1 = Normal3d(p3, p4, p5, p6)

    #工作平面
    Workplane1 = Workplane(Point0, Normal1)

    #3D版的Point0=&gt;Point1
    p7 = sys.add_param(0.0)
    p8 = sys.add_param(0.0)
    Point1 = Point2d(Workplane1, p7, p8)
    Constraint.dragged(Workplane1, Point1)

    #長連桿轉軸Point2，還有基線Line0。
    p9 = sys.add_param(d0)
    p10 = sys.add_param(0.0)
    Point2 = Point2d(Workplane1, p9, p10)
    Constraint.dragged(Workplane1, Point2)
    Line0 = LineSegment2d(Workplane1, Point1, Point2)

    #Angle約束判斷
    if degree &gt;= 180:
        other = -1
    else:
        other = 1

    #三角形Point3 / Point4 / Point5
    p11 = sys.add_param(20.0)
    p12 = sys.add_param(20.0)
    Point3 = Point2d(Workplane1, p11, p12)
    p13 = sys.add_param(0.0)
    p14 = sys.add_param(10.0*other)
    Point4 = Point2d(Workplane1, p13, p14)
    p15 = sys.add_param(30.0)
    p16 = sys.add_param(20.0)
    Point5 = Point2d(Workplane1, p15, p16)
    Constraint.distance(t1, Workplane1, Point4, Point3)
    Constraint.distance(t2, Workplane1, Point3, Point5)
    Constraint.distance(t3, Workplane1, Point4, Point5)

    #連桿約束
    Constraint.distance(n1, Workplane1, Point1, Point4)
    Constraint.distance(n2, Workplane1, Point2, Point5)
    Line1 = LineSegment2d(Workplane1, Point1, Point4)

    #短連桿與水平軸的角度
    Constraint.angle(Workplane1, degree, Line1, Line0, False)

    #以下解題

    sys.solve()

    if (sys.result == SLVS_RESULT_OKAY):
        x = sys.get_param(11).val
        y = sys.get_param(12).val
        return x, y
    elif (sys.result == SLVS_RESULT_INCONSISTENT):
        print ("solve failed")
        print ("SLVS_RESULT_INCONSISTENT")
        print ("%d DOF" % sys.dof)
    elif (sys.result == SLVS_RESULT_DIDNT_CONVERGE):
        print ("solve failed")
        print ("SLVS_RESULT_DIDNT_CONVERGE")
        print ("%d DOF" % sys.dof)
    elif (sys.result == SLVS_RESULT_TOO_MANY_UNKNOWNS):
        print ("solve failed")
        print ("SLVS_RESULT_TOO_MANY_UNKNOWNS")
        print ("%d DOF" % sys.dof)

#主程式
Xval  = []
Yval  = []

for i in range(0, 361):
    x, y = crank_rock(i)
    Xval += [x]
    Yval += [y]
print ("Solve Completed")

#bokeh
output_file("mango.html")
plot = figure(title="simple line example", x_axis_label='x', y_axis_label='y')
plot.line(Xval, Yval, legend="Temp.", line_width=2)
show(plot)
&lt;/pre&gt;

&lt;p&gt;使用的是簡單的show指令，會產生一個&lt;code&gt;html&lt;/code&gt;的檔案。&lt;/p&gt;
&lt;p&gt;內容是和matplotlib一樣的圖形。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/05kAM03.png" &gt;&lt;/p&gt;
&lt;p&gt;另外bokeh也可以在Jupyter notebook上使用。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from tmp.workplace.exposed.slvs import *
from math import *
from bokeh.plotting import figure, output_notebook, show

d0 = 90 #基線長度(mm)
n1 = 35 #短連桿長度(mm)
n2 = 70 #長連桿長度(mm)
t1 = 40 #三角形第一邊(mm)
t2 = 40 #三角形第二邊(mm)
t3 = 70 #三角形第三邊(mm)

#開始繪圖

def crank_rock(degree):
    ...

#主程式
Xval  = []
Yval  = []

for i in range(0, 361):
    x, y = crank_rock(i)
    Xval += [x]
    Yval += [y]
print ("Solve Completed")

#bokeh
output_notebook()
plot = figure(title="simple line example", x_axis_label='x', y_axis_label='y')
plot.line(Xval, Yval, legend="Temp.", line_width=2)
show(plot)
&lt;/pre&gt;

&lt;p&gt;程式庫名稱必須改為&lt;code&gt;tmp.workplace.exposed.slvs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;執行結果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/WHoVdrV.jpg" &gt;&lt;/p&gt;
&lt;p&gt;另一支跑手臂極限範圍的程式：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/dQM4kck.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;有找到另一個套件Vispy可以畫3D物件，也可以在Jupyter notebook上執行。&lt;/p&gt;
&lt;p&gt;另外Solvespace的運算方面無法同時計算2D和3D的物件，儲存的項目也不一樣。&lt;/p&gt;
&lt;p&gt;不知道能不能用球座標系或圓柱坐標系轉換的方式，做一個將3D點鎖定到2D點的功能。&lt;/p&gt;</summary><category term="bokeh"></category></entry><entry><title>40323230日誌 - 105/08/03</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050803.html" rel="alternate"></link><published>2016-08-03T21:00:00+08:00</published><updated>2016-08-03T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-03:blog/40323230ri-zhi-1050803.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;研究Scoop的使用方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;檢查錯誤&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;參考資料：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://scoop.readthedocs.io/en/latest/usage.html" title="scoop.readthedocs.io"&gt;http://scoop.readthedocs.io/en/latest/usage.html&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;啟動Scoop&lt;/h1&gt;
&lt;p&gt;為了讓自己製作的函式庫能進行分工運算，想要用一些工具讓SLVS Library能夠支援平行運算功能。&lt;/p&gt;
&lt;p&gt;用pip安裝scoop。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pip install scoop&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Scoop的需求：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Distribute &amp;gt;= 0.6.2 or setuptools &amp;gt;= 0.7
Greenlet &amp;gt;= 0.3.4
pyzmq &amp;gt;= 13.1.0 and libzmq &amp;gt;= 3.2.0
ssh for remote execution
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上述的套件Anaconda都有安裝了，不過在連線方面還不知道如何設定。&lt;/p&gt;
&lt;p&gt;用&lt;code&gt;python -m scoop&lt;/code&gt;啟動後會顯示［WinError 10022］，上網找資料發現是沒有指定特定目標。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/9SKyqDY.jpg" &gt;&lt;/p&gt;
&lt;p&gt;Scoop的Help指令。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/XjVDlDJ.jpg" &gt;&lt;/p&gt;
&lt;h1&gt;Scoop函式&lt;/h1&gt;
&lt;p&gt;啟動後，在python程式中導入scoop。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from scoop import futures, shared

def myParallelFunc(inValue):
    myValue = shared.getConst('myValue')
    return inValue + myValue

if __name__ == '__main__':
    shared.setConst(myValue=5)
    print(list(futures.map(myParallelFunc, range(10))))
&lt;/pre&gt;

&lt;p&gt;或是使用指令執行單一檔案也可以。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;python -m scoop --hostfile hosts -vv -n 6 your_program.py [your arguments]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Scoop可以分享函式給其他電腦，並在同時間回饋相同訊息。&lt;/p&gt;
&lt;p&gt;而每台電腦可以平均分配需要運算的項目，達成多工的目的。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;今天花太多時間檢查ZeroMQ (libzmq)的安裝狀態，因為不同語言的需求好像都不一樣，Python已經包含在pyzmq中（Windows版本應該是如此，但是Linux要另外裝和設定lib位置）；而C語言是安裝後從安裝位置include。&lt;/p&gt;
&lt;p&gt;而ZeroMQ也能導入Python中，不過Scoop給的指令更方便。&lt;/p&gt;
&lt;p&gt;關於Scoop的說明和介紹資料好像滿少的，而網路方面不知道如何架設。&lt;/p&gt;</summary><category term="pyScoop"></category></entry><entry><title>40323231日誌 - 指令(G碼、M碼...)</title><link href="http://project.mde.tw/blog/40323231ri-zhi-zhi-ling-gma-mma.html" rel="alternate"></link><published>2016-08-02T14:00:00+08:00</published><updated>2016-08-02T14:00:00+08:00</updated><author><name>40323231</name></author><id>tag:project.mde.tw,2016-08-02:blog/40323231ri-zhi-zhi-ling-gma-mma.html</id><summary type="html">&lt;p&gt;常用指令與解說&lt;/p&gt;


&lt;h3&gt;常用指令&lt;/h3&gt;

&lt;h4&gt;G28 : 原點複歸&lt;/h4&gt;

&lt;h4&gt;G29 : 自動校正&lt;/h4&gt;

&lt;h4&gt;G01 X70 Y60 Z5 : 快速定位  X70 Y60 高度5&lt;/h4&gt;

&lt;h4&gt;M104 : 設定噴頭溫度&lt;/h4&gt;

&lt;h4&gt;M105 : 查詢溫度(噴頭和熱床)&lt;/h4&gt;

&lt;h4&gt;M106 : 開啟風扇&lt;/h4&gt;

&lt;h4&gt;M107 : 關閉風扇&lt;/h4&gt;

&lt;h4&gt;M114 : 查詢目前位置(例如:X40 Y50 Z5)&lt;/h4&gt;

&lt;h4&gt;M119 : 查詢限位開關目前狀態&lt;/h4&gt;

&lt;h4&gt;M500 : 儲存參數&lt;/h4&gt;

&lt;p&gt;&lt;br&gt;
&lt;h3&gt;字母定義&lt;/h3&gt;
&lt;h4&gt;G:範例說明&lt;/h4&gt;
&lt;h4&gt;M:範例說明&lt;/h4&gt;
&lt;h4&gt;T:選擇工具，單一噴頭所以無用&lt;/h4&gt;
&lt;h4&gt;S:命令參數，如電壓，控制轉速、溫度等等&lt;/h4&gt;
&lt;h4&gt;P:命令參數，多少毫秒&lt;/h4&gt;
&lt;h4&gt;F:每分鐘進給(毫米)&lt;/h4&gt;
&lt;h4&gt;E:擠出材料的長度(毫米)&lt;/h4&gt;
&lt;br&gt;
&lt;h3&gt;其他指令說明&lt;/h3&gt;
&lt;h4&gt;G4的：暫停&lt;/h4&gt;
&lt;h4&gt;例如：G4 P200&lt;/h4&gt;
&lt;h4&gt;在這種狀態下暫停200秒不工作。在延時時的機器狀態下(例如:擠出機溫度)仍然會被保留和控制。&lt;/h4&gt;
&lt;h4&gt;G20 設定從現在開始為英寸&lt;/h4&gt;
&lt;h4&gt;G21 設定從現在開始為毫米&lt;/h4&gt;
&lt;h4&gt;G90 從現在開始，所有的座標都是絕對座標&lt;/h4&gt;
&lt;h4&gt;G91 設定現在位置為原點，之後的都為相對座標&lt;/h4&gt;&lt;/p&gt;
&lt;h4&gt;M0 停止&lt;/h4&gt;

&lt;h4&gt;M18 禁止所有步進馬達&lt;/h4&gt;

&lt;h4&gt;M20：列出SD卡&lt;/h4&gt;

&lt;h4&gt;M21：初始化SD卡&lt;/h4&gt;

&lt;h4&gt;M22：釋放SD卡&lt;/h4&gt;

&lt;h4&gt;M23：選擇SD文件&lt;/h4&gt;

&lt;h4&gt;M24：啟動/恢復SD列印&lt;/h4&gt;

&lt;h4&gt;M25：暫停SD列印&lt;/h4&gt;

&lt;h4&gt;M26：設置的SD位置&lt;/h4&gt;

&lt;h4&gt;M27：報告SD列印狀態&lt;/h4&gt;

&lt;h4&gt;M28：開始寫入到SD卡&lt;/h4&gt;

&lt;h4&gt;M29：停止向SD卡寫入&lt;/h4&gt;

&lt;h4&gt;M42：用盡材料時停止(XY回歸原點但Z沒有，關閉所有電器和加熱器，要重新開始必須複歸，之後繼續列印)&lt;/h4&gt;

&lt;h4&gt;M43: 用盡材料時等待(與M42相似，可是M43還可以下指令如G碼和M碼)&lt;/h4&gt;

&lt;h4&gt;M101:正轉啟動擠出馬達&lt;/h4&gt;

&lt;h4&gt;M102:逆向啟動擠出馬達&lt;/h4&gt;

&lt;h4&gt;M109:設定擠出溫度&lt;/h4&gt;

&lt;h4&gt;M112：緊急停止(全部動作停止包括電器關閉)&lt;/h4&gt;

&lt;h4&gt;M113：設定擠出機的的PWM，例如:M113 S0.7，設定為擠出機70%速度，未用過猜測與軟體內的流量設定相同功用&lt;/h4&gt;

&lt;h4&gt;M303 S200 C8 : 設定目標溫度200，並做8次震盪&lt;/h4&gt;

&lt;p&gt;&lt;a href = "http://www.simplyalt.com/atom/viewthread.php?tid=1560&amp;highlight=PID"&gt; 震盪參考 &lt;/a&gt;&lt;/p&gt;</summary><category term="3DP"></category></entry><entry><title>40323250日誌 - v-rep實做心得</title><link href="http://project.mde.tw/blog/40323250ri-zhi-v-repshi-zuo-xin-de.html" rel="alternate"></link><published>2016-08-02T11:15:00+08:00</published><updated>2016-08-02T11:15:00+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2016-08-02:blog/40323250ri-zhi-v-repshi-zuo-xin-de.html</id><summary type="html">&lt;p&gt;V-rep 與 Solvespace的結合應用&lt;/p&gt;


&lt;h3&gt;最近開了很多V-rep的範例檔來看 ,但都不太有收穫 ,為了避免浪費時間 ,回去找了之前老師提到的solvespace和vrep的共同運用 ,也因為要完成3D - Printer就要先了解基本觀念和用法 ,所以就抓了檔案來測試 &lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vrep_solvespace.png" &gt;
&lt;h3&gt;(檔案位於solvespace官網的 tutorial : linkages)
&lt;/h3&gt;&lt;p&gt;&lt;a href="http://solvespace.com/dl/mechanisms.zip "&gt;壓縮檔載點&lt;/a&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;h3&gt;由於各零件之軸孔沒有軸連接 ,導致旋轉軸無法放置 ,所以我把軸都畫上去了 ,檔案為g2目錄下的solvespcae_vrep&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/solvespace_vrep.png"&gt;
&lt;/br&gt;
&lt;h3&gt;Solvespace的長料與除料功能真的不太習慣 ,很容易造成運算錯誤&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;軸都放好了 ,只是從屬關係還是不太清楚要如何放置&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/solvespace_vrep_allaxis.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;結果我又弄了一個圖 ,試圖從這邊學習從屬設定&lt;/h3&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_test.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;目前只會讓它亂轉&lt;/h3&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_test.gif"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;感覺和各個旋轉軸速度也有關係&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_test2.gif"&gt;
&lt;hr&gt;
&lt;h3&gt;105 - 07/10更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;現在能夠讓連桿旋轉了&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/4_links.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/4_links.gif" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;想要測試能否以固定角度來回旋轉 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/links_move.gif" &gt;
&lt;/br&gt;
&lt;h3&gt;但是要達到這樣的動作需要編寫程式 ,且還在研究script的類別以及revolute的type到底要用哪一種 ,這些花了很多時間...&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/scripts_types.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;目前先以控單軸為主 ,但是遇到以下狀況&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/scripts_control2.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/example_code1.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/code_error1.png" &gt;
&lt;h3&gt;如果是用左邊的script就不會有simWait的錯誤 ,但是它只會走90度 ,然後simWait就不會動了&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;參考 :&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/jointDescription.htm "&gt;Joint types and operation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/childScripts.htm#threaded "&gt;Child Scripts&lt;/a&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 07/11更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;Joint 種類分成以下4種 :&lt;/h3&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/joint-types.png" &gt;
&lt;/br&gt;
&lt;h4&gt;1. 為旋轉軸, 只有一個自由度 (旋轉), 用於一般旋轉軸。&lt;/h4&gt;
&lt;h4&gt;2. 為平移軸, 只有一個自由度 (平移), 物體能沿著軸線做平移。 &lt;/h4&gt;
&lt;h4&gt;3. 為旋轉與平移軸的結合, 只有一個自由度, 能夠使物體沿著軸做旋轉移動, 如同螺絲。&lt;/h4&gt;
&lt;h4&gt;4. 為球窩接頭, 有三個自由度, 用於類似關節的地方。&lt;/h4&gt;
&lt;/br&gt;
&lt;h3&gt;Control the joint :&lt;/h3&gt;
&lt;h4&gt;1.simSetJointPosition : when your joint is not in force/torque mode&lt;/h4&gt;
&lt;h4&gt;2.simSetJointTargetPosition : when your joint is in force/torque mode, its motor enabled and its control loop also enabled&lt;/h4&gt;
&lt;h4&gt;3.simSetJointTargetVelocity : when your joint is in force/torque mode, its motor enabled, and its control loop NOT enabled&lt;/h4&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;今天回去翻老師的信, 才發現裡面有四連桿的範例, 以下為測試:&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/4_links_move.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/4_links_move.gif" &gt;
&lt;/br&gt;
&lt;h3&gt;只要設定一個轉軸, 其他設定好就可以跟著一起做動, 但是在程式部分, if 條件還是不太懂, 很容易出現lua錯誤, 還有很多語法要理解。&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 07/12更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;今天拿老師的程式去跑小車子 ,但是joint的角度只要定在360就跟0度一樣 ,要如何才能超過這個範圍還在思考... &lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/g2_files/little_car.ttt?raw=true"&gt;little_car.ttt&lt;/a&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/little_car.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 07/14更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;今天參照了irb360範例, 試著組了printer, 前面還算順利, 在中間的 close chain部分 還要加上重疊的Revolute 來限制移動, 最後再搭上dummy 應該就可以控制了&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/Printer_new.png" &gt;
&lt;/br&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/g2_files/printer_new.ttt?raw=true"&gt;printer_new.ttt&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/g2_files/printer_new_2.ttt?raw=true"&gt;printer_new_2.ttt&lt;/a&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 07/15更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;今天開始研究Inverse Kinematic 逆向運動學(IK) ,透過矩正及向量運算 ,就可以得到參數 ,且恰巧有學長論文和此相關 ,從中學到了不少 ,但還沒能弄懂 ,最後要結合進V-rep模擬中 ,腳步要加快了&lt;/h3&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 07/17更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;Solvespace測試連桿運動方式&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/solvespace_tutorial.gif" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;旋轉軸定義&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/solvespace_pic.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;子屬關係設定 (測試) ,加上dummy固定&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/relation_test.png" &gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;經過一番波折 ,終於和同學弄出來了 ,只要無法封閉的部分利用dummy固定就可以了 ,至於實體轉軸部分要搭接在桿子上才可以&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/g2_files/solvespace_successful.ttt?raw=true"&gt;solvespace_successful&lt;/a&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/solvespace_successful.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/solvespace_successful.gif" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 07/18更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;嘗試幫第一組 組裝手臂, 除了夾爪部分外 ,其餘都組裝好了 ,過程發現部分零件拆解後會有座標不對的問題 ,只要將做標調整和world相同就比較容易了&lt;/h3&gt;
&lt;h3&gt;(參照範例: 7 DoF manipulator 設定ik值)&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/arm_test.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/arm_test.gif" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 07/24更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;今天預計要測試馬達控制 ,但是沒有多的12V power supply ,所以先把Onshape ,printer的細部畫一畫 ,現在大概有300個特徵 ,本來可以輕鬆的拉動滑塊 ,現在要用箭頭才能拉動了 ,估計不會畫電路板部分 ,戲偶衣服穿太多了&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/printer_top.gif" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/printer_bottom.gif" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;script src="https://embed.github.com/view/3d/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/printer.stl"width="300"height="300"&gt;&lt;/script&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 07/28更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;暫時利用可變電阻取代步進馬達 ,並加入馬達轉軸 ,控制加熱頭移動&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/printer_control.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/Nsgt8YPSDpU" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 08/02更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;V-rep定位&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;在繪圖時 ,需要有一個對稱零件(輔助零件)在vrep內訂定位置 ,在定位之前 ,座標系要先調整&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/pos1.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/pos2.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;之後將主體設為此零件子屬&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/pos3.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;定位完之後就可以設為一個群組了&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/pos4.png" &gt;
&lt;/br&gt;&lt;/p&gt;</summary><category term="solvespace&amp;v-rep"></category></entry><entry><title>40323231日誌 - 105/08/01</title><link href="http://project.mde.tw/blog/40323231ri-zhi-1050801.html" rel="alternate"></link><published>2016-08-01T19:00:00+08:00</published><updated>2016-08-01T19:00:00+08:00</updated><author><name>40323231</name></author><id>tag:project.mde.tw,2016-08-01:blog/40323231ri-zhi-1050801.html</id><summary type="html">&lt;p&gt;網誌更新，列印組合件，觀看新軟體&lt;/p&gt;


&lt;h4&gt;今天把問題那篇網誌做新增和整理 ，並整理出常用指令一篇。&lt;/h4&gt;

&lt;h4&gt;列印組合件時，孔和外型的公差不太穩定，多次列印出來的公差也都不太一樣，有時會差到20條，還需要做改進和調整。&lt;/h4&gt;

&lt;h4&gt;今天列印需要支撐材的物件時，發現cura會生成很多不必要的支撐材，導致浪費，所以去尋找很多方法，其中有看到新的軟體Meshmixer，它的操作方式很獨特，跟其他3D繪圖軟體不一樣。網路教學讓軟體很多變，像是製作卡扣、拆解物件、填補漏洞、手動生成支撐材......等等，很多好用的功能，可是滿複雜的，還在學習。因為是新的軟體，所以花了比較多時間觀看，明天會把重心拉回來，繼續製作。&lt;/h4&gt;</summary><category term="3DP"></category></entry><entry><title>40323230日誌 - 105/07/31</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050731.html" rel="alternate"></link><published>2016-07-31T21:00:00+08:00</published><updated>2016-07-31T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-31:blog/40323230ri-zhi-1050731.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;新增範例Crank Rocker&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;準備整理函式庫內容，再製作英文版副本&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Crank Rocker範例&lt;/h1&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/EeRY鏈4H.jpg" &gt;&lt;/p&gt;
&lt;p&gt;模仿三角形呆鍊的圖形解題。&lt;/p&gt;
&lt;p&gt;用迴圈方式旋轉短連桿，讓三角形頂點畫出點座標。&lt;/p&gt;
&lt;p&gt;以下程式將輸出每一度畫出的點座標。&lt;/p&gt;
&lt;pre cla鏈s="brush: python"&gt;
#一三角形呆鍊，由一長一短的連桿固定在水平基線上。
#短連桿鎖固在原點上，長連桿鎖固在距原點90mm處。鏈鏈#短連桿長度35mm；長連桿長度70mm。
#三角形呆鍊邊長分別為40mm、40mm、70mm
from slvs import *
from math import *
import unittest

#相關參數
d0 = 90 #基線長度(mm)
n1 = 35 #短連桿長度(mm)
n2 = 70 #長連桿長度(mm)
t1 = 40 #三角形第一邊(mm)
t2 = 40 #三角形第二邊(mm)
t3 = 70 #三角形第三邊(mm)

#開始繪圖

def crank_rock(degree):
    sys = System(500)
    g = 1
    #原點Point0
    p0 = sys.add_param(0.0)
    p1 = sys.add_param(0.0)
    p2 = sys.add_param(0.0)
    Point0 = Point3d(p0, p1, p2)

    #XY法線
    qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0)
    p3 = sys.add_param(qw)
    p4 = sys.add_param(qx)
    p5 = sys.add_param(qy)
    p6 = sys.add_param(qz)
    Normal1 = Normal3d(p3, p4, p5, p6)

    #工作平面
    Workplane1 = Workplane(Point0, Normal1)

    #3D版的Point0=&gt;Point1
    p7 = sys.add_param(0.0)
    p8 = sys.add_param(0.0)
    Point1 = Point2d(Workplane1, p7, p8)
    Constraint.dragged(Workplane1, Point1)

    #長連桿轉軸Point2，還有基線Line0。
    p9 = sys.add_param(d0)
    p10 = sys.add_param(0.0)
    Point2 = Point2d(Workplane1, p9, p10)
    Constraint.dragged(Workplane1, Point2)
    Line0 = LineSegment2d(Workplane1, Point1, Point2)

    #Angle約束判斷
    if degree &gt;= 180:
        other = -1
    else:
        other = 1

    #三角形Point3 / Point4 / Point5
    p11 = sys.add_param(20.0)
    p12 = sys.add_param(20.0)
    Point3 = Point2d(Workplane1, p11, p12)
    p13 = sys.add_param(0.0)
    p14 = sys.add_param(10.0*other)
    Point4 = Point2d(Workplane1, p13, p14)
    p15 = sys.add_param(30.0)
    p16 = sys.add_param(20.0)
    Point5 = Point2d(Workplane1, p15, p16)
    Constraint.distance(t1, Workplane1, Point4, Point3)
    Constraint.distance(t2, Workplane1, Point3, Point5)
    Constraint.distance(t3, Workplane1, Point4, Point5)

    #連桿約束
    Constraint.distance(n1, Workplane1, Point1, Point4)
    Constraint.distance(n2, Workplane1, Point2, Point5)
    Line1 = LineSegment2d(Workplane1, Point1, Point4)

    #短連桿與水平軸的角度
    Constraint.angle(Workplane1, degree, Line1, Line0, False)

    #以下解題

    sys.solve()

    if (sys.result == SLVS_RESULT_OKAY):
        print ("點座標：")
        print(("P3(%.3f %.3f %.3f)")%(sys.get_param(11).val, sys.get_param(12).val, sys.get_param(2).val))
        print(("P4(%.3f %.3f %.3f)")%(sys.get_param(13).val, sys.get_param(14).val, sys.get_param(2).val))
        print ("%d DOF" % sys.dof)
    elif (sys.result == SLVS_RESULT_INCONSISTENT):
        print ("solve failed")
        print ("SLVS_RESULT_INCONSISTENT")
        print ("%d DOF" % sys.dof)
    elif (sys.result == SLVS_RESULT_DIDNT_CONVERGE):
        print ("solve failed")
        print ("SLVS_RESULT_DIDNT_CONVERGE")
        print ("%d DOF" % sys.dof)
    elif (sys.result == SLVS_RESULT_TOO_MANY_UNKNOWNS):
        print ("solve failed")
        print ("SLVS_RESULT_TOO_MANY_UNKNOWNS")
        print ("%d DOF" % sys.dof)

#主程式
for i in range(0, 360):
    print ("Degree: %3s deg"%(i))
    crank_rock(i)
    print ("=======")
print ("Solve Completed")
&lt;/pre&gt;

&lt;p&gt;輸出結果圖：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/r6qocmD.jpg" &gt;&lt;/p&gt;
&lt;p&gt;圖解法：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/LfDHVAi.jpg" &gt;&lt;/p&gt;
&lt;p&gt;這次旋轉的時候，角度約束似乎無法支援超過180度的角度，而會使用正值，讓原本在第一二象限的點&lt;code&gt;Point4&lt;/code&gt;座標無法移動至第三四象限。&lt;/p&gt;
&lt;p&gt;因此在起始定點時的象限位置非常重要，加入了&lt;code&gt;if&lt;/code&gt;判斷式讓&lt;code&gt;Point4&lt;/code&gt;更改初始位置，就解決了這個問題。&lt;/p&gt;
&lt;p&gt;只有用來畫線，且線段有約束角度的點座標有限制。&lt;/p&gt;
&lt;p&gt;另一個要注意的是，要約束成三角形的三個點不可以共線。&lt;/p&gt;
&lt;p&gt;以下是正確值比對：&lt;/p&gt;
&lt;h2&gt;0&amp;deg;&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/L9IQWoY.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;45&amp;deg;&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/FQRIlkm.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;135&amp;deg;&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/TTFfRil.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;180&amp;deg;&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/iA1lXcy.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;225&amp;deg;&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/jZNqz0W.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;解了多個圖形題目後，發現之前寫的那篇還滿不容易查詢資料，而且前作者的內容有些錯誤。&lt;/p&gt;
&lt;p&gt;由於當初紀錄是靠&lt;code&gt;DOC.txt&lt;/code&gt;的順序寫的，所以要自己重新閱讀多次，將使用比例分配一下。&lt;/p&gt;</summary><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>40323231 -3DP注意事項</title><link href="http://project.mde.tw/blog/40323231-3dpzhu-yi-shi-xiang.html" rel="alternate"></link><published>2016-07-31T16:00:00+08:00</published><updated>2016-07-31T16:00:00+08:00</updated><author><name>40323231</name></author><id>tag:project.mde.tw,2016-07-31:blog/40323231-3dpzhu-yi-shi-xiang.html</id><summary type="html">&lt;p&gt;注意事項&lt;/p&gt;


&lt;h3&gt;一.固件安裝 :&lt;/h3&gt;

&lt;h4&gt;1.鎖固個螺絲時請依循鎖固方向(對角或順逆時鐘)，而且不要一次就鎖緊，分兩次至三次，避免不平或無法微調&lt;/h4&gt;

&lt;h4&gt;2.安裝滑塊時請勿推出滑軌外，避免滑塊內的滾珠掉出&lt;/h4&gt;

&lt;h4&gt;3.鎖固滑塊上用來控制限位的螺絲時，不要鎖太裡面，避免限位開關接收不到訊號，導致撞機，或者校機時無法做調整(圖.A)&lt;/h4&gt;

&lt;h4&gt;4.安裝喉管和噴頭塊以及噴嘴時一定要確定鎖緊，不然可能會有液料或漏料的問題(圖.B)&lt;/h4&gt;

&lt;h4&gt;5.安裝噴頭塊時不要直接接觸噴頭座，避免噴頭座過熱(圖.C)&lt;/h4&gt;

&lt;h4&gt;6.安裝擠出機時不要將料壓得太緊，避免進料不順&lt;/h4&gt;

&lt;h4&gt;7.安裝位於噴頭座上方的鐵氟龍管時，要量測插入的深度，以免列印時喉管堵塞&lt;/h4&gt;

&lt;h4&gt;8.安裝料和鐵氟龍管時可將前端剪成斜狀，方便安裝和進料&lt;/h4&gt;

&lt;h4&gt;9.安裝加熱棒時，請置中洞中，勿太裡面或太外面，以免加熱不確實，或加熱到其他地方(圖.D)&lt;/h4&gt;

&lt;h4&gt;10.安裝皮帶上面的固定鎖時勿一開始就鎖到緊，避免皮帶太鬆時無法做調整(圖.E)&lt;/h4&gt;

&lt;p&gt;&lt;br&gt;
&lt;img src="http://i.imgur.com/zGKlktf.jpg" &gt;
&lt;h4&gt;(圖.A)&lt;/h4&gt;
&lt;br&gt;
&lt;img src="http://i.imgur.com/hNHGnCJ.jpg" &gt;
&lt;h4&gt;(圖.B)&lt;/h4&gt;
&lt;br&gt;
&lt;img src="http://i.imgur.com/iPPgmVk.jpg" &gt;
&lt;h4&gt;(圖.C)&lt;/h4&gt;
&lt;br&gt;
&lt;img src="http://i.imgur.com/hidvXCI.jpg" &gt;
&lt;h4&gt;(圖.D)&lt;/h4&gt;
&lt;br&gt;
&lt;img src="http://i.imgur.com/xDtP6BW.jpg" &gt;
&lt;h4&gt;(圖.E)&lt;/h4&gt;
&lt;br&gt;
&lt;h3&gt;二.配電 :&lt;/h3&gt;
&lt;h4&gt;1.裸露的線要用熱縮管(套到需要的地方後用打火機讓館子收縮即可)或者PVC電氣絕緣膠帶包覆&lt;/h4&gt;
&lt;h4&gt;2.delta機型的噴頭上所有的線用捲束管包覆，避免電線纏繞打結或扯斷&lt;/h4&gt;
&lt;h4&gt;3.鐵氟龍管以及噴頭上方的電線長度要夠長，避免噴頭到最下方時被扯斷或撞機&lt;/h4&gt;
&lt;h4&gt;4.控制板上所有電線都需整線，避免內部過熱燒毀&lt;/h4&gt;
&lt;br&gt;
&lt;h3&gt;三.測機 :&lt;/h3&gt;
&lt;br&gt;
&lt;h4&gt;切記:如發生意外，請迅速切斷電源，切斷後不要立即開啟電源，請先關閉軟體的訊號，之後再做開電的動作，避免開電後訊號依
舊在，導致機台繼續損壞。&lt;/h4&gt;
&lt;h4&gt;切記:要跑動X、Y方向時噴頭高度不能在最高點，不然機台可能損壞&lt;/h4&gt;
&lt;h4&gt;切記:列印機與電腦操控軟體(如:pronterface)連接後務必G28原點複歸&lt;/h4&gt;
&lt;br&gt;
&lt;h4&gt;1.要確定三軸速度不要太高，避免回歸或者移動速度太快&lt;/h4&gt;
&lt;h4&gt;2.確定訊號為多少(250000或其他)&lt;/h4&gt;
&lt;h4&gt;3.確定噴頭高度(程式)&lt;/h4&gt;
&lt;h4&gt;4.不要把列印範圍(平台大小)設最大，因為噴頭座可能會撞到各軸，或跑出外面導致列印品質低&lt;/h4&gt;
&lt;h4&gt;5.要確定限位開關是否有作用&lt;/h4&gt;
&lt;h4&gt;6.要下降Z方向時要注意高度，G1 Z20，避免撞機&lt;/h4&gt;
&lt;h4&gt;7.確定XYZ和擠出軸轉向是否正常&lt;/h4&gt;
&lt;h4&gt;8.跑動X、Y方向時噴頭高度不要靠近熱床，因為跑動時可能是碗公型，可能會撞擊熱床&lt;/h4&gt;
&lt;br&gt;
&lt;h3&gt;四.列印 :&lt;/h3&gt;
&lt;h4&gt;1.務必檢查列印成品是否超過列印大小&lt;/h4&gt;
&lt;h4&gt;2.列印前請用口紅膠或特定膠帶弄在熱床上，可避免列印時材料不能貼緊熱床&lt;/h4&gt;
&lt;h4&gt;3.前幾次列印請注意列印狀況以及擠料狀況(跳線、擠不進去等等)&lt;/h4&gt;&lt;/p&gt;</summary><category term="3DP"></category></entry><entry><title>40323250日誌 - V-rep &amp; 3D-Printer</title><link href="http://project.mde.tw/blog/40323250ri-zhi-v-rep-3d-printer.html" rel="alternate"></link><published>2016-07-30T22:10:00+08:00</published><updated>2016-07-30T22:10:00+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2016-07-30:blog/40323250ri-zhi-v-rep-3d-printer.html</id><summary type="html">&lt;p&gt;之後的 V-rep模擬Printer都整理於本文章中&lt;/p&gt;


&lt;h3&gt;透過Tkinter介面及remote api 控制printer參數&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h3&gt;程式碼&lt;/h3&gt;&lt;/p&gt;
&lt;pre class="brush: python"&gt;

from tkinter import *
import serial
import sys
import numpy as np
from matplotlib import pyplot, rcParams
import vrep
import math



class printer(Frame):
    def __init__(self, master=None):
        Frame.__init__(self, master)
        self.grid()
        self.createWidgets()

    def createWidgets(self):



        Label(pri, text="Axis").grid(column=0, row=0)
        Label(pri, text="").grid(column=0, row=1)
        Label(pri, text="X").grid(column=0, row=2)
        Label(pri, text="").grid(column=0, row=3)
        Label(pri, text="Y").grid(column=0, row=4)
        Label(pri, text="").grid(column=0, row=5)
        Label(pri, text="Z").grid(column=0, row=6)

        Label(pri, text="Position").grid(column=1, row=0)
        Label(pri, text="-125&lt;=X&lt;=125").grid(column=1, row=1)
        Label(pri, text="-125&lt;=Y&lt;=125").grid(column=1, row=3)
        Label(pri, text="0&lt;=Z&lt;=400").grid(column=1, row=5)

        a = Entry(pri, width=12, justify=RIGHT)
        b = Entry(pri, width=12, justify=RIGHT)
        c = Entry(pri, width=12, justify=RIGHT)
                #x.delete(0,END)
                #y.delete(0,END)
        a.grid(row=2, column=1)
        b.grid(row=4, column=1)
        c.grid(row=6, column=1)


        def show_entry_fields():

            deg = math.pi/180

            x = a.get()
            y = b.get()
            z = c.get()

            if x =='' or y==''or z =='':
                x = 0
                y = 0
                z = 0
                print("Error")

            else:
                x = float(a.get())
                y = float(b.get())
                z = float(c.get())


                if float(x) &gt;= 125:
                    x = 125
                    print("X_axis is out of range")
                if float(y) &gt;= 125:
                    y = 125
                    print("Y_axis is out of range")
                if float(z) &gt;= 400:
                    z = 400     
                    print("Z_axis is out of range")
                if float(x) &lt;= -125:
                    x = -125
                    print("X_axis is out of range")
                if float(y) &lt;= -125:
                    y = -125
                    print("Y_axis is out of range")
                if float(z) &lt; 0:
                    z = 0
                    print("Z_axis is out of range")

                if (float(x) &lt;= -125*math.sin(30*deg)) &amp; (float(y) &gt;= 125*math.cos(30*deg)):
                    x = -125*math.sin(30*deg)
                    y = 125*math.cos(30*deg)

                if (float(x) &lt;= -125*math.sin(30*deg)) &amp; (float(y) &lt;= -125*math.cos(30*deg)):
                    x = -125*math.sin(30*deg)
                    y = -125*math.cos(30*deg)

                if (float(x) &gt;= 125*math.sin(30*deg)) &amp; (float(y) &gt;= 125*math.cos(30*deg)):
                    x = 125*math.sin(30*deg)
                    y = 125*math.cos(30*deg)

                if (float(x) &gt;= -125*math.sin(30*deg)) &amp; (float(y) &lt;= -125*math.cos(30*deg)):
                    x = 125*math.sin(30*deg)
                    y = -125*math.cos(30*deg)


                e=x/1000
                r=y/1000
                t=z/889
                if t &lt;= 0.11656:
                    t = t+0.11656


                vrep.simxFinish(-1)
                clientID = vrep.simxStart('127.0.0.1', 19999, True, True, 5000, 5)
                if clientID!= -1:
                    print("Connected to remote server")
                else:
                    print('Connection not successful')
                    sys.exit('Could not connect')
                errorCode,plate=vrep.simxGetObjectHandle(clientID,'plate',vrep.simx_opmode_oneshot_wait)
                if errorCode == -1:
                    print('Can not find left or right motor')
                    sys.exit()                
                errorCode=vrep.simxSetObjectPosition(clientID,plate,-1,[e,r,t], vrep.simx_opmode_oneshot)
                print(x,y,z)


                #print("%s,%s,%s" % (x, y, z))


        Button(pri, text='Quit', width=5, command=pri.quit).grid(row=8, column=2, sticky=W, pady=4)
        Button(pri, text='Go', width=5, command=show_entry_fields).grid(row=8, column=0, sticky=W, pady=4)



if __name__ == '__main__':
    pri = Tk()
    pri.title("Printer")
    pri.geometry('180x220');  #設定視窗大小
    pri.resizable(0, 0) #鎖定視窗大小
    app = printer(master=pri)

    app.mainloop()


#print(x,y,z)

&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/g2_files/printer_final.ttt?raw=true"&gt;printer_final.ttt&lt;/a&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/UhC2eP_vbrA" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/br&gt;&lt;/p&gt;</summary><category term="v-rep&amp;tkinter"></category></entry><entry><title>40323231日誌 - 105/07/30</title><link href="http://project.mde.tw/blog/40323231ri-zhi-1050730.html" rel="alternate"></link><published>2016-07-30T21:00:00+08:00</published><updated>2016-07-30T21:00:00+08:00</updated><author><name>40323231</name></author><id>tag:project.mde.tw,2016-07-30:blog/40323231ri-zhi-1050730.html</id><summary type="html">&lt;p&gt;3DP維修&lt;/p&gt;


&lt;h4&gt;今天維修3DP，因為3DP擠出的料變得非常的少，導致成品稀疏和脆弱，而且還發現進料馬達有在旋轉，可是料卻擠不進去。&lt;/h4&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h4&gt;一開始先加熱之後開始清理喉管，清完後校機重新印製，可是情況還是一樣，再來我改變進料速度(80%.60%)，可是依舊如此。&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;再來將噴頭座整組拔出，測量鐵氟龍管插入喉管的深度和全新的做比較，發現深度差很多因此用燈照進去，發現有整塊白色的硬塊堵住，所以又加熱再拿尖銳物將裡面清空，並重新測量鐵氟龍管插入深度，確定可以後校機再重新印製，情況還是一樣，之後加熱更換噴頭，弄完校機後再印製，情況有所改善，可是進料有時候料會擠不進去，所以更改進料速度(最新值:65%)，現在情況已經穩定，印出的公差也調整過，公差在+4條。&lt;/h4&gt;
&lt;h4&gt;列印兩次後發現噴頭座有部分地方會有液料情況，重新鎖固鎖緊後就OK。(重組後須檢查是否鎖緊。)&lt;/h4&gt;&lt;/p&gt;
&lt;h4&gt;拆卸下來的噴頭需要用0.3大小的鑽頭去清理，還需要討論要怎麼處理噴頭。&lt;/h4&gt;</summary><category term="3DP"></category></entry><entry><title>40323230日誌 - 105/07/30</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050730.html" rel="alternate"></link><published>2016-07-30T19:00:00+08:00</published><updated>2016-07-30T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-30:blog/40323230ri-zhi-1050730.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;新增範例Nutcraker&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Nutcraker範例&lt;/h1&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/OlGMGj4.jpg" &gt;&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#行程解題解題：兩個長1.5mm、2.3mm的連桿，在一直線上作動。
#原點的基座塊比工作路徑高0.5mm，寬0.75mm（占用0.38mm）。
#底線距離基座面3.25mm。
#2.3mm的連桿寬0.25mm，半圓頭。
#求最小行程（2.3mm的連桿與基座接觸）。
#求最大行程（半圓頭與底線接觸）。
from slvs import *
from math import *
sys = System(500)
g = 1

#相關參數
h0 = 0.5 #基塊高度(mm)
b0 = 0.75 #基塊寬度(mm)
n1 = 1.5 #後連桿長度(mm)
n2 = 2.3 #前連桿長度(mm)
R0 = 0.25 #半圓頭半徑(mm)
L0 = 3.25 #底線距離(mm)

#開始繪圖

#原點Point0
p0 = sys.add_param(0.0)
p1 = sys.add_param(0.0)
p2 = sys.add_param(0.0)
Point0 = Point3d(p0, p1, p2)

#XY法線
qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0)
p3 = sys.add_param(qw)
p4 = sys.add_param(qx)
p5 = sys.add_param(qy)
p6 = sys.add_param(qz)
Normal1 = Normal3d(p3, p4, p5, p6)

#工作平面
Workplane1 = Workplane(Point0, Normal1)

#3D版的Point0=&gt;Point1
p7 = sys.add_param(0.0)
p8 = sys.add_param(0.0)
Point1 = Point2d(Workplane1, p7, p8)
Constraint.dragged(Workplane1, Point1)

#連桿中繼點Point2和行程點Point3
p9 = sys.add_param(2.0)
p10 = sys.add_param(2.0)
Point2 = Point2d(Workplane1, p9, p10)
p11 = sys.add_param(2.0)
p12 = sys.add_param(0.0)
Point3 = Point2d(Workplane1, p11, p12)
Line0 = LineSegment2d(Workplane1, Point1, Point3)
Constraint.horizontal(Workplane1, Line0)

#前連桿碰到基座
Line1 = LineSegment2d(Workplane1, Point2, Point3)
p13 = sys.add_param(b0/2)
p14 = sys.add_param(h0)
Point4 = Point2d(Workplane1, p13, p14)
Constraint.dragged(Workplane1, Point4) #必須鎖住已知點
Constraint.distance(R0, Workplane1, Point4, Line1)
Constraint.distance(n1, Workplane1, Point1, Point2)
Constraint.distance(n2, Workplane1, Point2, Point3)

#以下解題

sys.solve()

Ansmin = sys.get_param(11).val - b0/2
Ansmax = L0 - R0 - b0/2

if (sys.result == SLVS_RESULT_OKAY):
    print ("點座標：")
    print(("P1(%.3f %.3f %.3f)")%(sys.get_param(7).val, sys.get_param(8).val, sys.get_param(2).val))
    print("P1(0.000 0.000 0.000)")
    print(("P2(%.3f %.3f %.3f)")%(sys.get_param(9).val, sys.get_param(10).val, sys.get_param(2).val))
    print("P2(-0.400 1.450 0.000)")
    print(("P3(%.3f %.3f %.3f)")%(sys.get_param(11).val, sys.get_param(12).val, sys.get_param(2).val))
    print("P4(1.390 0.000 0.000)\n")
    print("Min:")
    print(("(%.3f)")%(Ansmin))
    print("Max:")
    print(("(%.3f)")%(Ansmax))
    print ("%d DOF" % sys.dof)
elif (sys.result == SLVS_RESULT_INCONSISTENT):
    print ("solve failed")
    print ("SLVS_RESULT_INCONSISTENT")
    print ("%d DOF" % sys.dof)
    for i in range(sys.faileds):
        print(" %lu", sys.failed[i]);
elif (sys.result == SLVS_RESULT_DIDNT_CONVERGE):
    print ("solve failed")
    print ("SLVS_RESULT_DIDNT_CONVERGE")
    print ("%d DOF" % sys.dof)
elif (sys.result == SLVS_RESULT_TOO_MANY_UNKNOWNS):
    print ("solve failed")
    print ("SLVS_RESULT_TOO_MANY_UNKNOWNS")
    print ("%d DOF" % sys.dof)
&lt;/pre&gt;

&lt;p&gt;解題結果：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/TQjsd3C.jpg" &gt;&lt;/p&gt;
&lt;p&gt;Nutcracker只有單純的連桿，非常簡單。&lt;/p&gt;
&lt;p&gt;而之前的題目有相切約束，Solvespace解這種會有極限的約束都十分不便，常常會出現約束衝突或是正負不分的狀況。&lt;/p&gt;
&lt;p&gt;目前還不知道如何解決，只能多注意圓弧曲線的地方，可以用距離約束取代的地方就盡量不用額外輔助線。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;倉儲中嵌入副模組&lt;/h1&gt;
&lt;p&gt;在倉儲中加入了BBBSnowball的模組SolidPython，不過不知道怎麼用。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
git submodule add https://github.com/BBBSnowball/SolidPython.git solid-python
&lt;/pre&gt;

&lt;p&gt;應該只是單純放著支援功能。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/QBhyKgH.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;之前"SLVS資料庫函式"那篇還需要檢查一下，或是做一個英文版副本連結到倉儲Readme。&lt;/p&gt;
&lt;p&gt;雖然轉到Python介面中不只那些指令，但是只靠這些指令就能解題目了。&lt;/p&gt;
&lt;p&gt;進階應用如切換群組等，稍微看一下原本的範例code或CDemo的原始碼應該就能瞭解。&lt;/p&gt;</summary><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/29</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050729.html" rel="alternate"></link><published>2016-07-29T19:00:00+08:00</published><updated>2016-07-29T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-29:blog/40323230ri-zhi-1050729.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;CDemo資料庫內容補正&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;資料庫解題成功&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;修復內容&lt;/h1&gt;
&lt;p&gt;使用修復過的資料庫內容解題，新增將近三分之一的對應函式。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/7iQxUpJ.jpg" &gt;&lt;/p&gt;
&lt;p&gt;這些函式中也包括需要的相切約束。&lt;/p&gt;
&lt;p&gt;由於這些函式都未有對應名稱，所以都是自己編名的，例如&lt;code&gt;equal_angle( )&lt;/code&gt;。&lt;/p&gt;
&lt;h1&gt;解題成功&lt;/h1&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/XddGS1n.jpg" &gt;&lt;/p&gt;
&lt;p&gt;使用的是下列程式碼，在SciTE中解題成功：鏈鏈
&lt;pre class="brush: python"&gt;&lt;/p&gt;
&lt;h1&gt;鍊條解題：18齒與30齒的鏈條，上下外切線長為200。&lt;/h1&gt;
&lt;h1&gt;小圓圓心為原點，大圓圓心在X軸上，求四個切點的座標&lt;/h1&gt;
&lt;p&gt;from slvs import &lt;em&gt;
from math import &lt;/em&gt;
sys鏈= System(500)
g = 1&lt;/p&gt;
&lt;h1&gt;相關參數&lt;/h1&gt;
&lt;p&gt;n0 = 20 #鍊條長度(mm)
n1 = 18 #小輪齒數(t)
n2 = 30 #大輪齒數(t)&lt;/p&gt;
&lt;h1&gt;邊長為a的的正n邊形外接圓半徑為：&lt;/h1&gt;
&lt;h1&gt;R=a/(2&lt;em&gt;sin(pi/n)) or R=(a/2)&lt;/em&gt;csc(pi/n)&lt;/h1&gt;
&lt;p&gt;R1 = n0/(2&lt;em&gt;sin(pi/n1))
R2 = n0/(2&lt;/em&gt;sin(pi/n2))&lt;/p&gt;
&lt;h1&gt;開始繪圖&lt;/h1&gt;
&lt;h1&gt;原點Point0&lt;/h1&gt;
&lt;p&gt;p0 = sys.add_param(0.0)
p1 = sys.add_param(0.0)
p2 = sys.add_param(0.0)
Point0 = Point3d(p0, p1, p2)&lt;/p&gt;
&lt;h1&gt;XY法線&lt;/h1&gt;
&lt;p&gt;qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0)
p3 = sys.add_param(qw)
p4 = sys.add_param(qx)
p5 = sys.add_param(qy)
p6 = sys.add_param(qz)
Normal1 = Normal3d(p3, p4, p5, p6)&lt;/p&gt;
&lt;h1&gt;工作平面&lt;/h1&gt;
&lt;p&gt;Workplane1 = Workplane(Point0, Normal1)&lt;/p&gt;
&lt;h1&gt;3D版的Point0=&amp;gt;Point1&lt;/h1&gt;
&lt;p&gt;p7 = sys.add_param(0.0)
p8 = sys.add_param(0.0)
Point1 = Point2d(Workplane1, p7, p8)
Constraint.dragged(Workplane1, Point1)&lt;/p&gt;
&lt;h1&gt;Point2&lt;/h1&gt;
&lt;p&gt;p9 = sys.add_param(0.0)
p10 = sys.add_param(200.0)
Point2 = Point2d(Workplane1, p9, p10)&lt;/p&gt;
&lt;h1&gt;上端外切線的兩個點Point3和Point4&lt;/h1&gt;
&lt;p&gt;p11 = sys.add_param(0.0)
p12 = sys.add_param(500.0)
Point3 = Point2d(Workplane1, p11, p12)
p13 = sys.add_param(500.0)
p14 = sys.add_param(500.0)
Point4 = Point2d(Workplane1, p13, p14)&lt;/p&gt;
&lt;h1&gt;下端外切線的兩個點Point5和Point6&lt;/h1&gt;
&lt;p&gt;p15 = sys.add_param(0.0)
p16 = sys.add_param(-500.0)
Point5 = Point2d(Workplane1, p15, p16)
p17 = sys.add_param(500.0)
p18 = sys.add_param(-500.0)
Point6 = Point2d(Workplane1, p17, p18)&lt;/p&gt;
&lt;h1&gt;外切線&lt;/h1&gt;
&lt;p&gt;Line1 = LineSegment2d(Workplane1, Point3, Point4)
Line2 = LineSegment2d(Workplane1, Point5, Point6)&lt;/p&gt;
&lt;h1&gt;圓弧&lt;/h1&gt;
&lt;p&gt;Arc1 = ArcOfCircle(Workplane1, Normal1, Point1, Point3, Point5)
Constraint.diameter(R1&lt;em&gt;2, Workplane1, Arc1)
Arc2 = ArcOfCircle(Workplane1, Normal1, Point2, Point6, Point4)
Constraint.diameter(R2&lt;/em&gt;2, Workplane1, Arc2)&lt;/p&gt;
&lt;h1&gt;X軸Line0&lt;/h1&gt;
&lt;p&gt;Line0 = LineSegment2d(Workplane1, Point1, Point2)
Constraint.horizontal(Workplane1, Line0)&lt;/p&gt;
&lt;h1&gt;約束&lt;/h1&gt;
&lt;p&gt;Constraint.tangent(Arc1, Line1, False)
Constraint.tangent(Arc2, Line1, False)
Constraint.tangent(Arc2, Line2, True)
Constraint.distance(200.0, Workplane1, Point3, Point4)&lt;/p&gt;
&lt;h1&gt;以下解題&lt;/h1&gt;
&lt;p&gt;sys.solve()&lt;/p&gt;
&lt;p&gt;if (sys.result == SLVS_RESULT_OKAY):
    print ("兩點座標：")
    print(("(%.3f %.3f %.3f)")%(sys.get_param(7).val, sys.get_param(8).val, sys.get_param(2).val))
    print(("(%.3f %.3f %.3f)\n")%(sys.get_param(9).val, sys.get_param(10).val, sys.get_param(2).val))
    print ("上切點座標：")
    print(("(%.3f %.3f %.3f)")%(sys.get_param(11).val, sys.get_param(12).val, sys.get_param(2).val))
    print("(-10.770 56.570 0.000)")
    print(("(%.3f %.3f %.3f)")%(sys.get_param(13).val, sys.get_param(14).val, sys.get_param(2).val))
    print("(185.700 93.980 0.000)\n")
    print ("下切點座標：")
    print(("(%.3f %.3f %.3f)")%(sys.get_param(15).val, sys.get_param(16).val, sys.get_param(2).val))
    print("(-10.770 -56.570 0.000)")
    print(("(%.3f %.3f %.3f)")%(sys.get_param(17).val, sys.get_param(18).val, sys.get_param(2).val))
    print("(185.700 -93.98 0.000)\n")
    print ("導入函數測試：")
    print ("R1：")
    print(R1)
    print ("R2：")
    print(R2)
    print ("pi：")
    print(pi)
    print ("%d DOF" % sys.dof)
elif (sys.result == SLVS_RESULT_INCONSISTENT):
    print ("solve failed")
    print ("SLVS_RESULT_INCONSISTENT")
    print ("%d DOF" % sys.dof)
    for i in range(sys.faileds):
        print(" %lu", sys.failed[i]);
elif (sys.result == SLVS_RESULT_DIDNT_CONVERGE):
    print ("solve failed")
    print ("SLVS_RESULT_DIDNT_CONVERGE")
    print ("%d DOF" % sys.dof)
    for i in range(sys.faileds):
        print(" %lu", sys.failed[i]);
elif (sys.result == SLVS_RESULT_TOO_MANY_UNKNOWNS):
    print ("solve failed")
    print ("SLVS_RESULT_TOO_MANY_UNKNOWNS")
    print ("%d DOF" % sys.dof)
&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;弧與直線相切的函式只能鎖住一頭（布林值調整鎖住頭或尾），所以要下兩次。&lt;/p&gt;
&lt;p&gt;不過由於Solvespace對約束的要求十分嚴謹，所以只要下了衝突約束或是重複約束，前者會顯示&lt;code&gt;SLVS_RESULT_INCONSISTENT&lt;/code&gt;，後者會顯示&lt;code&gt;SLVS_RESULT_DIDNT_CONVERGE&lt;/code&gt;，就得重新檢查寫的程式。&lt;/p&gt;
&lt;p&gt;以下是圖解法比對（其實已經記錄在上面的程式中供比對），兩者使用的資料庫函式應該是一樣的。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/FWVqdhW.jpg" &gt;&lt;/p&gt;
&lt;p&gt;結果是零誤差。&lt;/p&gt;
&lt;p&gt;以下是SciTE的顯示結果，較上方的是Python運算的結果。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/iqkIH4L.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;使用這個函式庫非常簡單，跟在Solvespace上畫圖一樣。&lt;/p&gt;
&lt;p&gt;先設定起始值後，利用約束調整這些值（而且可以將固定值鎖住），確定之後就能算出答案。&lt;/p&gt;
&lt;p&gt;第一次使用自己寫的介面，由於以熟悉它們的從屬關係和解題公式，所以用起來十分上手。&lt;/p&gt;
&lt;p&gt;這個函式庫最大的缺點應該是取值不太方便吧，雖然仍可以使用自己命名或是直接內嵌進函式中，可是取值時是按照註冊順序取的，所以養成輸入值時給編號比較不容易亂掉。&lt;/p&gt;</summary><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/28</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050728.html" rel="alternate"></link><published>2016-07-28T19:00:00+08:00</published><updated>2016-07-28T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-28:blog/40323230ri-zhi-1050728.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;CDemo資料庫內容補正&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;未支援項目&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;＊某些項目未紀錄於DOC.exe中&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;SLVS_C_PT_FACE_DISTANCE
SLVS_C_PT_ON_FACE
SLVS_C_LENGTH_RATIO
SLVS_C_EQ_LEN_PT_LINE_D
SLVS_C_EQ_PT_LN_DISTANCES
SLVS_C_EQUAL_ANGLE
SLVS_C_EQUAL_LINE_ARC_LEN
SLVS_C_SYMMETRIC
SLVS_C_SYMMETRIC_HORIZ
SLVS_C_SYMMETRIC_VERT
SLVS_C_SYMMETRIC_LINE
SLVS_C_AT_MIDPOINT
SLVS_C_SAME_ORIENTATION
SLVS_C_ANGLE
SLVS_C_PARALLEL
SLVS_C_PERPENDICULAR
SLVS_C_ARC_LINE_TANGENT
SLVS_C_CUBIC_LINE_TANGENT
SLVS_C_PROJ_PT_DISTANCE
SLVS_C_WHERE_DRAGGED
SLVS_C_CURVE_CURVE_TANGENT
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;今天編譯完&lt;code&gt;slvs_python.hpp&lt;/code&gt;，並推送至倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;因為大部分都是強硬約束的關係，只測試過部分功能。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;編譯流程&lt;/h1&gt;
&lt;p&gt;使用Netbeans編譯&lt;code&gt;slvs_python.hpp&lt;/code&gt;和&lt;code&gt;slvs.i&lt;/code&gt;，旁邊的&lt;code&gt;constrainteq.cpp&lt;/code&gt;供參考函式。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/zjppe0U.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;&lt;em&gt;slvs.i&lt;/em&gt;&lt;/h2&gt;
&lt;pre class="brush: c"&gt;
class Constraint {
    Constraint();
public:
...
    static Constraint some_other_constraint(
            System* system,
            int type, Workplane workplane, double value,
            Point ptA, Point ptB, Entity entityA, Entity entityB,
            Slvs_hGroup group = USE_DEFAULT_GROUP);
&lt;/pre&gt;

&lt;p&gt;標準的約束條件格式如上，其實所有的約束函式都是透過&lt;code&gt;slvs_python.hpp&lt;/code&gt;輸入&lt;code&gt;constrainteq.cpp&lt;/code&gt;的約束做計算。&lt;/p&gt;
&lt;h2&gt;&lt;em&gt;slvs_python.hpp&lt;/em&gt;&lt;/h2&gt;
&lt;pre class="brush: c"&gt;
class Constraint {
...
public:
static Constraint some_other_constraint(
            System* system,
            int type, Workplane workplane, double value,
            Point ptA, Point ptB, Entity entityA, Entity entityB,
            Slvs_hGroup group = USE_DEFAULT_GROUP) {
        return init(system, Slvs_MakeConstraint(
            0, group,
            type,
            workplane.handle(),
            value,
            ptA.handle(), ptB.handle(),
            entityA.handle(), entityB.handle()));
    }
...
&lt;/pre&gt;

&lt;p&gt;但是由於約束&lt;code&gt;SLVS_C_EQUAL_ANGLE&lt;/code&gt;會用到四個Entity，預設只有開啟2個，另外的&lt;code&gt;EntityC&lt;/code&gt;、&lt;code&gt;EntityD&lt;/code&gt;沒有開啟，而相切約束需要的布林值&lt;code&gt;other&lt;/code&gt;和&lt;code&gt;other2&lt;/code&gt;亦沒有加入。&lt;/p&gt;
&lt;p&gt;所以只能從&lt;code&gt;slvs.h&lt;/code&gt;添加這4個值。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/cV0HyKc.jpg" &gt;&lt;/p&gt;
&lt;p&gt;其他項目也要加上4個空位，以免出錯。&lt;/p&gt;
&lt;p&gt;對照&lt;code&gt;constrainteq.cpp&lt;/code&gt;中需要的項目，在&lt;code&gt;slvs_python.hpp&lt;/code&gt;中填上需要的值的類型，應該就可以運作了。&lt;/p&gt;
&lt;p&gt;測試了一些新加入的約束，如果&lt;code&gt;slvs_python.hpp&lt;/code&gt;中填上的類型正確，就會解題，不過「重複約束」的結果似乎是歸類在「過度約束」裡。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Ej4JQHF.jpg" &gt;&lt;/p&gt;
&lt;p&gt;而如果本身類型填錯，就會回傳錯誤碼&lt;code&gt;-1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/n3iIuhW.jpg" &gt;&lt;/p&gt;
&lt;p&gt;但是函式庫中只有&lt;code&gt;SLVS_C_WHERE_DRAGGED&lt;/code&gt;會抓住點（而且還是有移動量），還要研究一下如何鎖住這些點的位置。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;今天幫忙編寫CDemo，使其擁有Solvespace全部約束的功能。&lt;/p&gt;
&lt;p&gt;會找時間翻修一下之前的紀錄。&lt;/p&gt;</summary><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/27</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050727.html" rel="alternate"></link><published>2016-07-27T19:00:00+08:00</published><updated>2016-07-27T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-27:blog/40323230ri-zhi-1050727.html</id><summary type="html">&lt;p&gt;規劃解題與檢驗函式&lt;/p&gt;
&lt;p&gt;&lt;em&gt;檢驗出功能缺損&lt;/em&gt;&lt;/p&gt;


&lt;h2&gt;規劃解題 :&lt;/h2&gt;

&lt;p&gt;計算題目，並一邊利用SciTE的偵錯窗來檢查之前寫的函式資料。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/tfgUIVX.jpg" &gt;&lt;/p&gt;
&lt;p&gt;之前的題目：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://chiamingyen.github.io/kmolab/blog/zi-xing-che-chuan-dong-2d-lian-tiao-hui-tu-er.html" title="chiamingyen.gi鏈hub.io"&gt;http://chiamingyen.github.io/kmolab/blog/zi-xing-che-chuan-dong-2d-lian-tiao-hui-tu-er.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;規劃了一支程式來計算鍊輪的點座標（半成品）：&lt;/p&gt;
&lt;p&gt;&lt;pre鏈class="brush: python"&gt;&lt;/p&gt;
&lt;h1&gt;鍊條解題：18齒與30齒的鏈條，上下外切線長為200。&lt;/h1&gt;
&lt;h1&gt;小圓圓心為原點，大圓圓心在X軸上，求四個切點的座標&lt;/h1&gt;
&lt;p&gt;from slvs import &lt;em&gt;
from math import &lt;/em&gt;
sys = Syst鏈m(500)
g = 1&lt;/p&gt;
&lt;h1&gt;相關參數&lt;/h1&gt;
&lt;p&gt;n0 = 20 #鍊條長度(mm)
n1 = 18 #小輪齒數(t)
n2 = 30 #大輪齒數(t)&lt;/p&gt;
&lt;h1&gt;邊長為a的的正n邊形外接圓半徑為：&lt;/h1&gt;
&lt;h1&gt;R=a/(2&lt;em&gt;sin(pi/n)) or R=(a/2)&lt;/em&gt;csc(pi/n)&lt;/h1&gt;
&lt;p&gt;R1 = n0/(2&lt;em&gt;sin(pi/n1))
R2 = n0/(2&lt;/em&gt;sin(pi/n2))&lt;/p&gt;
&lt;h1&gt;開始繪圖&lt;/h1&gt;
&lt;h1&gt;原點Point0&lt;/h1&gt;
&lt;p&gt;p0 = sys.add_param(0.0)
p1 = sys.add_param(0.0)
p2 = sys.add_param(0.0)
Point0 = Point3d(p0, p1, p2)&lt;/p&gt;
&lt;h1&gt;XY法線&lt;/h1&gt;
&lt;p&gt;qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0)
p3 = sys.add_param(qw)
p4 = sys.add_param(qx)
p5 = sys.add_param(qy)
p6 = sys.add_param(qz)
Normal1 = Normal3d(p3, p4, p5, p6, sys)&lt;/p&gt;
&lt;h1&gt;工作平面&lt;/h1&gt;
&lt;p&gt;Workplane1 = Workplane(Point0, Normal1)&lt;/p&gt;
&lt;h1&gt;3D版的Point0=&amp;gt;Point1&lt;/h1&gt;
&lt;p&gt;Point1 = Point2d(Workplane1, p0, p1)&lt;/p&gt;
&lt;h1&gt;小圓&lt;/h1&gt;
&lt;p&gt;p7 = sys.add_param(R1)
Distance1 = Distance(Workplane1, p7)
Circle1 = Circle(Workplane1, Normal1, Point1, Distance1)&lt;/p&gt;
&lt;h1&gt;Point2&lt;/h1&gt;
&lt;p&gt;p8 = sys.add_param(500.0)
p9 = sys.add_param(0.0)
Point2 = Point2d(Workplane1, p7, p8)&lt;/p&gt;
&lt;h1&gt;大圓&lt;/h1&gt;
&lt;p&gt;p10 = sys.add_param(R2)
Distance2 = Distance(Workplane1, p10)
Circle2 = Circle(Workplane1, Normal1, Point2, Distance2)&lt;/p&gt;
&lt;h1&gt;上端外切線的兩個點Point3和Point4&lt;/h1&gt;
&lt;p&gt;p11 = sys.add_param(300.0)
p12 = sys.add_param(500.0)
Point3 = Point2d(Workplane1, p11, p12)
p13 = sys.add_param(500.0)
p14 = sys.add_param(500.0)
Point4 = Point2d(Workplane1, p13, p14)&lt;/p&gt;
&lt;h1&gt;下端外切線的兩個點Point5和Point6&lt;/h1&gt;
&lt;p&gt;p15 = sys.add_param(300.0)
p16 = sys.add_param(-500.0)
Point5 = Point2d(Workplane1, p15, p16)
p17 = sys.add_param(500.0)
p18 = sys.add_param(-500.0)
Point6 = Point2d(Workplane1, p17, p18)&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;h1&gt;以下解題&lt;/h1&gt;
&lt;p&gt;sys.solve()&lt;/p&gt;
&lt;p&gt;if (sys.result == SLVS_RESULT_OKAY):
    print ("兩點座標：")
    print(("(%.3f %.3f %.3f)")%(sys.get_param(0).val, sys.get_param(1).val, sys.get_param(2).val))
    print(("(%.3f %.3f %.3f)\n")%(sys.get_param(8).val, sys.get_param(9).val, sys.get_param(2).val))
    print ("上切點座標：")
    print(("(%.3f %.3f %.3f)")%(sys.get_param(11).val, sys.get_param(12).val, sys.get_param(2).val))
    print(("(%.3f %.3f %.3f)\n")%(sys.get_param(13).val, sys.get_param(14).val, sys.get_param(2).val))
    print ("下切點座標：")
    print(("(%.3f %.3f %.3f)")%(sys.get_param(15).val, sys.get_param(16).val, sys.get_param(2).val))
    print(("(%.3f %.3f %.3f)\n")%(sys.get_param(17).val, sys.get_param(18).val, sys.get_param(2).val))
    print ("導入函數測試：")
    print(pi)
    print ("%d DOF" % sys.dof)
else:
    print ("solve failed")
&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;但是在使用畫線並約束與圓相切的指令時，之前臆測的程式碼卻沒有這個功能，於是去倉儲搜尋函式名稱。&lt;/p&gt;
&lt;p&gt;發現某些Solvespace的功能並沒有轉給CDemo使用，之前&lt;code&gt;DOC.txt&lt;/code&gt;簡介只是說明出本體支援的功能。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;在&lt;code&gt;h++&lt;/code&gt;的標頭檔&lt;code&gt;slvs_python.hpp&lt;/code&gt;中，有以下項目：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
class Constraint {
...
public:
    // This constructor can be used to make arbitrary
    // constraints. It has a very ugly name to discourage
    // its use. If you need a constraint that the library
    // doesn't support, you should implement it.
//以下是所有約束函式
...
&lt;/pre&gt;

&lt;p&gt;而那些沒做出的功能都用註解的方式放在這些做好的函式之間，所以看來好像是要自己做了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/3x4fBiB.jpg" &gt;&lt;/p&gt;
&lt;p&gt;目前瞭解需要編寫的檔案為&lt;code&gt;slvs.i&lt;/code&gt;的Interface檔、&lt;code&gt;slvs_python.hpp&lt;/code&gt;標頭檔、&lt;code&gt;constrainteq.cpp&lt;/code&gt;約束方程式的函式。&lt;/p&gt;
&lt;p&gt;畢竟是用別人寫好的架構，自己修改應該沒甚麼太大的障礙，以一個Python模組而言，拓展所需才是協同作業重要之處。&lt;/p&gt;</summary><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>40323231日誌 - 105/07/25</title><link href="http://project.mde.tw/blog/40323231ri-zhi-1050725.html" rel="alternate"></link><published>2016-07-25T21:00:00+08:00</published><updated>2016-07-25T21:00:00+08:00</updated><author><name>40323231</name></author><id>tag:project.mde.tw,2016-07-25:blog/40323231ri-zhi-1050725.html</id><summary type="html">&lt;p&gt;3DP問題、測試、解決方法&lt;/p&gt;


&lt;h3&gt;固件組裝時的問題 : &lt;/h3&gt;

&lt;h4&gt;1.熱床的安裝較不容易，因為它是暗孔所以比較難對齊，鎖固的時間較長，之後有要組一台的話要考慮是否改換成明孔&lt;/h4&gt;

&lt;p&gt;&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;配電的問題 : &lt;/h3&gt;
&lt;h4&gt;1.限位開關的接法，因為限位開關有分兩種，一種是機械式微動開關，一種是光學限位開關，要怎麼接?
接法和注意事項:&lt;/h4&gt;
&lt;h4&gt;  a. 機械微動開關接法
機械微動開關只需接2個腳位的：單純使用微動開關當作限位器，那一定要接RAMPS上的 "S" 跟 "-" 腳位。絕對不要把3個腳位都接了，如果不小心接了3個腳位，那在觸發時會發生火花，會把5V穩壓 IC燒毀。&lt;/h4&gt;
&lt;h4&gt;  b. 光學限位開關接法(我們的)
光學限位開關則是需要用到3條線，接到RAMPS上的"S"、"-"及"+" 3個腳位。&lt;/h4&gt;
&lt;h4&gt;  c.程式碼也需要改(由於我們的是光學限位所以都改成false)&lt;/h4&gt;
&lt;h4&gt;const bool X_MIN_ENDSTOP_INVERTING = false;&lt;/h4&gt;
&lt;h4&gt;const bool Y_MIN_ENDSTOP_INVERTING = false;&lt;/h4&gt;
&lt;h4&gt;const bool Z_MIN_ENDSTOP_INVERTING = false;&lt;/h4&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;測機問題 : &lt;/h3&gt;
&lt;h4&gt;1.用arduino燒入韌體時會說缺少東西，這時用(u8glib_arduino_v1.16)壓縮檔即可。&lt;/h4&gt;
&lt;h4&gt;操作方法是 : &lt;/h4&gt;
&lt;h4&gt;     a.先到網站下載u8glib_arduino_v1.16這包壓縮檔&lt;/h4&gt;
&lt;h4&gt;     b.點開arduino&lt;/h4&gt;
&lt;h4&gt;     c.點選Sketch  &lt;/h4&gt;
&lt;h4&gt;     d.點選Include Library &lt;/h4&gt;
&lt;h4&gt;     e.點選Add .ZIP Library...&lt;/h4&gt;
&lt;h4&gt;     f.選擇u8glib_arduino_v1.16&lt;/h4&gt;
&lt;h4&gt;     g.完成&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;2.擠出馬達不能運作,其他xyz馬達皆能動&lt;/h4&gt;
&lt;h4&gt;測試方法:&lt;/h4&gt;
&lt;h4&gt;    a.將擠出馬達的訊號線接到X軸的訊號端(馬達是否正常)，測試馬達正常&lt;/h4&gt;
&lt;h4&gt;    b.將擠出軸的訊號線由E0接到E1(測試控制板和韌體是否正常)，測試結果無法作動&lt;/h4&gt;
&lt;h4&gt;    c.將電源線和擠出訊號線接到ramps1.4和arduino上(測試控制板是否正常)，測試結果無法作動&lt;/h4&gt;
&lt;h4&gt;解決方法:因為程式碼中有保護措施，保護措施為噴頭溫度要先加熱到指定的溫度後才能啟動，怕擠料不正常。可修改此程式碼define MIN_EXTRUDER_TEMP 170&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;3.馬達旋轉方向不符&lt;/h4&gt;
&lt;h4&gt;解決方法:調整程式碼&lt;/h4&gt;
&lt;h4&gt;Repetier(0、1為正反轉)&lt;/h4&gt;
&lt;h4&gt;#define INVERT_X_DIR 0&lt;/h4&gt;
&lt;h4&gt;#define INVERT_Y_DIR 0&lt;/h4&gt;
&lt;h4&gt;#define INVERT_Z_DIR 0&lt;/h4&gt;
&lt;h4&gt;#define EXT0_INVERSE 0&lt;/h4&gt;
&lt;h4&gt;Marlin(true、false為正反轉)&lt;/h4&gt;
&lt;h4&gt;#define INVERT_X_DIR true&lt;/h4&gt;
&lt;h4&gt;#define INVERT_Y_DIR true&lt;/h4&gt;
&lt;h4&gt;#define INVERT_Z_DIR true&lt;/h4&gt;
&lt;h4&gt;#define INVERT_E0_DIR true&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;4.G28回歸的時候，Z軸不動其他兩軸馬達回歸，導致噴頭座往外跑出&lt;/h4&gt;
&lt;h4&gt;測試方法 : &lt;/h4&gt;
&lt;h4&gt;    a.打指令M119檢查限位開關是否有開，測試結果有開&lt;/h4&gt;
&lt;h4&gt;    b.用手讓限位器偵測是否會感應，測試結果有感應&lt;/h4&gt;
&lt;h4&gt;    c.檢查程式碼true/false是否正確，正確(有說明此功能的一篇)&lt;/h4&gt;
&lt;h4&gt;解決方法:更換新的杜邦端子，因為測量多次後發現時好時壞，所以猜測是訊號接收不正常，更換後能夠順利回歸&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;5.軟體關掉訊號後滑軌依然鎖住&lt;/h4&gt;
&lt;h4&gt;解決方法:關掉訊號後再連接(connect)，之後再斷掉，就可以解鎖了&lt;/h4&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;使用韌體Repetier所碰到的問題 : &lt;/h3&gt;
&lt;h4&gt;1.噴嘴高度不管怎麼改都是319.2mm不知道為什麼?&lt;/h4&gt;
&lt;h4&gt;解決方法(還未真正找到解決方法)&lt;/h4&gt;
&lt;h4&gt;    a.修改程式碼中噴頭最大高度，可是不管怎麼改依然都是319.2mm&lt;/h4&gt;
&lt;h4&gt;    b.修改程式碼中噴頭最小高度，可是依然319.2mm&lt;/h4&gt;
&lt;h4&gt;    c.修改3軸的補正值，依然不變&lt;/h4&gt;
&lt;h4&gt;    d.修改xyz軸的最大值，發現xyz軸會超出設定的最大值，發現好像是code燒不進去，而且有看到RAM大小所以猜測是空間不足&lt;/h4&gt;
&lt;h4&gt;    e.將空白的arduino燒進控制板後，機器不能運轉表示燒入成功，之後再把修改過的韌體在燒進去，可是依然還是319.2mm&lt;/h4&gt;
&lt;h4&gt;    f.用軟體Repetier-Host直接修改高度，可是一樣還是319.2mm&lt;/h4&gt;
&lt;h4&gt;    g.改用韌體Marlin，可是Marlin卻有更多的不穩定&lt;/h4&gt;
&lt;h4&gt;    h.用Cura_15.04特別版，才成功修改，並能順利列印&lt;/h4&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;使用韌體Marlin所碰到的問題 : &lt;/h3&gt;
&lt;h4&gt;1.G28回歸後，只能單軸單軸進行復歸補正，導致速度較慢，而且有時候複歸的途中會停下來，之後單軸複歸導致噴頭座跑出機台外。(備註:機台斷電後，軟體也要切斷訊號，不然機台重新開電後還是會繼續執行)&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;2.執行G28時個軸的速度，寫法與Repetier不太一樣，所以一開始沒注意到，導致速度過快差點撞機。&lt;/h4&gt;
&lt;h4&gt;#define HOMING_FEEDRATE {50&lt;em&gt;60, 50&lt;/em&gt;60, 50*60, 0}&lt;/h4&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;列印時碰到的問題 : &lt;h3&gt;
&lt;h4&gt;1.翹邊&lt;/h4&gt;
&lt;h4&gt;解決方法:塗口紅膠在平台上，以及再加熱期間把溢出來的料弄掉，因為溢出來的料會把底層弄掀，導致沒有地基、材料高低不平&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;2.列印出來的東西很稀疏，而且一捏就碎&lt;/h4&gt;
&lt;h4&gt;解決方法:&lt;/h4&gt;
&lt;h4&gt;a.先加熱，之後用細的鐵絲或夾子將堵塞住的料全部清除(清理時要注意不要直接觸摸噴頭組，請用工具夾持，夾持時勿將熱敏電阻和加熱棒弄壞)，清完後用鐵氟龍管測試深度(避免之後再裝鐵氟龍管時無法到達最深部，導致又回流堵料)&lt;/h4&gt;
&lt;h4&gt;b.如果上述不行，再清理噴頭，或直接更換，我是清理完喉管後還是不行，直接更換噴頭，之後就改善了&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;3.擠出馬達持續轉動，料則是斷斷續續的進料，有時甚至完全停止&lt;/h4&gt;
&lt;h4&gt;解決方法:&lt;/h4&gt;
&lt;h4&gt;a.進入軟體(cura)的基本 -&amp;gt; 列印材料(Filament) -&amp;gt; 流量(Flow)(%) -&amp;gt;更改此數值(擠料速度會降低)&lt;/h4&gt;
&lt;h4&gt;b.還是未改善請依循:列印時碰到的問題2進行改善&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;4.列印時噴頭和熱床無法同時加熱&lt;/h4&gt;
&lt;h4&gt;還未解決&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;5.噴頭液料(部位有噴頭、喉管的鎖固部分)&lt;/h4&gt;
&lt;h4&gt;解決方法:重新鎖固，或者鎖緊即可&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;6.口紅膠的殘留，以及要拿下產品時要用刮刀拆下，導致平板會有刮傷&lt;/h4&gt;
&lt;h4&gt;還未解決，有看到網路上有人是購買專用的膠帶，不知道實不實用&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;7.馬達很燙&lt;/h4&gt;
&lt;h4&gt;還未解決，有想要在熱床下加裝風扇&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;8.如何放置料桶&lt;/h4&gt;
&lt;h4&gt;還未解決，想要製作料座，然後用軸承放置兩邊讓他能順利進料&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;持續更新&lt;/h4&gt;&lt;/p&gt;</summary><category term="3DP"></category></entry><entry><title>40323230紀錄 - Python-Solvespace編譯完畢</title><link href="http://project.mde.tw/blog/40323230ji-lu-python-solvespacebian-yi-wan-bi.html" rel="alternate"></link><published>2016-07-24T19:00:00+08:00</published><updated>2016-07-24T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-24:blog/40323230ji-lu-python-solvespacebian-yi-wan-bi.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Windows執行成功！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ubuntu執行失敗（需重生&lt;code&gt;_slvs.so&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;公開倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;編譯結果 :&lt;/h2&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/E4PEUbR.jpg" &gt;&lt;/p&gt;
&lt;p&gt;最後編譯時把&lt;code&gt;_slvs.so&lt;/code&gt;改成了&lt;code&gt;_slvs.pyd&lt;/code&gt;就能使用了。&lt;/p&gt;
&lt;p&gt;有測試過改成&lt;code&gt;.dll&lt;/code&gt;的方式，但是反而不能使用，可能是Windows平台Python辨認的問題。&lt;/p&gt;
&lt;p&gt;不過由於&lt;code&gt;_slvs.pyd&lt;/code&gt;是參照&lt;code&gt;libslvs.so&lt;/code&gt;的內容生成的，所以這四個檔案必須放在同一個資料夾：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;solvespace/exposed/_slvs.pyd
solvespace/exposed/libslvs.so
solvespace/exposed/slvs.py
solvespace/exposed/Usage.py
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;倉儲的Readme也做了一下說明。&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;test.py&lt;/code&gt;執行結果中，偵測到&lt;code&gt;long&lt;/code&gt;還沒定義，所以資料庫還需要修理一下。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Ejc5KDo.jpg" &gt;&lt;/p&gt;
&lt;p&gt;搬到新電腦虛擬機的Ubuntu上測試時，使用的是&lt;code&gt;_slvs.so&lt;/code&gt;的樣式。&lt;/p&gt;
&lt;p&gt;會顯示ELF標頭檔錯誤，而無法執行，應該是因為在Windows上生成的關係，重新在Ubuntu上編譯應該就行了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/jolKcHW.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;另外在新電腦虛擬機的Ubuntu上裝了一下Git、Netbeans和GNU工具包，可以正常運作，不過可能是跨系統模擬的關係，反應還滿慢的。&lt;/p&gt;
&lt;p&gt;然後Python3不知道怎麼更新，一直在3.4.2沒辦法升上去。&lt;/p&gt;</summary><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>40323218日誌 - 105/07/23</title><link href="http://project.mde.tw/blog/40323218ri-zhi-1050723.html" rel="alternate"></link><published>2016-07-23T20:37:00+08:00</published><updated>2016-07-23T20:37:00+08:00</updated><author><name>40323218</name></author><id>tag:project.mde.tw,2016-07-23:blog/40323218ri-zhi-1050723.html</id><summary type="html">&lt;p&gt;V-rep   printer_control&lt;/p&gt;


&lt;h2&gt;嘗試組裝3Dprinter&lt;/h2&gt;

&lt;p&gt;&lt;br&gt;
&lt;h3&gt;現在已嘗試兩種方式操控&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;分別是：&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/g2_files/40323218/Printer_position_control.ttt?raw=true"&gt;Printer_position_control.ttt&lt;/a&gt;&lt;/p&gt;&lt;br&gt;
&lt;h3&gt;可以操控position(需用滑鼠移動)&lt;/h3&gt;&lt;br&gt;&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/position.gif" weight=600 &gt;
&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/g2_files/40323218/Printer_motor_control.ttt?raw=true"&gt;Printer_motor_control.ttt&lt;/a&gt;&lt;/p&gt;&lt;br&gt;
&lt;h3&gt;可以操控motor(需用參數移動)&lt;/h3&gt;
&lt;br&gt;&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/motor.gif" weight=600 &gt;
&lt;br&gt;&lt;br&gt;
&lt;h3&gt;串列通訊：&lt;/h3&gt;
&lt;br&gt;
&lt;iframe width="854" height="480" src="https://www.youtube.com/embed/1-CW00QXwwk" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;br&gt;
&lt;iframe width="854" height="480" src="https://www.youtube.com/embed/y1vbxmeJ4M0" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323230紀錄 - C語言資料庫格式</title><link href="http://project.mde.tw/blog/40323230ji-lu-cyu-yan-zi-liao-ku-ge-shi.html" rel="alternate"></link><published>2016-07-23T19:00:00+08:00</published><updated>2016-07-23T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-23:blog/40323230ji-lu-cyu-yan-zi-liao-ku-ge-shi.html</id><summary type="html">&lt;p&gt;關於各平台程式使用之連結庫類型。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Static libraries&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Shared libraries&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dynamically loaded libraries&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;參考資料來源：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://terrycslife.blogspot.tw/2010/07/so.html" title="terrycslife.blogspot.tw"&gt;http://terrycslife.blogspot.tw/2010/07/so.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://kaineshu.wordpress.com/2007/05/02/%E8%BD%89%E8%B2%BC%E7%94%A8gcc-%E8%87%AA%E8%A3%BD-library/" title="kaineshu.wordpress.com"&gt;https://kaineshu.wordpress.com/2007/05/02/%E8%BD%89%E8%B2%BC%E7%94%A8gcc-%E8%87%AA%E8%A3%BD-library/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://www.jianshu.com/p/09994c9d8489" title="jianshu.com"&gt;http://www.jianshu.com/p/09994c9d8489&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Object File :&lt;/h2&gt;

&lt;p&gt;通常副檔名為&lt;code&gt;.o&lt;/code&gt;或是&lt;code&gt;.obj&lt;/code&gt;，後者為Windows使用的格式。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/zpxnXLj.jpg" &gt;&lt;/p&gt;
&lt;p&gt;將&lt;code&gt;.c&lt;/code&gt;或&lt;code&gt;.cpp&lt;/code&gt;、&lt;code&gt;.cxx&lt;/code&gt;的C語言程式碼包裝成的物件檔，無法直接使用。&lt;/p&gt;
&lt;p&gt;使用編譯工具的"Link"功能可以將這些單獨的物件檔合併成連結庫或是可執行檔。&lt;/p&gt;
&lt;h2&gt;Static libraries - 靜態資料庫 :&lt;/h2&gt;

&lt;p&gt;通常副檔名為&lt;code&gt;.a&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;作用方式：將連結庫包入程式中執行，處理效率高，缺點是檔案大且不易更新。&lt;/p&gt;
&lt;p&gt;若要建立一個靜態資料庫，可以使用DllTool從&lt;code&gt;.dll&lt;/code&gt;檔解出或是用GNU的&lt;code&gt;ar&lt;/code&gt;工具連結物件檔編譯。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ar&lt;/code&gt;的指令中，&lt;code&gt;rcs&lt;/code&gt;或是&lt;code&gt;-r&lt;/code&gt;後接上輸出的檔案名稱，如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ar rcs libmylib.a first.o second.o&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;產生靜態資料庫後，可以使用gcc的&lt;code&gt;-L&lt;/code&gt;和&lt;code&gt;-l&lt;/code&gt;指令連結，對象包含程式碼、物件檔和其他靜態資料庫。&lt;/p&gt;
&lt;h2&gt;Shared libraries - 共用資料庫 :&lt;/h2&gt;

&lt;p&gt;通常副檔名為&lt;code&gt;.so&lt;/code&gt;，後面可加掛版本編號。&lt;/p&gt;
&lt;p&gt;作用方式：資料庫和執行檔是分離的，剛開始就要載入，並且資料庫必須一直和執行檔待在一起，優點是修改方便。&lt;/p&gt;
&lt;p&gt;gcc在產生物件檔時必須加上&lt;code&gt;-fPIC&lt;/code&gt;參數，紀錄"position-independent code"，就是獨立位置碼，以紀錄存取位置的資訊。沒有使用的話只會用相對位置，不利於共享內容。&lt;/p&gt;
&lt;p&gt;再來將物件檔合併成資料庫時，加上&lt;code&gt;-shared&lt;/code&gt;參數，接著要自訂義"soname"、"real name"、"linker name"。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;soname是資料庫的名稱，通常以&lt;code&gt;lib&lt;/code&gt;開頭，包含附檔名和大版號，如&lt;code&gt;libexample.so.1&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;real name是真正使用程式的資料庫名稱，包含小版號，如&lt;code&gt;libexample.so.1.0.0&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;linker name是連結時的資料庫名稱，不包含版號，如&lt;code&gt;libexample.so&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;gcc使用&lt;code&gt;-Wl&lt;/code&gt;參數向內建的Link工具"ln"傳入資訊，如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gcc -shared -Wl,-soname,libexample.so.1 -o libexample.so.1.0.0 first.o second.o&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;-Wl,-soname&lt;/code&gt;定義soname；輸出的檔案名稱為real name；使用&lt;code&gt;-l&lt;/code&gt;或&lt;code&gt;-l:&lt;/code&gt;連結的名稱為linker name。&lt;/p&gt;
&lt;p&gt;尋找了下&lt;a href="https://en.wikipedia.org/wiki/Soname" title="https://en.wikipedia.org/wiki/Soname"&gt;維基百科&lt;/a&gt;，似乎也能使用&lt;code&gt;-h&lt;/code&gt;和&lt;code&gt;-soname=&lt;/code&gt;來定義soname的名稱。&lt;/p&gt;
&lt;p&gt;資料庫連結時使用&lt;code&gt;ln&lt;/code&gt;指令連結兩個&lt;code&gt;.so&lt;/code&gt;檔。使用&lt;code&gt;-s&lt;/code&gt;參數為軟連結，類似捷徑式的參照；使用&lt;code&gt;-d&lt;/code&gt;參數為硬連結，類似副本的備份。&lt;/p&gt;
&lt;p&gt;最後必須用以下指令為real name創造linker name和soname的檔案（使用&lt;code&gt;-s&lt;/code&gt;或&lt;code&gt;-d&lt;/code&gt;就隨喜好了）。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;linker name&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ln -s libexample.so.1.0.0 libexample.so&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;soname&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ln -s libexample.so.1.0.0 libexample.so.1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;之後可以用GNU的另一個工具"objdump"檢查連結。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;objdump -p libexample.so.1.3 | grep SONAME&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;產生共用資料庫後，可以像靜態資料庫一樣包裝，也可以用程式呼叫。&lt;/p&gt;
&lt;p&gt;連結時有同名資料庫時會以共用資料庫優先，加上&lt;code&gt;-static&lt;/code&gt;參數可以指定靜態資料庫。&lt;/p&gt;
&lt;p&gt;而調用資料庫時是先找soname的檔案，否則會尋找linker name的檔案，可執行檔亦同。&lt;/p&gt;
&lt;h2&gt;Dynamically loaded libraries - 動態載入庫 :&lt;/h2&gt;

&lt;p&gt;為Windows中&lt;code&gt;.dll&lt;/code&gt;檔標準的模式，不過並非所有&lt;code&gt;.dll&lt;/code&gt;都是如此。&lt;/p&gt;
&lt;p&gt;作用方式：使用時才會載入，編譯時不須要相關資料庫檔案，因此常用於附加元件。&lt;/p&gt;
&lt;p&gt;使用一套DLL function來處理，標頭檔和編譯的程式碼中都會使用來傳遞訊息。&lt;/p&gt;
&lt;p&gt;gcc編譯時要加上&lt;code&gt;-ldl&lt;/code&gt;參數連結。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;後來發現gcc有時編譯「成功」的樣子可能包含著錯誤。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Pk6DJDw.jpg" &gt;&lt;/p&gt;
&lt;p&gt;今天測試了一些方法，但是明明CDemo和Python的&lt;code&gt;.so&lt;/code&gt;都是差不多的參數，編譯出的結果卻不如預期。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;libslvs.so&lt;/em&gt;&lt;/p&gt;
&lt;pre class="brush: c"&gt;
g++ -shared -o libslvs.so ../obj/util.obj ... ../obj/w32util.obj
&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;_slvs.so&lt;/em&gt;&lt;/p&gt;
&lt;pre class="brush: c"&gt;
g++ -shared -o _slvs.so ../obj/util.obj ... ../obj/slvs_wrap.o -LW:/Anaconda3/libs -lPython35 -L. -l:libslvs.so
&lt;/pre&gt;

&lt;p&gt;如果編譯&lt;code&gt;_slvs.so&lt;/code&gt;時不加上後面的&lt;code&gt;-LW:/Anaconda3/libs&lt;/code&gt;、&lt;code&gt;-lPython35&lt;/code&gt;等等就會因為&lt;code&gt;slvs_wrap.o&lt;/code&gt;的&lt;code&gt;slvs_wrap.cxx&lt;/code&gt;出問題，但是沒加上就和&lt;code&gt;libslvs.so&lt;/code&gt;一樣了。&lt;/p&gt;
&lt;p&gt;但是這樣另一個問題就產生了，因為編出來的&lt;code&gt;_slvs.so&lt;/code&gt;是「可執行檔」，不指定&lt;code&gt;-o _slvs.so&lt;/code&gt;的話就會編譯成&lt;code&gt;a.exe&lt;/code&gt;，所以其他Python程式碼都找不到（有搬到虛擬機的Ubuntu測試，也找不到）。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/A9ITgDd.jpg" &gt;&lt;/p&gt;
&lt;p&gt;想過學範例用&lt;code&gt;.c&lt;/code&gt;跳過Object File的階段直接轉成&lt;code&gt;.so&lt;/code&gt;檔，但是只有&lt;code&gt;libslvs.so&lt;/code&gt;成功，&lt;code&gt;_slvs.so&lt;/code&gt;反而在系統暫存檔Temp資料夾中找不到Python連結。&lt;/p&gt;
&lt;p&gt;之後稍微看了一下SWIG轉出的&lt;code&gt;slvs.py&lt;/code&gt;結構，呼叫的&lt;code&gt;.py&lt;/code&gt;檔必須先導入&lt;code&gt;slvs.py&lt;/code&gt;後，&lt;code&gt;slvs.py&lt;/code&gt;會視Python版本取用&lt;code&gt;_slvs.so&lt;/code&gt;的內容，再傳給需要的&lt;code&gt;.py&lt;/code&gt;檔，所以&lt;code&gt;slvs.py&lt;/code&gt;和&lt;code&gt;_slvs.so&lt;/code&gt;都必須和撰寫的&lt;code&gt;.py&lt;/code&gt;檔放在一起。&lt;/p&gt;</summary><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/22</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050722.html" rel="alternate"></link><published>2016-07-22T19:00:00+08:00</published><updated>2016-07-22T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-22:blog/40323230ri-zhi-1050722.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Python-Solvespace編譯完畢。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;進行&lt;code&gt;_slvs.so&lt;/code&gt;呼叫測試。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;公開倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已推送。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;編譯成功 :&lt;/h2&gt;

&lt;p&gt;上次編譯時一直找不到&lt;code&gt;Slvs_&lt;/code&gt;相關名稱的問題。&lt;/p&gt;
&lt;p&gt;最後發現編譯&lt;code&gt;_slvs.so&lt;/code&gt;時加入參照&lt;code&gt;libslvs.so&lt;/code&gt;資料庫的指令（&lt;code&gt;-L&lt;/code&gt;和&lt;code&gt;-l&lt;/code&gt;），就成功編譯了。&lt;/p&gt;
&lt;p&gt;結束編譯時，Makefile執行了CDemo.exe證明C語言調用&lt;code&gt;libslvs.so&lt;/code&gt;是完全沒問題的。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/M7G0AH3.jpg" &gt;&lt;/p&gt;
&lt;p&gt;接著要試著執行Python調用&lt;code&gt;_slvs.so&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;測試test.py和Usage.py :&lt;/h2&gt;

&lt;p&gt;作者提供了2個範例使用，將它們和&lt;code&gt;_slvs.so&lt;/code&gt;放在相同目錄中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Usage.py&lt;/code&gt;是參照Readme的說明，將範例code抓下來存在&lt;code&gt;exposed&lt;/code&gt;資料夾的程式檔。&lt;/p&gt;
&lt;p&gt;然而若直接執行會出下列錯誤：&lt;/p&gt;
&lt;h2&gt;&lt;em&gt;test.py&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Dp86EeP.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;&lt;em&gt;Usage.py&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/goKX3du.jpg" &gt;&lt;/p&gt;
&lt;p&gt;意思是Python無法調用&lt;code&gt;_slvs&lt;/code&gt;這個模組，大部分的原因是名稱錯誤或是沒有導入。&lt;/p&gt;
&lt;p&gt;SWIG手冊的"Using distutils"之後的幾章是講導出模組後的應用。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/xm3XyRs.jpg" &gt;&lt;/p&gt;
&lt;p&gt;看了一下內容，Python導出後的模組可以作為Python的附加元件、直接呼叫、動態模組、靜態連結之類的。&lt;/p&gt;
&lt;p&gt;不過沒有解答一些例外的錯誤。&lt;/p&gt;
&lt;p&gt;但是一直找不到&lt;code&gt;_slvs.so&lt;/code&gt;，不知道是出了甚麼問題，會繼續尋找資料。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;公開倉儲 :&lt;/h2&gt;

&lt;p&gt;把目前進度推到了自己的&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;倉儲，在&lt;code&gt;exposed&lt;/code&gt;資料夾中的Makefile編輯工具位置，就能Make和Clean。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/u5OAbuX.jpg" &gt;&lt;/p&gt;</summary><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>40323250日誌 - V-rep 功能 (持續更新中)</title><link href="http://project.mde.tw/blog/40323250ri-zhi-v-rep-gong-neng-chi-xu-geng-xin-zhong.html" rel="alternate"></link><published>2016-07-20T20:37:00+08:00</published><updated>2016-07-20T20:37:00+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2016-07-20:blog/40323250ri-zhi-v-rep-gong-neng-chi-xu-geng-xin-zhong.html</id><summary type="html">&lt;p&gt;V-rep 的使用與學習&lt;/p&gt;


&lt;p&gt;&lt;/br&gt;
&lt;h2&gt;Onshape繪製V-rep零件 : &lt;/h2&gt;
&lt;/br&gt;
&lt;h3&gt;在Onshape新增一個零件檔 ,選擇隱私或者公開 ,目前每個人擁有的容量為10mb。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/onshape_1.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;在part studio部分選擇平面當作草圖繪圖 ,功能和大多繪圖軟體相同。&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;單位設置 :&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/onshape_units.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;功能表有一個(x)函數圖示 ,能夠設定變數值 ,方便用於零件設計 ,若新增一個x ,命名為a且值為10的值 ,之後在填入尺寸部分輸入#a ,則該尺寸為10。 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/onshape_a.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;零件繪製好之後 ,在Assembly中引入零件。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/onshape_insert.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;先按右鍵將底座設定為fix(固定) ,組裝零件須注意 ,因為使用V-rep模擬 ,組裝時零件和零件設定小段距離(offset) ,不要完全貼合(在V-rep較易拆解零件) ,旋轉軸先透過cylindrical_mate和孔配合 ,再利用planar_mate讓軸偏移小段距離。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/onshape_offset.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;組合完畢後 ,在Assembly點選右鍵 ,輸出成stl格式檔案。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/onshape_export.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h2&gt;V-rep 教學 :&lt;/h2&gt;
&lt;/br&gt;
&lt;h3&gt;導入stl檔案 :&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;點選左上方工具列File ,import ,mesh ,選取繪製的stl檔案後 ,就可以看到零件了。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/vrep_import.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/vrep_import2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;h3&gt;調整座標 :&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;若只看到零件的一部分 ,就是零件倒過來了 ,這時候點選左方零件圖示 ,再選上方工具列 ,將零件座標系設定成V-rep內(World)座標 ,最後點選上方旋轉功能 ,旋轉零件至理想角度。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/vrep_setaxis.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/vrep_setaxis2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;轉好角度之後 ,點選上方平移功能 ,並調整Z軸高度。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/vrep_setaxis3.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;若零件被地板遮住 ,看不到零件 ,可先使用選平移功能 。&lt;/h3&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;h3&gt;拆解零件 :&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;在V-rep導入的stl檔都會變成一個整體零件 ,而在Onshape先組好是因為零件拆解後較容易定位 ,且座標較容易設定等等。&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;點選欲拆解之零件後 ,點選工具列 ,編輯 ,Grouping/Merging ,Divide select shapes。 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/vrep_divide.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;若有照上方Onshape繪製零件方式 ,零件就可以順利拆開。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/vrep_divide2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h2&gt;加入旋轉軸 : &lt;/h2&gt;
&lt;/br&gt;
&lt;h3&gt;在右側視窗點選右鍵 , Add → Joint → Revolute
&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/Revolute.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;新增完成 ,快點兩下圖示 ,可以設定相關性質&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/Revolute_icon.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;橘色框框為旋轉軸長度及直徑 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/Revolute_properties.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;移動旋轉軸至零件主軸 : 先點選欲移動之物件(a.)後 ,按著shift並點選欲移動到的物件(b.) ,之後點選移動調整性質&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/move.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;綠色框框內分別為X、Y、Z重合 ,使旋轉軸與物體在同一軸線上 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/move_properties.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;如果相關參數都設定好了 ,點選右鍵→Edit→使旋轉軸與零件結合成一物件(也可以直接用滑鼠拖曳)&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/object_combine.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;結合後的從屬關係&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/object_parent.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h2&gt;旋轉軸(馬達)設定 :&lt;/h2&gt;
&lt;/br&gt;
&lt;h3&gt;先將各部位組立完成&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/Revolute_pin.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;設定底座Dynamic性質 , ( X = 不打勾 )&lt;/h3&gt;
&lt;h3&gt;Body is respondable 指 是否實體化 ,若兩個實體化物件互相碰撞 ,會依照物理設定做相對反應。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/dynamic_properties_1.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;設定Revolute_joint(馬達)性質 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/dynamic_properties_2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;設定旋轉軸Dynamic性質 ,設為動態物件
&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/dynamic_properties_3.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;設定旋轉桿Dynamic性質&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/dynamic_properties_4.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;都設定好之後 ,設定旋轉軸(馬達)程式 ,點選左方文件圖示 ,之後在右方Scripts新增一個子程式&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/scripts_code_1.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;在Assciated object選擇STL_Imported_sub(主體) &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/scripts_code_2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;之後打開左方script ,並加入下面那行程式&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/child_script.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;設定完之後就可以按start ,跑老師的python範例了&lt;/h3&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h2&gt;加入攝影機&lt;/h2&gt;
&lt;/br&gt;
&lt;h3&gt;在物件視窗點選滑鼠右鍵 → add → vision sensor →選擇其中一種類型&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sensor.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;vision_sensor類型可分為 :
a.為orthographic type  及  b.為perspective type&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sensor_types.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;點兩下圖示設定攝影機性質 ,橘色框框為攝影範圍 ,
綠色框框為範圍內的解析度 (2^n ,2~256) ,棕色框框為攝影機大小&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sensor_properties.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;將旋轉桿和攝影機結合並設定從屬關係&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sensor_combine.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;在物件視窗點選右鍵 ,點選 Remove page ,再次按右鍵新增2個視窗&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/add_2views.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;點選左方第一台預設攝影機後 ,在上方視窗點選右鍵輸入攝影鏡頭&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/first_view.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;下方視窗則點選新增的攝影機 ,一樣新增攝影鏡頭
&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/second_view.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;下方視窗會是黑色的 ,因為鏡頭所照的地方都是黑色 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sight.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;若將攝影機向下轉 ,就可以照到地板了 ,紅框內是照到旋轉桿 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sight2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;啟動程式來跑看看囉~&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision.gif"&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;dummy ( 虛擬座標 ) :&lt;/h3&gt;
&lt;h3&gt;dummy 能夠讓不是從屬性質的物件做相對移動, 常用於close chain, 以irb360範例來說 :&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;a. b.桿為示範物件&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/dummy_1.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;將a.及b.桿實體隱藏之後 ,能夠看到從屬於a、b桿下的dummy為重疊狀態 ,並且為互相對應(target)  &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/dummy_2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/dummy_3.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;目的是因為 ,若a桿做出任何動作(移動) ,在它從屬下的dummy會隨著target的dummy做相對運動 ,因此兩桿距離始終會保持固定 &lt;/h3&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;零件大小 :&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;size factor 為 目前模型的 比例 ,透過下方 Scaling 可以設定模型倍率 ,若Scaling factor 設為2 ,上方的size factor 會變成2 ,就是原始模型的2倍大&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/size_1.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;零件座標系 :&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;導入零件後 ,拆解發現零件的角度與V-rep右下角(World)的座標不同 ,有時對於joint的放置會變得不方便 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/axis_1.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;點選要改變座標的零件後 ,在edit選單下點選Reorient bounding box→with reference frame of world 即可&lt;/h3&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/axis_2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/axis_3.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;利用三角建構零件放入joint :&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;因為手臂有個齒輪 ,且有傾斜角度 ,所以需要透過零件轉換 ,並插入一個圓軸來輔助joint&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/axis_4.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;點選零件後右鍵選取 Edit→Decimate selected shape後 ,選擇三角形數量 (太少圓形會變多角形 ,太多運算會變慢) ,之後點選左方 Toggle shape edit mode&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/icon.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;全選所有三角形 ,並點選Extract cylinder後按OK&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/shape.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;之後就可以順利放上joint了&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/shape_2.png"&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323230日誌 - 105/07/20</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050720.html" rel="alternate"></link><published>2016-07-20T19:00:00+08:00</published><updated>2016-07-20T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-20:blog/40323230ri-zhi-1050720.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;gcc的&lt;code&gt;-M&lt;/code&gt;類型參數問題。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;math.h與pyconfig.h衝突修正。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用libpython35.a解決_wrap.cxx找不到函式的問題。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;Solvespace Makefile :&lt;/h2&gt;

&lt;p&gt;目前發現obj檔案無法辨識的原因是原始Makefile中加上了&lt;code&gt;-MT&lt;/code&gt;這個參數，然而沒有這個參數，只能改用&lt;code&gt;-MD&lt;/code&gt;來取代。&lt;/p&gt;
&lt;p&gt;直到Link這些obj檔時才發現，這些obj檔竟然是文字文件，而另一個Makefile導出的obj檔都相當正常。&lt;/p&gt;
&lt;p&gt;最後決定把Makefile中gcc的參數統一化，剩下才發現&lt;code&gt;-M&lt;/code&gt;系的參數會輸出信息檔，而不是物件。&lt;/p&gt;
&lt;p&gt;但是將obj檔重新連結成&lt;code&gt;solvespace.exe&lt;/code&gt;時就開始顯示大大小小的錯誤了，而且並非&lt;code&gt;-W&lt;/code&gt;的普通警告。相反的另一邊exposed資料夾就沒出現過警告。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/fnQrcS8.jpg" &gt;&lt;/p&gt;
&lt;p&gt;所以要成功編譯就必須將錯誤修正，看一些關於C++的資料。這些錯誤貌似都是物件繼承、指標項的用法問題。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/2dtnGX0.jpg" &gt;&lt;/p&gt;
&lt;p&gt;不過今天專注在如何克服exposed資料夾的錯誤。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;MinGW的math.h和Python的pyconfig.h :&lt;/h2&gt;

&lt;p&gt;上網搜尋了許多文章，大部分的人使用MinGW編譯C轉Python的文件時，同時導入&lt;code&gt;cmath&lt;/code&gt;和&lt;code&gt;Python.h&lt;/code&gt;都會遇到這個衝突。&lt;/p&gt;
&lt;p&gt;主要原因是＜math.h＞中有一段&lt;code&gt;_hypot(double _X, double _Y)&lt;/code&gt;的函式，而它的名稱剛好與&lt;code&gt;pyconfig.h&lt;/code&gt;中的&lt;code&gt;define hypot _hypot&lt;/code&gt;衝突。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/xdCKbBE.jpg" &gt;&lt;/p&gt;
&lt;p&gt;上網搜尋時找到一系列2013年的信件：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.vtk.org/pipermail/vtk-developers/2013-March/013475.html" title="vtk.org"&gt;http://www.vtk.org/pipermail/vtk-developers/2013-March/013475.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;主要是討論如何處理這個問題，信中曾建議在自己的程式碼的&lt;code&gt;include ＜Python.h＞&lt;/code&gt;下加上這段：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#include ＜cmath＞
#include ＜Python.h＞
#ifdef hypot
#undef hypot
#endif
&lt;/pre&gt;

&lt;p&gt;但是這樣根本不可行，因為導入&lt;code&gt;Python.h&lt;/code&gt;時就會同時導入&lt;code&gt;pyconfig.h&lt;/code&gt;，一旦導入&lt;code&gt;pyconfig.h&lt;/code&gt;就會產生衝突，後面再undefine也不會有用。&lt;/p&gt;
&lt;p&gt;所以根本的問題就是修改&lt;code&gt;pyconfig.h&lt;/code&gt;，變成這一段：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#ifndef _MATH_H_
#define hypot _hypot
#endif
&lt;/pre&gt;

&lt;p&gt;讓它只能在沒有&lt;code&gt;math.h&lt;/code&gt;的時候才能使用。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/4OWuZG1.jpg" &gt;&lt;/p&gt;
&lt;p&gt;更改後編譯就沒有問題了。&lt;/p&gt;
&lt;p&gt;不過不知道這樣更改會不會讓Anaconda的Python衍生其他狀況。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;libpython35.a :&lt;/h2&gt;

&lt;p&gt;出現了&lt;code&gt;slvs_wrap.cxx&lt;/code&gt;匯入函式的問題。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
slvs_wrap.o: In function `_SWIG_Py_None':
slvs_wrap.cxx:1446: undefined reference to `__imp__Py_RefTotal'
...
&lt;/pre&gt;

&lt;p&gt;這些是SWIG自動產生的，interface無法修改。&lt;/p&gt;
&lt;p&gt;上網搜尋了一下，應該是軟體位元問題，找到了類似的問題。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.gdomc.com/0423/how-can-i-build-my-c-extensions-with-mingw-w64-in-python/" title="gdomc.com"&gt;http://www.gdomc.com/0423/how-can-i-build-my-c-extensions-with-mingw-w64-in-python/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接著參考另一篇文章生成&lt;code&gt;libpython35.a&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/kivy/kivy/wiki/Creating-a-64-bit-development-environment-with-MinGW-on-Windows" title="github.com"&gt;https://github.com/kivy/kivy/wiki/Creating-a-64-bit-development-environment-with-MinGW-on-Windows&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先，將Python的DLL檔複製一份進Python的libs資料夾中。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/6CGP2VW.jpg" &gt;&lt;/p&gt;
&lt;p&gt;接著下載&lt;code&gt;gendef.exe&lt;/code&gt;，它也是MinGW的工具之一，從下列網址下載&lt;code&gt;gendef-1.0.1346-1-mingw32-bin.tar.lzma&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://sourceforge.net/projects/mingw/files/MinGW/Extension/gendef/gendef-1.0.1346/" title="sourceforge.net"&gt;https://sourceforge.net/projects/mingw/files/MinGW/Extension/gendef/gendef-1.0.1346/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解壓縮進MinGW的bin資料夾中。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/CsH45V5.jpg" &gt;&lt;/p&gt;
&lt;p&gt;接著用CMD進入Python的libs資料夾中使用以下命令。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
gendef python35.dll
dlltool --dllname python35.dll --def python35.def --output libpython35.a
&lt;/pre&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/nMybQmX.jpg" &gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dlltool&lt;/code&gt;是GNU內建的工具，有安裝過安裝版的GNU工具包就能在本機端環境使用。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/wAdo8A1.jpg" &gt;&lt;/p&gt;
&lt;p&gt;做完後就會產生&lt;code&gt;libpython35.a&lt;/code&gt;這個檔案。&lt;/p&gt;
&lt;p&gt;然後到Python的include資料夾開啟&lt;code&gt;pyconfig.h&lt;/code&gt;這個檔案編輯。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/oSfNLI9.jpg" &gt;&lt;/p&gt;
&lt;p&gt;搜尋並將以下內容剪下：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#ifdef _WIN64
#define MS_WIN64
#endif
&lt;/pre&gt;

&lt;p&gt;貼到以下內容的「上方」：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#ifdef _MSC_VER
...
&lt;/pre&gt;

&lt;p&gt;再到Python的&lt;code&gt;Lib\distutils&lt;/code&gt;資料夾中，開啟&lt;code&gt;cygwinccompiler.py&lt;/code&gt;這個檔案。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/XwvABHb.jpg" &gt;&lt;/p&gt;
&lt;p&gt;搜尋以下內容並註解掉：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
self.dll_libraries = get_msvcr()
&lt;/pre&gt;

&lt;p&gt;注意四周會有相似的內容，不要弄錯註解。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/xfY1FU0.jpg" &gt;&lt;/p&gt;
&lt;p&gt;範例在編譯&lt;code&gt;slvs_wrap.o&lt;/code&gt;時加上&lt;code&gt;-DMS_WIN64&lt;/code&gt;參數。&lt;/p&gt;
&lt;p&gt;不過這時因為已經修改過&lt;code&gt;pyconfig.h&lt;/code&gt;的內容，會自動宣告&lt;code&gt;MS_WIN64&lt;/code&gt;，所以加上會提示說重複宣告。&lt;/p&gt;
&lt;p&gt;最後編譯用的指令如下。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
g++ -IW:/Anaconda3/include -Wno-unused-but-set-variable -c -o ../obj/slvs_wrap.o slvs_wrap.cxx
g++ -shared -fPIC -o _slvs.so ... ../extlib/si/siapp.lib  -LW:/Anaconda3/libs -lPython35
&lt;/pre&gt;

&lt;p&gt;但是最後還是出現一點錯誤：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Ie05RYb.jpg" &gt;&lt;/p&gt;
&lt;p&gt;應該是內部的導入問題。&lt;/p&gt;
&lt;p&gt;由於時間不多，所以這個部分之後再解決。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;今天有稍微比較下Whitequark的原始碼，不過用法已經完全不一樣，相同的變數也改變了型態，更有系統性，但是也更難判讀，所以&lt;code&gt;.cpp&lt;/code&gt;的部分還得熟悉相關的知識。&lt;/p&gt;
&lt;p&gt;Solvespace Makefile的部分是編譯&lt;code&gt;solvespace.exe&lt;/code&gt;的部分，不過Python呼叫的部分應該是不用那麼多，畢竟那些大部分都是介面檔，真正的本體只需要判斷是否衝突。&lt;/p&gt;
&lt;p&gt;所以Solvespace Makefile的部分才做得漫不經心吧。&lt;/p&gt;
&lt;p&gt;exposed Makefile部分的&lt;code&gt;all&lt;/code&gt;為三個目標：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
all: cdemo _slvs.so slvs.py
    LD_LIBRARY_PATH=. ./cdemo
&lt;/pre&gt;

&lt;p&gt;CDemo的部分已經成功轉出可執行檔；&lt;code&gt;_slvs.so&lt;/code&gt;還在最後階段的編譯中；&lt;code&gt;slvs.py&lt;/code&gt;則是原作者撰寫好的（不過是Python 2）。&lt;/p&gt;
&lt;p&gt;預計不久後就能夠測試&lt;code&gt;_slvs.so&lt;/code&gt;的功能。&lt;/p&gt;</summary><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>40323218日誌 - 105/07/19</title><link href="http://project.mde.tw/blog/40323218ri-zhi-1050719.html" rel="alternate"></link><published>2016-07-19T20:37:00+08:00</published><updated>2016-07-19T20:37:00+08:00</updated><author><name>40323218</name></author><id>tag:project.mde.tw,2016-07-19:blog/40323218ri-zhi-1050719.html</id><summary type="html">&lt;p&gt;V-rep 翻譯 Inverse kinematics&lt;/p&gt;


&lt;p&gt;&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/IK1.png" weight=600 &gt;&lt;br&gt;&lt;br&gt;
&lt;h3&gt;•  Inverse kinematics enabled:   啟用或禁用所有IK計算。&lt;br&gt;
&lt;br&gt;&lt;br&gt;
•  Add new IK group: &lt;br&gt;&lt;br&gt;新增一個空的 IK group. IK groups 可以包含一個或多個 IK elements.&lt;br&gt;&lt;br&gt; IK elements 是基本運動學綁著IK任務, IK groups可以組合他們來同時運行.&lt;br&gt;&lt;br&gt; 當需要時只使用同時運行(比依序運算花較長的計算時間).&lt;br&gt;&lt;br&gt; 一個IK element 總必須被一個IK group連結，而且不能單獨存在. &lt;br&gt;&lt;br&gt;在按鈕下方的列表中顯示所有的IK groups將會在IK計算時被運行.&lt;br&gt;&lt;br&gt; 在列表中一個 IK group需要被選擇，為了顯現它的參數在剩餘的對話框中.&lt;br&gt;&lt;br&gt; 在列表中的順序很重要(IK group 1的結果可能被IK group 2需要來正確地或更快的執行).&lt;br&gt;&lt;br&gt; 在列表旁的兩個按鈕可以改變被選擇的IK group的位置.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  IK group is active:     允許啟動這個IK groups.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Explicit handling: &lt;br&gt;&lt;br&gt;表示被選擇的IK group 是否應該被明確地處理. &lt;br&gt;&lt;br&gt;如果打勾, 當呼叫simHandleIkGroup(sim_handle_all_except_explicit)時，&lt;br&gt;&lt;br&gt;在IK 計算這個IK group將不會被處理，但只有當&lt;br&gt;&lt;br&gt;simHandleIkGroup(sim_handle_all) or&lt;br&gt;&lt;br&gt; simHandleIkGroup(ikGroupHandle) 呼叫時除外. &lt;br&gt;&lt;br&gt;這是非常有用的當如果用戶希望在  child script 而不是在  main script&lt;br&gt;&lt;br&gt;處理IK group裡的kinematics  (如果沒有打勾, IK計算將會被執行兩次,一次是在&lt;br&gt;&lt;br&gt;main script呼叫simHandleIkGroup(sim_handle_all_except_explicit) 時, &lt;br&gt;&lt;br&gt;另一次是在child script 呼叫simHandleIkGroup(ikGroupHandle)時. &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Mechanism is redundant: &lt;br&gt;&lt;br&gt;當被打勾時, 在IK解析時joint限制校正將被啟用. &lt;br&gt;&lt;br&gt;否則，joint limits 將會簡單地被強制執行在IK 解析之後，可能導致不穩定.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Ignore max. step sizes:   如果被勾選，在  joint properties 裡的maximum step sizes 將會被忽略.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Calc. method: &lt;br&gt;&lt;br&gt;具體說明IK group 決定使用的計算方式. &lt;br&gt;&lt;br&gt; Pseudo inverse  是最快的方式但可能不穩定當目標與 tip lie 距離太遠, 當一個運動鏈超過限制或當機構靠近一個單一組態 或 超出目標.&lt;br&gt;&lt;br&gt;  DLS 是較慢但更穩定因為它是一個阻尼分析方式(阻尼因子可以被指定（阻尼）). &lt;br&gt;&lt;br&gt;這是一個好的選擇當  pseudo inverse可能失敗.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Damping: &lt;br&gt;&lt;br&gt;阻尼因子當使用DLS.  較大的值導致更穩定的分辨率，但速度很慢。適當地調整值是重要的。&lt;br&gt;&lt;br&gt;&lt;br&gt;
•  Max. iterations: &lt;br&gt;&lt;br&gt;重複的最大數值可以被指定. 這是計算經過的最大數量對於給予的IK group，直到它指定的結果精度到達. DLS 經常需要比  Pseudo inverse更多的重複.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Joint limits (calculation weights): &lt;br&gt;&lt;br&gt;the calculation weight 應該被使用在 joint limitation constraints &lt;br&gt;&lt;br&gt;(joint limitation constraints 是被指定在  joint properties &lt;br&gt;&lt;br&gt;(position minimum andposition range).&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Obstacle avoidance (calculation weights): &lt;br&gt;&lt;br&gt;the calculation weight 應該被使用對於 obstacle avoidance(避開障礙物) constraints.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Joint limit thresholds:   線性和角度的臨界值應該和joint limitation constraints 一起被使用.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Edit conditional parameters:   調整選擇的IK group裡附加的參數 .&lt;/h3&gt;
&lt;br&gt;&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/IK2.png" weight=600 &gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3&gt;•  Perform if... : &lt;br&gt;&lt;br&gt;這是有條件的分析部分. &lt;br&gt;&lt;br&gt;使用者可以選擇下拉一個在列表中的IK group，&lt;br&gt;&lt;br&gt;這個IK分析結果將會決定當前IK group是否會被解決。&lt;br&gt;&lt;br&gt;被認為是成功的IK group計算的IK elements都位於指定的線性/角度精度內。&lt;br&gt;&lt;br&gt;&lt;br&gt;
•  Restore if... : &lt;br&gt;&lt;br&gt;允許恢復初始IK group配置（goint values）如果分析沒有成功 (位置和/或定向精度沒有達到).&lt;br&gt;&lt;br&gt; 與上述條件的解結合時，用戶可以例如結合兩個不同的計算方法。&lt;br&gt;&lt;br&gt;這是有用的如果在操作者的目標可能超出範圍或靠近一個單一組態: &lt;br&gt;&lt;br&gt;第一次分析嘗試將試著求解IK group與non-damped resolution method (pseudo inverse, fast), &lt;br&gt;&lt;br&gt;而且如果不成功, 第二次嘗試將會試著解決它與damped resolution method (DLS, slower). &lt;br&gt;&lt;br&gt;使用者也當然可以自由手動地處理IK resolution 從script, plugin, 等.&lt;br&gt;&lt;br&gt;&lt;br&gt;
•  Edit obstacle avoidance parameters: &lt;br&gt;&lt;br&gt;允許調整避障參數。&lt;br&gt;&lt;br&gt;請注意，這只是對熟練的操作者有意義, &lt;br&gt;&lt;br&gt;而且模擬速度會大幅度地放緩。&lt;/h3&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/IK3.png" weight=600 &gt;&lt;br&gt;&lt;br&gt;
&lt;h3&gt;•  Select avoidance entities / Remove avoidance constraint: &lt;br&gt;&lt;br&gt;允許選擇/移除avoidance entities. &lt;br&gt;&lt;br&gt;一個整體通常是機器人，其他實體是障礙物。&lt;br&gt;&lt;br&gt; 使用簡單地measurable objects 來快速分析.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Distance threshold: &lt;br&gt;&lt;br&gt;在兩個avoidance entities 之間應該保持最小的距離.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Edit IK elements: &lt;br&gt;&lt;br&gt;允許編輯各種被選擇的IK group有關聯的IK elements.
&lt;/h3&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323230日誌 - 105/07/19</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050719.html" rel="alternate"></link><published>2016-07-19T19:00:00+08:00</published><updated>2016-07-19T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-19:blog/40323230ri-zhi-1050719.html</id><summary type="html">&lt;p&gt;Python-Solvespace編譯除錯中。&lt;/p&gt;


&lt;h2&gt;Netbeans的版次管理與自訂工具列 :&lt;/h2&gt;

&lt;p&gt;Netbeans有內建檔案版本紀錄的功能，只要在檔案左上角的按鈕切換到&lt;code&gt;History&lt;/code&gt;，就會出現修改紀錄表。&lt;/p&gt;
&lt;p&gt;點擊其中的項目就會顯示並和目前版本的檔案做比較。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/dwmVZD4.jpg" &gt;&lt;/p&gt;
&lt;p&gt;其中紅色是刪除；綠色是新增；藍色是取代。&lt;/p&gt;
&lt;p&gt;如果想復原其中的項目，可以移到顏色區塊上，左側的版本會出現箭頭，能夠將舊版的內容復原至當前的區段中，十分方便。&lt;/p&gt;
&lt;p&gt;若是想直接復原整個檔案，可以在紀錄上案右鍵，選擇&lt;code&gt;Revert from History&lt;/code&gt;就會復原檔案。特別的是，一但復原檔案，Netbeans就會直接儲存檔案，成為新的歷史紀錄，這方面需要多注意。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/2Ih9AVd.jpg" &gt;&lt;/p&gt;
&lt;p&gt;而專案中的檔案名稱也會配上顏色，不論是在左側的檔案樹或是分頁上。&lt;/p&gt;
&lt;p&gt;黑色是一般clone下來的專案；藍色是使用者修改過的檔案（縱使已經復原到原始版本）；灰色是透過MinGW以外程式編寫的檔案；綠色是自己撰寫或是由MinGW編譯出的檔案。&lt;/p&gt;
&lt;p&gt;Netbeans是以Git功能為基礎架設的（雖然不一定要使用），因此十分注重版次管理，也支援圖形化顯示&lt;code&gt;git pull&lt;/code&gt;的修改處。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/H2v8Lve.jpg" &gt;&lt;/p&gt;
&lt;p&gt;另一個個人化的功能就是自訂工具列，能夠將內建或模組的功能鈕設置在工具列上。&lt;/p&gt;
&lt;p&gt;排列方法跟Firefox一樣是抓取的。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/W7kSbRH.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;上次的問題 :&lt;/h2&gt;

&lt;p&gt;上一篇網誌中的問題：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Icons&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Netbeans找不到外部程式的問題已解決，只要指定程式的確切位置就能執行。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/jVeAaE3.jpg" &gt;&lt;/p&gt;
&lt;p&gt;所以指定Perl在W:槽的位置，上次發現的Perl其實是MinGW的附加工具，版本是5.8。&lt;/p&gt;
&lt;p&gt;但是新下載的是5.24，並且有安裝需要的模組"GD"。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/zSV5yLU.jpg" &gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/NjpIYjZ.jpg" &gt;&lt;/p&gt;
&lt;p&gt;修改成下面這段：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
PERL = W:\Perl524\bin\perl.exe

...

$(OBJDIR)/icons.h: png2c.pl icons/*
    @echo icons
    $(PERL) $＜ $@ $(OBJDIR)/icons-proto.h
&lt;/pre&gt;

&lt;p&gt;指定後就可以執行。&lt;/p&gt;
&lt;p&gt;而後來又有一個"rc"的指令：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
$(RES): win32/$(@B).rc icon.ico
    rc win32/$(@B).rc
    mv win32/$(@B).res $(OBJDIR)/$(@B).res
&lt;/pre&gt;

&lt;p&gt;（原始版本的錯誤用法＄(＠B)應該為＄(＠F)，都改為＄＜或＄^較明瞭）&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/jVeAaE3.jpg" &gt;&lt;/p&gt;
&lt;p&gt;經查詢資料，"rc.exe"原是Windows Kits的一個工具。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/QWfaVfq.jpg" &gt;&lt;/p&gt;
&lt;p&gt;所以就改寫用變數指定。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
RC = "C:\Program Files (x86)\Windows Kits\$(RCVER)\bin\$(RCBIT)\rc.exe"
RCVER = 10
RCBIT = x64

...

$(RES): resource.rc icon.ico
    @echo RES
    $(RC) $＜
    mv win32/resource.res  $@
&lt;/pre&gt;

&lt;p&gt;同理，其他如SWIG都可以呼叫所在位置來執行了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ld.exe does not find libraries&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;要改一下語法，之前使用的&lt;code&gt;-lslvs&lt;/code&gt;應該指定名稱&lt;code&gt;-l:libslvs.so&lt;/code&gt;並指定同目錄：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
cdemo: CDemo.c libslvs.so
    @echo cdemo
    @$(CXX) $(CFLAGS) -o $@ $＜ -L. -l:libslvs.so $(LIBS)
&lt;/pre&gt;

&lt;p&gt;接著就能夠找到libslvs.so。&lt;/p&gt;
&lt;p&gt;不知道是因為沒有&lt;code&gt;-L&lt;/code&gt;指定目錄還是&lt;code&gt;-l&lt;/code&gt;不會看附檔名的關係，一定要標定到檔案才會容許。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;錯誤紀錄 :&lt;/h2&gt;

&lt;h4&gt;已解決&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Function "vasprintf"&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在"slvs_python.hpp"中，導入了一個stdio.h的函式&lt;code&gt;vasprintf&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;不過其實正確名稱應該要增加父項式，因此修改成&lt;code&gt;__mingw_vasprintf(&amp;amp;buf, fmt, args)&lt;/code&gt;就沒問題了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/czsgUbf.jpg" &gt;&lt;/p&gt;
&lt;p&gt;Netbeams應該是支援h++的標頭檔，但是"slvs_python.hpp"的前半段錯誤累累，應該是從屬關係和宣告的部分沒弄清楚。&lt;/p&gt;
&lt;p&gt;目前並沒有干擾MinGW的編譯，但是這些東西應該重新整理一下，尤其是下面的導入：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#include ＜string＞
#include ＜exception＞
&lt;/pre&gt;

&lt;p&gt;在編寫時好像連結不到，但是編譯時MinGW抓得到，不知道Netbeams的錯誤有沒有算入這種情形。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;CMath&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;用SWIG剛轉出"slvs_wrap.cxx"時產生的問題。&lt;/p&gt;
&lt;p&gt;出現一段錯誤：&lt;code&gt;error: '::hypot' has not been declared&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在其他人的commit中有解答：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/casadi/casadi/issues/622" title="github.com"&gt;https://github.com/casadi/casadi/issues/622&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;是說要新增&lt;code&gt;include ＜cmath＞&lt;/code&gt;進"slvs_wrap.cxx"中，而且必須在"Python.h"之前。&lt;/p&gt;
&lt;p&gt;所以我就在interface檔中新增了，讓轉換時會自動加入這段。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/cqgzD3B.jpg" &gt;&lt;/p&gt;
&lt;p&gt;不過這個問題是暫時解決，後來又有相關的麻煩。&lt;/p&gt;
&lt;h4&gt;未解決&lt;/h4&gt;

&lt;p&gt;分成兩部分的Makefile，主要是exposed資料夾的python函式比較重要。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Solvespace Makefile&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在最後一個要生成"solvespace.exe"時無法辨識&lt;code&gt;.obj&lt;/code&gt;檔案？&lt;/p&gt;
&lt;pre class="brush: c"&gt;
g++ -D_WIN32_WINNT=0x500 -DISOLATION_AWARE_ENABLED -D_WIN32_IE=0x500 -DWIN32_LEAN_AND_MEAN -DWIN32 -g -m32 -MT -Iextlib -I..\common\win32 -I. -D_DEBUG -D_CRT_SECURE_NO_WARNINGS   obj/ratpoly.obj ... obj/resource.res -o obj/solvespace.exe
w:/mingw/bin/../lib/gcc/x86_64-w64-mingw32/6.1.0/../../../../x86_64-w64-mingw32/bin/ld.exe:obj/ratpoly.obj: file format not recognized; treating as linker script
w:/mingw/bin/../lib/gcc/x86_64-w64-mingw32/6.1.0/../../../../x86_64-w64-mingw32/bin/ld.exe:obj/ratpoly.obj:1: syntax error
collect2.exe: error: ld returned 1 exit status
make.exe": *** [obj/solvespace.exe] Error 1
&lt;/pre&gt;

&lt;p&gt;目前還不知道怎麼辦，因為不太了解&lt;code&gt;.o&lt;/code&gt;和&lt;code&gt;.obj&lt;/code&gt;的關係。&lt;/p&gt;
&lt;p&gt;前者是暫時等待編譯的物件，後者是給記憶體參照的。&lt;/p&gt;
&lt;p&gt;gcc對於副檔名是很重視的，可能要調整參數之類的？&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Exposed Makefile&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;剩下幾步可以編成"slvs_wrap.o"。&lt;/p&gt;
&lt;p&gt;最後跳出的錯誤，竟然是內建資料庫的問題。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
In file included from W:/Anaconda3/include/Python.h:8:0,
                 from slvs_wrap.cxx:14:
W:/Anaconda3/include/pyconfig.h:262:15: error: 'std::_hypot' has not been declared
 #define hypot _hypot
               ^
make.exe": *** [../obj/slvs_wrap.o] Error 1
&lt;/pre&gt;

&lt;p&gt;導入"Python.h"和相關的"pyconfig.h"時出現了錯誤。是從上面cmath衍生的問題。&lt;/p&gt;
&lt;p&gt;上網搜尋了一下，好像找不到解決方法，&lt;code&gt;'std::_hypot' has not been declared&lt;/code&gt;好像有出現在MinGW的Bug紀錄中。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;這兩個Makefile的使用參數大相逕庭，以下是比較：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Solvespace&lt;/em&gt;&lt;/p&gt;
&lt;pre class="brush: c"&gt;
DEFINES = -D_WIN32_WINNT=0x500 -DISOLATION_AWARE_ENABLED -D_WIN32_IE=0x500 -DWIN32_LEAN_AND_MEAN -DWIN32
CFLAGS = -g -m32 -MT -Iextlib -I..\common\win32 -I. -D_DEBUG -D_CRT_SECURE_NO_WARNINGS
&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Exposed&lt;/em&gt;&lt;/p&gt;
&lt;pre class="brush: c"&gt;
WIN_DEFINES = -D_WIN32_WINNT=0x500 -D_WIN32_IE=0x500 -DWIN32_LEAN_AND_MEAN
DEFINES = -DISOLATION_AWARE_ENABLED -DLIBRARY
CFLAGS  = -I../extlib -I../../common/win32 -I. -I.. -D_DEBUG -D_CRT_SECURE_NO_WARNINGS -O2 -g -Wno-write-strings -fpermissive
CFLAGS_SHARED = -fPIC -shared $(CFLAGS)
&lt;/pre&gt;

&lt;p&gt;兩個Makefile編譯階段都進入整合階段，剩下的一些編譯問題主要是對MinGW的編譯程式不熟悉的緣故。&lt;/p&gt;
&lt;p&gt;像是一般的&lt;code&gt;.so&lt;/code&gt;、&lt;code&gt;.o&lt;/code&gt;都較為廣用，可是將obj檔直接轉換成可執行檔，卻找不到範例。&lt;/p&gt;
&lt;p&gt;之後要再找找看gcc和g++的編譯範例。&lt;/p&gt;</summary><category term="SWIG"></category><category term="Solvespace"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/18</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050718.html" rel="alternate"></link><published>2016-07-18T19:00:00+08:00</published><updated>2016-07-18T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-18:blog/40323230ri-zhi-1050718.html</id><summary type="html">&lt;p&gt;改寫Python-Solvespace的Makefile運作方式。&lt;/p&gt;


&lt;h2&gt;前言 :&lt;/h2&gt;

&lt;p&gt;閱讀GNU-Make的手冊之後，已經了解Makefile基本的運作方式，所以試圖解決Python-Solvespace編譯程序中出現的問題。&lt;/p&gt;
&lt;p&gt;手冊連結：&lt;a href="https://www.gnu.org/software/make/manual/make.pdf" title="gnu.org"&gt;https://www.gnu.org/software/make/manual/make.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;利用Interface來轉換Whitequark的新版Solvespace應該是不太可行的方式了，何況Python-Solvespace也未使用全部的功能，我們需要的是解題的函式就好。&lt;/p&gt;
&lt;p&gt;而另一方面Solid-python現在已經完全支援Python 3，若之後要調用其功能，應該也不會有太大的障礙。&lt;/p&gt;
&lt;p&gt;所以決定把Python-Solvespace的Makefile重新寫好，將Python-Solvespace的資料庫建構完成。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;Netbeans的支援 :&lt;/h2&gt;

&lt;p&gt;其實Netbeans與&lt;span class="math"&gt;\(GNU開發者工具包\)&lt;/span&gt;周邊的軟體都有良好的相依性，因此在撰寫Makefile時方便不少。&lt;/p&gt;
&lt;p&gt;在編寫完Makefile時，可以在個別的Makefile上點擊右鍵，選擇需要的命令讓make執行，諸如all、clean等等的功能可以選擇。&lt;/p&gt;
&lt;p&gt;Makefile中可以撰寫功能讓工程師執行，連基本的clean功能也可以自訂要刪除哪些檔案。&lt;/p&gt;
&lt;p&gt;當然利用這點，Makefile中也可以利用Echo做help的功能，Whitequark的Solvespace就有支援。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/9DDeyVj.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;編寫Makefile :&lt;/h2&gt;

&lt;p&gt;原本Python-Solvespace的Makefile是將檔案分類，再一類類用一樣的式子做轉換，而且語法冗長還有許多錯誤。若有新增檔案，就必須填入參數的名單中登記。&lt;/p&gt;
&lt;p&gt;一個小型程式專案的Makefile事實上只需要下列的式子就能轉換：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
$(ADIR)/%.obj: $(BDIR)/%.cpp $(HEADERS)
    $(CXX) $(FLAGS) -c -o $@ $＜
&lt;/pre&gt;

&lt;p&gt;意思是ADIR中的obj檔都與BDIR的cpp檔、標頭檔有關聯，而每個obj檔是由每個cpp檔透過＄(CXX)命令式產生的。&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(後面的＄＠表示每個目標項（包括其位置）\)&lt;/span&gt;；同理，&lt;span class="math"&gt;\(＄＜亦代表每個參照項\)&lt;/span&gt;，不過＄＜是只包含第一個條件的參照項，所以後面的多個標頭檔就不會帶入＄(CXX)命令中。&lt;/p&gt;
&lt;p&gt;若要在命令式中使用所有條件的參照項，要使用＄+，但是更好的選擇是使用＄^，會自動排除重複名稱的參照項。&lt;/p&gt;
&lt;p&gt;這樣寫固然簡單，但是每個檔案都在不同的資料夾中，要如何讓make搜尋？&lt;/p&gt;
&lt;p&gt;所以必須加上VPath這個參數，讓尋找參照檔案時可以搜尋到所有符合的項目。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/wpUqKDX.jpg" &gt;&lt;/p&gt;
&lt;p&gt;make在找檔案時最大的特性就是&lt;span class="math"&gt;\(按邏輯去找\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;也因為這點，不用顧慮產生檔案的順序問題。只要"填寫"檔案是如何產生的，make就會根據需要的檔案來做順序調整。&lt;/p&gt;
&lt;p&gt;make會先忽略還沒產生的參照檔案，尋找已經備齊參照檔案的項目先做，指令亦可使用外部程式來執行。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;編譯瓶頸 :&lt;/h2&gt;

&lt;p&gt;經過重新整理的Makefile，應該是沒有問題了，都將指令分配完整沒有衝突。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/IkKQSqe.jpg" &gt;&lt;/p&gt;
&lt;p&gt;但是仍然遇到Makefile以外的一些問題。&lt;/p&gt;
&lt;h4&gt;已解決&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Stdint.h&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;這個原先是C語言的額外函式庫，幫助統一化使用的格式，但是如果沒裝，就會選擇作者寫的指令。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Rz3xBwO.jpg" &gt;&lt;/p&gt;
&lt;p&gt;不過這個地方應該是寫錯了，會一直認為這些是未定義的格式。&lt;/p&gt;
&lt;p&gt;其實導入"stdint.h"的地方也只有上圖的前半段，所以最快的解決方法就是讓solvespace.h擁有stdint.h一部份的能力。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/BireSqB.jpg" &gt;&lt;/p&gt;
&lt;p&gt;在上面這張Netbeans的比較圖中，直接把前半段的功能插進來用了，並成功解決問題。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Min &amp;amp; Max Functions&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;下列solvespace.h的函式出了問題。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#ifndef min
#define min(x, y) ((x) &lt; (y) ? (x) : (y))
#endif
#ifndef max
#define max(x, y) ((x) &gt; (y) ? (x) : (y))
#endif
&lt;/pre&gt;

&lt;p&gt;上網搜尋了一下，找到基本款的用法：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#define min(x, y) (((x)＜(y)) ? (x):(y))
#define max(x, y) (((x)&gt;(y)) ? (x):(y))
&lt;/pre&gt;

&lt;p&gt;加上括弧其實非必要，因為三元運算子的優先度本身就比大於小於還低。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/l5u0t2N.jpg" &gt;&lt;/p&gt;
&lt;p&gt;不過這個判斷式使用上怪怪的，移除後直接define就沒這個問題了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Object-oriented problem&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在surface.h中有一段是這樣描述的：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
class STrimBy {
...
    static STrimBy STrimBy::EntireCurve(SShell *shell, hSCurve hsc, bool bkwds);
...
};
&lt;/pre&gt;

&lt;p&gt;到stackoverflow.com的論壇尋找後，有相似的問題。&lt;/p&gt;
&lt;p&gt;是物件導向的從屬錯誤，不應該重複稱呼，但是編譯器通常不會抓這種錯誤，解決方法是刪掉前面的父項名稱。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/PC43snc.jpg" &gt;&lt;/p&gt;
&lt;p&gt;最後變成：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
class STrimBy {
...
    static EntireCurve(SShell *shell, hSCurve hsc, bool bkwds);
...
};
&lt;/pre&gt;

&lt;p&gt;也是成功解決。&lt;/p&gt;
&lt;h4&gt;未解決&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Icons&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;首先是圖示(icon)的問題。&lt;/p&gt;
&lt;p&gt;Python-Solvespace的作者使用另一個語言&lt;span class="math"&gt;\(Perl\)&lt;/span&gt;的程式來做出"icons.h"這個檔案。&lt;/p&gt;
&lt;p&gt;Perl是一個高階語言，特點就是除了自己的寫法，還可以安裝大量模組來改變撰寫方式，甚至還繼承許多C語言的標準式。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/eXwWp0J.jpg" &gt;&lt;/p&gt;
&lt;p&gt;安裝方式跟Python相同，複製檔案跟設定環境變數就能使用了。&lt;/p&gt;
&lt;p&gt;作者用了"GD"這個模組來導出"icons.h"。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Y1p6Mck.jpg" &gt;&lt;/p&gt;
&lt;p&gt;Netbeans雖然也有Perl的附加元件，但是功能比SciTE還陽春，就沒使用它了。&lt;/p&gt;
&lt;p&gt;Perl的副檔名是pl，專案中有"png2c.pl"和"pngchar2c.pl"，應該就是將PNG檔導入C語言中的意思，Makefile中是要執行"png2c.pl"並產生出"icons.h"和"icons-proto.h"的樣子，不過"icons-proto.h"不會用到。&lt;/p&gt;
&lt;p&gt;在Netbeans中似乎無法呼叫外部程式，會顯示無法找到Perl指令的訊息。&lt;/p&gt;
&lt;p&gt;可是到CMD中執行時又會發生無法回應的情況，接著make就會因為找不到"icons.h"而無法編譯。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ld.exe does not find libraries&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在exposed資料的Makefile中，g++的參數中需要導入資料庫"-lslvs"。&lt;/p&gt;
&lt;p&gt;而在上一個步驟中，"libslvs.so"確定已經產生，但是找不到的狀況。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/67n3jzL.jpg" &gt;&lt;/p&gt;
&lt;p&gt;網路上普遍都是需要資料連結和打錯名稱，但是好像沒這種狀況，莫非是"libslvs.so"產生失敗，或是並非"slvs"這個名稱？&lt;/p&gt;
&lt;p&gt;Python-Solvespace的作者有特別指名不要使用DLL做副檔名。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;這次學到了編譯程式重要的一環，雖然make的過程中很煩人，也要一直注意是否出錯，但是最後成功時滿有成就感的。&lt;/p&gt;
&lt;p&gt;有些錯誤當下想不出來，不過換一種想法後就能克服許多障礙，訓練眼光放遠也是一件重要的事情。&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="Solvespace"></category><category term="Python-Solvespace"></category></entry><entry><title>40323218日誌 - 105/07/17</title><link href="http://project.mde.tw/blog/40323218ri-zhi-1050717.html" rel="alternate"></link><published>2016-07-17T20:37:00+08:00</published><updated>2016-07-17T20:37:00+08:00</updated><author><name>40323218</name></author><id>tag:project.mde.tw,2016-07-17:blog/40323218ri-zhi-1050717.html</id><summary type="html">&lt;p&gt;V-rep_solvespace_linkages&lt;/p&gt;


&lt;h2&gt;嘗試 vrep_solvespace_linkages&lt;/h2&gt;

&lt;p&gt;&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/linkages.png" weight=600 &gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2&gt;影片教學：&lt;/h2&gt;
&lt;br&gt;
&lt;iframe src="https://player.vimeo.com/video/175117655" width="640" height="480" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt; &lt;p&gt;&lt;a href="https://vimeo.com/175117655"&gt;vrep_solvespace_linkages&lt;/a&gt; from &lt;a href="https://vimeo.com/user44943624"&gt;Li Steven&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2&gt;檔案：&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/g2_files/40323218/solvespace_successful.ttt?raw=true"&gt;solvespace_successful.ttt&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2&gt;心得：&lt;/h2&gt;
&lt;h3&gt;組裝這個物件的重點我認為是在零件的順序和Dummy放置的位置，嘗試了兩天終於作了出來，對零件的從屬關係有比較OK了，有學會dummy的應用，再來就是把這些統整可以試著弄我們的 printer。&lt;/h3&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323230紀錄 - Makefile的建構</title><link href="http://project.mde.tw/blog/40323230ji-lu-makefilede-jian-gou.html" rel="alternate"></link><published>2016-07-16T19:00:00+08:00</published><updated>2016-07-16T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-16:blog/40323230ji-lu-makefilede-jian-gou.html</id><summary type="html">&lt;p&gt;閱讀GNU-Make相關的知識。&lt;/p&gt;
&lt;p&gt;嘗試了解Python-Solvespace的Makefile運作方式。&lt;/p&gt;


&lt;h2&gt;Makefile簡介 :&lt;/h2&gt;

&lt;p&gt;閱讀資料來源：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://mropengate.blogspot.tw/2015/06/makefile-makefile.html" title="mropengate.blogspot.tw"&gt;http://mropengate.blogspot.tw/2015/06/makefile-makefile.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://jeff71321.pixnet.net/blog/post/92143030-makefile%E6%95%99%E5%AD%B8(%E4%B8%80)" title="jeff71321.pixnet.net"&gt;http://jeff71321.pixnet.net/blog/post/92143030-makefile%E6%95%99%E5%AD%B8(%E4%B8%80)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;GNU-Make在開發者工具包有著極其重要的地位，最大的好處就是「自動化編譯」。&lt;/p&gt;
&lt;p&gt;相較於要用shell來執行編譯的Script，GNU-Make可以只針對部分內容作測試，相當有自由度。&lt;/p&gt;
&lt;p&gt;make.exe依靠著Makefile的設定來將整個專案按照原作者的設定，編譯成可執行文件或是連結庫。&lt;/p&gt;
&lt;p&gt;也因為如此，只要是願意加入專案協同的工程師，裝好原作者使用的工具，無論使用哪個編譯程式，就能利用一個make命令，從頭到尾將專案編譯好進行測試或除錯。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;注意事項 :&lt;/h2&gt;

&lt;p&gt;GNU-Make在閱讀一份Makefile時有幾個重點。&lt;/p&gt;
&lt;p&gt;首先若直接執行make指令，會尋找當前目錄中叫"Makefile"或"makefile"的文件。若Makefile並非這兩個名稱（亦能自訂附檔名），可以加上"-f"參數指定Makefile的名稱。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Makefile中包含了&lt;/em&gt;：&lt;/p&gt;
&lt;p&gt;1.&lt;em&gt;顯式規則&lt;/em&gt;：說明如何生成一個或多個文件，有使用工具、依賴文件、使用參數等等。&lt;/p&gt;
&lt;p&gt;2.&lt;em&gt;隱晦規則&lt;/em&gt;：不太瞭解這個功能，大約是利用自動推導原則，可以比較簡略地寫定義，篩選檔案。&lt;/p&gt;
&lt;p&gt;3.&lt;em&gt;變量&lt;/em&gt;：自訂參數的功能，能自由更改位置或目標名稱、使用工具和參數等等。&lt;/p&gt;
&lt;p&gt;4.&lt;em&gt;文件指示&lt;/em&gt;：Makefile之間是可以互相溝通的，也可以透過情況作出判斷。&lt;/p&gt;
&lt;p&gt;5.&lt;em&gt;註解&lt;/em&gt;：Makefile的註解符號是"#"，如果要使用井字符號，必須使用反斜線"#"。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0716_01.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;特別注意，在Makefile中，命令項的起始一定要使用Tab縮排，不可使用空白字元。&lt;/p&gt;
&lt;p&gt;一般撰寫程式的編譯器都能檢視空白字元的類型。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;SciTE&lt;/em&gt;：View -&amp;gt; Whitespace&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0716_02.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Netbeams&lt;/em&gt;：View -&amp;gt; Show Non-printable Characters&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0716_03.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;在此會發現Tab（→）和空白字元（.）的差異。&lt;/p&gt;
&lt;p&gt;不過某些像是SciTE的編譯器，在按下Tab鍵時，會幫使用者轉換成四個空白字元，甚至會用空白字元補齊縮排，所以使用上需要注意。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0716_04.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0716_05.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;Makefile中的目錄分隔號是斜線"/"，換行閱讀符號是反斜線"\"。&lt;/p&gt;
&lt;p&gt;GNU-Make在執行途中遇到錯誤就會停止並跳出，所以必須要整個Makefile和編譯過程都沒有干擾執行問題，才會編譯完畢。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;主要規則 :&lt;/h2&gt;

&lt;p&gt;語法的結構就是目標文件（未生成）後方加上冒號和空格，接著同一行中必須接上會利用到的檔案名稱（不包含工具和include參數的項目）。&lt;/p&gt;
&lt;p&gt;第二行是寫下如何產生目標文件的命令。&lt;/p&gt;
&lt;p&gt;一個項目中有多個檔案時會用一個空白字元分隔。換行時如果想縮排以便閱讀，必須使用空白字元縮排，不然Tab起始的項目都會視為命令。&lt;/p&gt;
&lt;p&gt;而如果命令不能執行時就會中斷操作。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0716_06.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;Makefile中的參數定義和大部分的語言雷同。不過為了明顯標示，大部分使用者習慣大寫字母。&lt;/p&gt;
&lt;p&gt;定義項目後，使用"＄( )"符號括住來使用變數。變數可以是目錄位置、命令名稱、參數名稱，亦有如"＄＄(basename ＄＄(notdir ＄＄@))"內定的用法。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0716_07.jpg" /&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;編譯結果 :&lt;/h2&gt;

&lt;p&gt;途中用Netbeams作輔助檢查檔案關聯性和編寫文件，並make專案。&lt;/p&gt;
&lt;p&gt;不過用cmd下指令也是可行。只是直接打make會用到MinGW的make，必須先指定MSYS的make。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0716_08.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;Python-Solvespace中的Makefile編寫有一些小缺漏，是Tab和空白字元的問題，後來改正就沒問題了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0716_09.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;不過後來在Netbeams編譯外層"Solvespace"時出現了一些問題：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0716_10.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;檢查了一下，似乎中間的檔案"＄(SRFOBJS)"找不到？而"＄(SRFOBJS)"的檔案是從"srf\＄(@B).cpp"和"＄(HEADERS)"產生的。&lt;/p&gt;
&lt;p&gt;其中"srf\＄(@B).cpp"應該就是取下所有\srf資料夾的cpp檔案，配上標頭檔後生成obj檔。途中不知道什麼原因obj檔沒有產生，所以才會無法找到？&lt;/p&gt;
&lt;p&gt;但是只編譯exposed資料夾的Makefile時又有這個問題：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0716_11.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;上網檢查了一下這段的用途是編碼對應，可是語法照常來講應該沒錯才是。&lt;/p&gt;
&lt;p&gt;而且後面對應的檔案導入時都出錯，所以就停止了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0716_12.jpg" /&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;Makefile和cmake的CMakelist.txt一樣都是工程師自己要創建的，所以又是一項工程，不過除了一些內定代號，其他都滿好理解的。&lt;/p&gt;
&lt;p&gt;找了一下Python-Solvespace相關的網站，但是內容都好少。不過在Github的說明已經滿詳盡了，只是倉儲內的資料時間有點久遠，所以要花些時間偵錯。&lt;/p&gt;</summary><category term="SWIG"></category><category term="Solvespace"></category><category term="Python-Solvespace"></category></entry><entry><title>40323218日誌 - 105/07/15</title><link href="http://project.mde.tw/blog/40323218ri-zhi-1050715.html" rel="alternate"></link><published>2016-07-15T20:37:00+08:00</published><updated>2016-07-15T20:37:00+08:00</updated><author><name>40323218</name></author><id>tag:project.mde.tw,2016-07-15:blog/40323218ri-zhi-1050715.html</id><summary type="html">&lt;p&gt;V-rep 程式應用&lt;/p&gt;


&lt;h2&gt;從 irb360 程式中找尋可能用到的並嘗試解釋和整理。 &lt;/h2&gt;

&lt;p&gt;&lt;br&gt;
&lt;h3&gt;
simGetObjectHandle - 對物件命名&lt;br&gt;
&lt;br&gt;
用法： number objectHandle=simGetObjectHandle(string objectName)&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
simSetJointTargetPosition - 設置目標位置(if the joint is in torque/force mode)(motor and position control are enabled)&lt;br&gt;
&lt;br&gt;
用法： number result=simSetJointTargetPosition(number objectHandle,number targetPosition)&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
simGetJointPosition - 得到軸的位置(不能使用在關節上 , 用simGetJointMatrix取代)&lt;br&gt;
&lt;br&gt;
用法： number position=simGetJointPosition(number objectHandle)&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
simSwitchThread - 轉換到另一個程式&lt;br&gt;
&lt;br&gt;
用法： number result=simSwitchThread()&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
simAddStatusbarMessage - 增加一則訊息到狀態欄&lt;br&gt;
&lt;br&gt;
用法： number result=simAddStatusbarMessage(string message)&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
simSetIkElementProperties - 設置性質的特定反向運動元素&lt;br&gt;
&lt;br&gt;
用法：  number result=simSetIkElementProperties(number ikGroupHandle,number tipDummyHandle,number constraints,table_2 precision=nil,table_2 weight=nil&lt;br&gt;
&lt;br&gt;
補充：  IK = Inverse kinematics(在左邊功能區第三個裡)&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
simSetJointMode - 設置joint的操作模式&lt;br&gt;
&lt;br&gt;
用法：  number result=simSetJointMode(number jointHandle,number jointMode,number options)&lt;br&gt;
&lt;br&gt;
補充：  option(現在設定為0是可以被使用，如果設定為1會啟用hybrid mode)&lt;br&gt;
&lt;br&gt;
jointMode&lt;br&gt; 
sim_jointmode_passive&lt;br&gt;
sim_jointmode_motion_deprecated&lt;br&gt;
sim_jointmode_ik&lt;br&gt;
sim_jointmode_ikdependent&lt;br&gt;
sim_jointmode_dependent&lt;br&gt;
sim_jointmode_force&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
simGetObjectAssociatedWithScript - 擷取角本附加到物體處理&lt;br&gt;
&lt;br&gt;
用法：  number objectHandle=simGetObjectAssociatedWithScript (number scriptHandle)&lt;br&gt;
&lt;br&gt;
補充：  scriptHandle = sim_handle_self&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
simRMLMoveToJointPositions - 在同一時間幾個關節一起使用Reflexxes Motion Library type IV移動（驅動）。這功能只能在child scripts中一個thread中運行（因為這是一個阻塞的操作），而且C-API的不可使用。&lt;br&gt;
&lt;br&gt;
用法：number result , table newPos , table newVel , table newAccel , number timeLeft =
simRMLMoveToJointPositions ( table jointHandles , number flags , table currentVel , table currentAccel , table maxVel , table maxAccel , table maxJerk , table targetPos , table targetVel , table direction)&lt;br&gt;
&lt;br&gt;
補充：&lt;br&gt; 
jointHandles: 要驅動的joint&lt;br&gt;
flags: RML flags. -1 for default flags.&lt;br&gt;
currentVel: the current velocity of the joints. Can be nil in which case a velocity vector of 0 is used.&lt;br&gt;
currentAccel: the current acceleration of the joints. Can be nil in which case an acceleration vector of 0 is used.&lt;br&gt;
maxVel: the maximum allowed velocity of the joints&lt;br&gt;
maxAccel: the maximum allowed acceleration of the joints&lt;br&gt;
maxJerk: the maximum allowed jerk of the joints&lt;br&gt;
targetPos: the desired target positions of the joints&lt;br&gt;
targetVel: the desired velocity of the joints at the target. Can be nil in which case a velocity vector of 0 is used.&lt;br&gt;
direction: the desired rotation direction for cyclic revolute joints: 0 for the shortest distance, -x for a movement towards negative values, +x for a movement towards positive values (n=(x-1) represents the number of additional turns). Can be nil or omitted, in which case a value of 0 is used for all joints&lt;br&gt;
&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;p&gt;(待補充)&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323230日誌 - 105/07/15</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050715.html" rel="alternate"></link><published>2016-07-15T19:00:00+08:00</published><updated>2016-07-15T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-15:blog/40323230ri-zhi-1050715.html</id><summary type="html">&lt;p&gt;研究Python-Solvespace。&lt;/p&gt;


&lt;h2&gt;更新Anaconda3 :&lt;/h2&gt;

&lt;p&gt;從官方網站下載最新的Anaconda 3，配有Python 3.5.2。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.continuum.io/downloads" title="continuum.io"&gt;https://www.continuum.io/downloads&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用Path指令檢查環境變數。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0715_01.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;確定無誤後放入可攜式環境中，並把原本的Python 3.5移除，將start.bat的環境位置改成Anaconda的資料夾。&lt;/p&gt;
&lt;p&gt;接著再檢查Anaconda程式的運作狀態。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0715_02.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;安裝了其他工具，也包含Leo 5.3。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0715_03.jpg" /&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;說明 :&lt;/h2&gt;

&lt;p&gt;&lt;a href="https://github.com/BBBSnowball/python-solvespace" title="github.com"&gt;Python-Solvespace&lt;/a&gt;是由BBBSnowball所開發的Solvespace函式庫，另外能調用Solid-python來協助運算。&lt;/p&gt;
&lt;p&gt;Python-Solvespace最後一次更新是在2013年，所以使用的是Python 2，SWIG可能也是舊版的。&lt;/p&gt;
&lt;p&gt;而根據協同者們留下的"VbDemo.vb"紀錄，應該是用VC來編譯它的。&lt;/p&gt;
&lt;p&gt;若要使用Solid-python，必須用"git submodule update --init"指令額外下載它，不然只有空資料夾。&lt;/p&gt;
&lt;p&gt;不過目前沒有要使用Solid-python，所以可以不用下載。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0715_04.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;按照Readme的說明，要用make指令來編譯檔案。&lt;/p&gt;
&lt;p&gt;但是在make的時候出錯了，顯示"missing separator. Stop."的錯誤，查了下面的網站，貌似是make.exe的新版本讀取舊的Makefile的問題，必須改寫他們的Makefile或使用舊版的MSYS。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.crifan.com/error_missing_separator_stop_while_make_in_windows_cmd/" title="crifan.com"&gt;http://www.crifan.com/error_missing_separator_stop_while_make_in_windows_cmd/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而顯示的錯誤如下圖：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0715_05.jpg" /&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;與Whitequark的版本比較 :&lt;/h2&gt;

&lt;p&gt;不過Python-Solvespace有留下來interface的檔案，但是它的檔案結構已經跟Whitequark的版本不一樣了，所以也不能直接讓interface對應新版的檔案來創建。&lt;/p&gt;
&lt;p&gt;好消息是SWIG的interface檔案改變不大，新版仍能使用。只要切換到\exposed資料夾，使用下列指令就能生成"slvs_wrap.cxx"。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
swig -c++ -python -py3 slvs.i
&lt;/pre&gt;

&lt;p&gt;新版有用到cmake來建置檔案，但是Python-Solvespace沒有，所以沒有CMakelist的清單。而CMakelist是要手動編寫的，視規模大小來分配。&lt;/p&gt;
&lt;p&gt;Python-Solvespace似乎是只有原本Solvespace的"src"資料夾部分（不過外面原本就是給編譯器介紹用）。&lt;/p&gt;
&lt;p&gt;並將"exposed"、"extlib"、"win32"等資料夾放了進來，並且將總標頭檔"slvs.h"和DLL的"lib.cpp"加入"exposed"中，讓CDemo成為主幹，調用Solvespace裡的約束函式。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0715_06.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;但是"exposed"中除了原本的CDemo，還有一個h++的標頭檔"slvs_python.hpp"、一個"DOC.txt"說明Python要如何呼叫編譯好的函式列表，以及一些Python的小程式。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;test.py :&lt;/h2&gt;

&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0715_07.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;py檔總共有3個，其中一個是使用Solid-python的呼叫工具，其他的"test.py"分別用"2.scad"和"3.scad"命名。&lt;/p&gt;
&lt;p&gt;檢查了一下Python-Solvespace附上的py檔，最後作者做了3個測試，並寫下了一些註解。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0715_08.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;第一個"test.py"，展示了Python要如何取用slvs.dll的函式，長得跟原先的"CDemo.c"十分相似。&lt;/p&gt;
&lt;p&gt;在這裡，可以注意到SWIG轉換後的函式名稱還是一樣，用法也極其相似。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0715_09.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;第二個"test2.scad.py"匯入了slvs和solid。&lt;/p&gt;
&lt;p&gt;由於Python只要在附近資料中尋找到宣告的項目就可運作，所以不太確定它們的副檔名究竟是DLL還是SO、PYD之類的連結庫或Python程式。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0715_10.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;第三個"test3.scad.py"明顯使用了"slvs_solid.py"的內容，不過只有稍微閱讀過Solid-python的Readme，所以不太知道它的函式，但是看似比Solvespace更方便。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0715_11.jpg" /&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;這次在Python-Solvespace碰上一些小瓶頸。&lt;/p&gt;
&lt;p&gt;主要是MSYS的Makefile問題，論壇上滿多人討論它在編譯時的障礙，有時連參數前加個空格都會顯示錯誤，無法進行。&lt;/p&gt;
&lt;p&gt;而Python-Solvespace應該是用不到cmake（因為原作者是用VC），如果需要用到Netbeams，就要自行撰寫一份CMakelist，或是在編譯器中捨棄它的功能。&lt;/p&gt;
&lt;p&gt;至於需要Python 2轉Python 3的部分比較少，除非要動用Solid-python的內容。&lt;/p&gt;</summary><category term="SWIG"></category><category term="Solvespace"></category></entry><entry><title>40323231日誌 - 105/07/14</title><link href="http://project.mde.tw/blog/40323231ri-zhi-1050714.html" rel="alternate"></link><published>2016-07-14T21:00:00+08:00</published><updated>2016-07-14T21:00:00+08:00</updated><author><name>40323231</name></author><id>tag:project.mde.tw,2016-07-14:blog/40323231ri-zhi-1050714.html</id><summary type="html">&lt;p&gt;3DP碰到的問題及解決&lt;/p&gt;


&lt;h3&gt;第一次組裝3D列印機，所以各個零件和電子元件的功用都不知道，所以只能從型號去著手，知道並了解運用。&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h3&gt;在研究電子板的時候發現，熱床是時麼?而且我手邊怎麼沒有熱床?&lt;/h3&gt;
&lt;h3&gt;解決:我們有熱床，只是我們的跟網路上和現有的3DP不一樣。它的功用是防止成品翹邊，由於料出來是熱的，經過板子和空氣冷卻導致成品收縮，所以熱床需給予溫度，減輕翹邊，可是不能完全避免，而且會因材料不同，需要的溫度也不同(我們的材料PLA大約60度，)。電壓不能輕易更改或太高，因為電壓高一倍，功率大四倍，所以一開始要確定給定的電壓。&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;在接限位開關線路的時候發現，在夢工廠老師接的線路和網路上的不一樣，三條線路分別為"+""-""S"顏色分別為"紅""藍""黑"，夢工老師接的是"+"接紅，"-"接藍，"S"接黑。網路是"+"接紅，"-"接黑，"S"接藍。而且3個限位開關的線路有的接3條，有的接2條，很混亂，沒有頭緒。&lt;/h3&gt;
&lt;h3&gt;問題:1. "+""-""S"如何接?  2.為何線路有的接兩條有的接三條?&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;限位開關分兩種:&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;1. 機械微動開關接法&lt;/h3&gt;
&lt;h4&gt;機械微動開關只需接2個腳位的：單純使用微動開關當作限位器，那一定要接RAMPS上的 "S" 跟 "-" 腳位。絕對不要把3個腳位都接了，如果不小心接了3個腳位，那在觸發時會發生火花，會把5V穩壓 IC燒毀。&lt;/h4&gt;
&lt;/br&gt;
&lt;h3&gt;2. 光學限位開關接法(我們的)&lt;/h3&gt;
&lt;h4&gt;光學限位開關則是需要用到3條線，接到RAMPS上的"S"、"-"及"+" 3個腳位。&lt;/h4&gt;
&lt;/br&gt;
&lt;h3&gt;1.S為藍，+為紅，-為黑&lt;/h3&gt;
&lt;h3&gt;2.常開型和常關型只有微動開關才有，所以光學開關一定要3調都接&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;今天進度&lt;/h3&gt;
&lt;h4&gt;組裝 3DP，將缺少的材料抄寫下來，將跟工廠管理員詢問，使用VREP，看組員的所寫的網誌並實際操作&lt;/h4&gt;&lt;/p&gt;</summary><category term="3DP"></category></entry><entry><title>40323218日誌 - 105/07/14</title><link href="http://project.mde.tw/blog/40323218ri-zhi-1050714.html" rel="alternate"></link><published>2016-07-14T20:37:00+08:00</published><updated>2016-07-14T20:37:00+08:00</updated><author><name>40323218</name></author><id>tag:project.mde.tw,2016-07-14:blog/40323218ri-zhi-1050714.html</id><summary type="html">&lt;p&gt;V-rep&lt;/p&gt;


&lt;h2&gt;翻譯文章重點&lt;/h2&gt;

&lt;p&gt;&lt;br&gt;
&lt;h2&gt;原文章網址：&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm "&gt;http://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm &lt;/a&gt;&lt;/p&gt; 
&lt;br&gt;
&lt;h2&gt;Building the visible shapes：&lt;/h2&gt;
&lt;br&gt;
&lt;h3&gt;1. Automatic mesh division：&lt;br&gt;
[Menu bar --&amp;gt; Edit --&amp;gt; Grouping/Merging --&amp;gt; Divide selected shapes]&lt;br&gt;
(自動分割物件，有時候會無作用)&lt;br&gt;
[Menu bar --&amp;gt; Edit -&amp;gt; Grouping/Merging --&amp;gt; Merge selected shapes]&lt;br&gt;(使選擇的物件組合在一起)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;2. Extract the convex hull：&lt;br&gt;
[Menu bar --&amp;gt; Edit --&amp;gt; Morph selection into convex shapes]&lt;br&gt;
(使物件轉換成convex hull)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;3. Decimate the mesh：&lt;br&gt;
[Menu bar --&amp;gt; Edit --&amp;gt; Decimate selected shape...]&lt;br&gt;
(減少mesh三角形量)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;4. Remove the inside of the mesh：&lt;br&gt;
[Menu bar --&amp;gt; Edit --&amp;gt; Extract inside of selected shape]&lt;br&gt;
(此功能是基於視覺傳感器，可以依靠設定得到更多或更少滿意的結果。)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;上述功能沒有先後順序(除了第一項應該先嘗試)，主要取決於我們如何嘗試精簡mesh。&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;下圖說明上述功能應用到imported mesh（沒有第一項）：&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/vrep1.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;再來我們要分割imported mesh，有兩種方式可使用。&lt;br&gt;&lt;br&gt;
1. Automatic mesh division：跟上面一樣
&lt;br&gt;
2. Manual mesh division：這使用 triangle edit mode (左邊功能列第六個)，選擇你要的物體的三角形，再點 Extract shape，他會投影物件出來，再把原先選擇的三角形刪除。&lt;/h3&gt;
&lt;br&gt;
&lt;h2&gt;Building the joints&lt;/h2&gt;&lt;br&gt;
&lt;h3&gt;再來我們要創建 joint，先 import mesh，使用 triangle edit mode 使物件三角形化。&lt;/h3&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/vrep2.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;我們需要使 joint 在圓心中間，所以我們點選圓形的三角形，點選 Extract cylinder 或 Extract shape ，他會在選擇的三角形上投影一個圓形出來。&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt; 右鍵→Add→Joint→Revolute(創建一個Revolute joint)，
再來我們點Revolute joint、Ctrl點投影的圓型，點 Position/Translation 按鈕，然後在 Object/item position section裡，我們點 Apply to selection (使兩物體位置相同)。再來我們點Orientation/Rotation 按鈕，然後在Object/item orientation section裡，我們點 Apply to selection(使兩物體坐標軸相同)。&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/vrep3.png" weight=600 &gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/vrep4.png" weight=600 &gt;
&lt;br&gt;
&lt;h2&gt;Building the dynamic shapes&lt;/h2&gt;
&lt;br&gt;
&lt;h3&gt;如果我們想要使 Robot 作動，那麼我們就需要適當地創建/配置形狀。形狀可以是：&lt;br&gt;&lt;br&gt;
1. dynamic or static：&lt;br&gt;
dynamic 是動態，如果這個形狀是動態的，它將會有重量會往下掉，也會對力/力矩造成影響。&lt;br&gt;
static是靜態，他跟 dynamic 相反，他會固定在位置上或隨著
運動移動。&lt;br&gt;&lt;br&gt;
2. respondable or non-respondable：&lt;br&gt;
respondable shape 是會跟其他的 respondable shape 造成碰撞效應，他們或其對撞機，將會影響其運動(如果它們是動態的) 。&lt;br&gt;non-respondable shapes 是相反，他們不會造成碰撞運動。&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;respondable shape應盡可能簡單，以允許快速和穩定的模擬。一個物理引擎將能夠模擬以下5種不同程度的速度和穩定的形狀：&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;1. Pure shapes：&lt;br&gt;
 [Menu bar --&amp;gt; Add --&amp;gt; Primitive shape]&lt;br&gt;
一個Pure shapes是穩定的，並由物理引擎非常有效地處理。Pure shapes在幾何限制：大部分長方體，圓柱體或球體。&lt;br&gt;
&lt;br&gt;
2. Pure compound shapes：&lt;br&gt;
 [Menu bar --&amp;gt; Edit --&amp;gt; Grouping/Merging --&amp;gt; Group selected shapes]&lt;br&gt;
它是由多個Pure shape組合而成的，功能跟Pure shape雷同。
&lt;br&gt;
&lt;br&gt;
3. Convex shapes：&lt;br&gt;
[Menu bar --&amp;gt; Add --&amp;gt; Convex hull of selection] &lt;br&gt;
[Menu bar --&amp;gt; Edit --&amp;gt; Morph selection into convex shapes]&lt;br&gt;
Convex shapes會有點不太穩定，當物理引擎處理時需要多一點點計算時間。它允許一個比純形狀更一般的幾何形狀（唯一的要求：它必須是 convex）。
&lt;br&gt;
&lt;br&gt;
4. Compound convex shapes, or convex decomposed shapes&lt;br&gt;
 [Menu bar --&amp;gt; Edit --&amp;gt; Grouping/Merging --&amp;gt; Group selected shapes]&lt;br&gt;
[Menu bar --&amp;gt; Add --&amp;gt; Convex decomposition of selection...]&lt;br&gt;
[Menu bar --&amp;gt; Edit --&amp;gt; Morph selection into its convex decomposition...]&lt;br&gt;
它是由多個convex shapes組合而成的，功能跟convex shapes雷同。
&lt;br&gt;
&lt;br&gt;
5. Random shapes：&lt;br&gt;
一個Random shapes是一個形狀不是convex也不是pure。它一般具有性能差（計算速度和穩定性）。盡可能地避免使用隨機的形狀。&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;因此，優先順序是：pure shapes → pure compound shapes → convex shapes → compound convex shapes → random shapes。&lt;/h3&gt;&lt;br&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323230日誌 - 105/07/14</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050714.html" rel="alternate"></link><published>2016-07-14T19:00:00+08:00</published><updated>2016-07-14T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-14:blog/40323230ri-zhi-1050714.html</id><summary type="html">&lt;p&gt;試圖解決SWIG問題&lt;/p&gt;


&lt;h2&gt;撰寫批次檔 :&lt;/h2&gt;

&lt;p&gt;依照&lt;a href="http://www.ittc.ku.edu/kusp/kusp_docs/kusp_swig_guide/index.html" title="ittc.ku.edu"&gt;http://www.ittc.ku.edu/kusp/kusp_docs/kusp_swig_guide/index.html&lt;/a&gt;提供的gcc指令，撰寫了3個批次檔來執行。&lt;/p&gt;
&lt;p&gt;第一個命名為interface.bat，用來讓swig生成"_wrap.c"檔，並建立"build"和"dist"兩個資料夾。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
@echo off
set interface_name=example

echo 編譯接口
swig -python -py3 %interface_name%.i
echo 編譯完成
pause

REM MKDIR
echo 正在建立目錄
MKDIR "build"
MKDIR "dist"
echo 目錄已建立
pause
&lt;/pre&gt;

&lt;p&gt;第二個是pyd.bat，主要是下gcc的編譯指令並執行runme.py，不過不知道修改後正不正確。&lt;/p&gt;
&lt;p&gt;原理是將example.c和它的_wrap.c參照W:/Python35/include的內容變成".o"檔，再將它們參照W:/Python35/libs/libpython35.a編譯成".pyd"檔。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
@echo off
set target_name=example
set module_name=example

echo 正在建立暫存檔
gcc -c -g %target_name%.c %target_name%_wrap.c -IW:/Python35/include
move %target_name%.o build\%target_name%.o
move %target_name%_wrap.o build\%target_name%_wrap.o
echo 暫存檔建立
pause

echo 正在建立PYD
gcc -shared build/%target_name%.o build/%target_name%_wrap.o W:/Python35/libs/libpython35.a -o dist/%module_name%.pyd
echo PYD建立

copy /Y runme.py dist\runme.py

python dist\runme.py

pause
&lt;/pre&gt;

&lt;p&gt;第三個式失敗後重來的清除工具，刪掉前面建立的檔案和成果檔。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
@echo off
set target_name=example

echo RMDIR...
RMDIR /S /Q .\build
RMDIR /S /Q .\dist

echo DEL...
del /F /S /Q %target_name%_wrap.c
del /F /S /Q %target_name%.py

pause
&lt;/pre&gt;

&lt;p&gt;檔案如下圖：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0714_01.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;將interface.bat和pyd.bat分開的原因是為了檢察途中example.i和example_wrap.c是否出了問題。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;執行測試 :&lt;/h2&gt;

&lt;p&gt;之前的example.c和example.i內容並沒有更動。&lt;/p&gt;
&lt;p&gt;第一次執行後，發現會出現以下錯誤：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0714_02.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;然後就發現example_wrap.c中的這句錯誤了，多了一個底線符號，刪除後就能導入了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0714_03.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;這個錯誤經過搜索後是SWIG本身的問題，要解決的話必須重新編譯原始碼。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0714_04.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;但是這個舉動實在是太耗費時間了，所以後來放棄了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0714_05.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;不過更改那行後，runme.py就可以導入example.pyd，不過卻會出現TypeError，如下圖：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0714_06.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;估計是這裡有錯誤：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0714_07.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;不過不知道怎麼調整。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;SWIG在自身的編譯上有點小錯誤，但是有些地方因為不了解Python的模組，所以不知道要怎麼修改。&lt;/p&gt;
&lt;p&gt;另外有些不知道C語言的格式轉換是怎麼套用到Python的，所以在Python.h的函式不知該怎麼用。&lt;/p&gt;</summary><category term="SWIG"></category></entry><entry><title>40323230日誌 - 105/07/13</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050713.html" rel="alternate"></link><published>2016-07-13T19:00:00+08:00</published><updated>2016-07-13T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-13:blog/40323230ri-zhi-1050713.html</id><summary type="html">&lt;p&gt;Python 3.5.2軟體更新&lt;/p&gt;


&lt;h2&gt;軟體更新目標 :&lt;/h2&gt;

&lt;p&gt;之前W:沒安裝Python和Leo，所以暫時把Y:的複製過來用。&lt;/p&gt;
&lt;p&gt;以W:為主，Y:用來撰寫網誌暫不需要更新。&lt;/p&gt;
&lt;p&gt;1.Python 3.5及之前安裝的套件。&lt;/p&gt;
&lt;p&gt;2.Leo 5.3正式版。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;Python及套件更新步驟 :&lt;/h2&gt;

&lt;p&gt;將W:槽的Python 3.4.4 RC1更新至最新的3.5.2。&lt;/p&gt;
&lt;p&gt;Python 3.5.2下載處：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.python.org/downloads/" title="python.org"&gt;https://www.python.org/downloads/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;刪除Python34資料的所有內容後，將安裝完的Python35放進W:內，並將start.bat內的Python34位置全數改成Python35。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0713_01.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;在Y:槽中執行以下指令以取得舊有的軟體資訊，存成名為rq.txt的清單。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
pip freeze &gt; rq.txt
&lt;/pre&gt;

&lt;p&gt;清單中列的就是Python 3.4安裝的套件版本。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0713_02.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;進入Python 3.5後使用pip指令時出現類似"Fatal error in launcher"的訊息，原因是官方的pip版本較舊。&lt;/p&gt;
&lt;p&gt;如果不更新，只能用"python -m pip"的方式驅動它，所以先命令它為自己升級。&lt;/p&gt;
&lt;pre&gt;
python -m pip install pip --upgrade
&lt;/pre&gt;

&lt;p&gt;然後再利用Y:槽傳來的清單安裝，不過之前的Leo 5.1沒有在pip的下載網站裡，5.3版也要從Leo的官方下載，所以暫時先把leo剔除。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0713_03.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;接著利用下列指令更新：&lt;/p&gt;
&lt;pre&gt;
pip install -r rq.txt
&lt;/pre&gt;

&lt;p&gt;就會裝回所有的套件了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0713_04.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;使用下列指令可以查看已安裝的套件。&lt;/p&gt;
&lt;p&gt;而只要在安裝時加入--upgrade參數就能更新，不過目前沒有全部更新的指令。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
//已安裝套件
pip freeze
//過期套件
pip list --outdated
&lt;/pre&gt;

&lt;hr&gt;

&lt;h2&gt;Leo更新步驟 :&lt;/h2&gt;

&lt;p&gt;至於安裝Leo，到&lt;a href="http://sourceforge.net/projects/leo/files/Leo/" title="sourceforge.net"&gt;http://sourceforge.net/projects/leo/files/Leo/&lt;/a&gt;下載5.3的安裝檔，並暫時解壓縮到根目錄。&lt;/p&gt;
&lt;p&gt;接著進入\Leo-5.3-final\leo\dist資料夾，執行下面指令：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
python setup.py install
&lt;/pre&gt;

&lt;p&gt;安裝完後，接著就能把解壓縮的檔案刪除了。&lt;/p&gt;
&lt;p&gt;不過在pip的紀錄中還是5.0 Bata2的樣子。&lt;/p&gt;
&lt;p&gt;新版的Leo介面（設定檔複製之前的）。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0713_05.jpg" /&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;上次的swig還是沒成功，"_wrap.c"中似乎還要加一些python3的判斷式。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://python3porting.com/cextensions.html#module-initialization" title="python3porting.com"&gt;http://python3porting.com/cextensions.html#module-initialization&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這裡的作者描述還是有點看不懂，雖然下了-py3的指令，但是設定還是沒調。&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323230日誌 - 105/07/12</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050712.html" rel="alternate"></link><published>2016-07-12T19:00:00+08:00</published><updated>2016-07-12T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-12:blog/40323230ri-zhi-1050712.html</id><summary type="html">&lt;p&gt;瞭解SWIG的用法。&lt;/p&gt;


&lt;h2&gt;軟體修正 :&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;NetBeans&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;為NetBeans安裝python的附加元件，使其可以編譯python文件。&lt;/p&gt;
&lt;p&gt;這些附加元件還包含了jython2.7.0。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0712_01.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;SWIG&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;上次載的版本沒有Windows使用的可執行檔，需要從原始code編譯太麻煩了，所以從以下網址下載了Windows使用的版本。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://sourceforge.net/projects/swig/files/swigwin/" title="sourceforge.net"&gt;https://sourceforge.net/projects/swig/files/swigwin/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解壓縮後就有可執行檔了，再把它的所在目錄加入start.bat的環境參數中。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0712_02.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;接著就能用它下參數了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0712_03.jpg" /&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;SWIG簡介 :&lt;/h2&gt;

&lt;p&gt;SWIG的功能就是利用自己的Interface檔案".i"，產生出一個"_wrap.c"檔，如果DLL專案一起將這個".c"編譯的話，就可以讓其他高階語言呼叫了。&lt;/p&gt;
&lt;p&gt;SWIG內有個\Examples資料夾，裡面有所有支援語言的轉換函式，參照它們的格式來撰寫自己的Interface，放在專案中。&lt;/p&gt;
&lt;p&gt;諸如：D語言、java、javascript、lua、php、python、ruby。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0712_04.jpg" /&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;練習應用 :&lt;/h2&gt;

&lt;p&gt;參考範例：&lt;/p&gt;
&lt;p&gt;/Examples/python/simple/index.html&lt;/p&gt;
&lt;p&gt;先寫一個".c"程式碼。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
/* File : example.c */

/* A global variable */
double Foo = 3.0;

/* Compute the greatest common divisor of positive integers */
int gcd(int x, int y) {
  int g;
  g = y;
  while (x &gt; 0) {
    g = x;
    x = y % x;
    y = g;
  }
  return g;
}
&lt;/pre&gt;

&lt;p&gt;然後再寫一個Interface的".i"文件。&lt;/p&gt;
&lt;p&gt;至於格式可能要參考手冊的其他內容。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
/* File: example.i */
%module example

extern int gcd(int x, int y);
extern double Foo;
&lt;/pre&gt;

&lt;p&gt;然後用cmd到/Examples/python/simple中下指令：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
swig -python example.i
&lt;/pre&gt;

&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0712_05.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;然後simple資料夾中就會產生example_wrap.c與example_wrap.py檔，再拿進編譯器Build。&lt;/p&gt;
&lt;p&gt;但是Netbeans卻無法編譯檔案，照常來說最新的SWIG已經支援到Python 3.5，還是說有參數需要調整。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0712_06.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;而且在動態連結庫的專案中，不知道怎麼調Build的參數成為pyd檔。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;SWIG的操作大致知道了，但是仍有些許不瞭解的地方。&lt;/p&gt;
&lt;p&gt;像是Interface的檔案撰寫，有將網路上一些範例存起來，但是下swig的指令時就出現".i"文件格式錯誤的訊息。&lt;/p&gt;
&lt;p&gt;而在Netbeans裡要如何設定gcc編譯成pyd呢？在CMD裡下了跟2015cp.leo按鈕一樣的參數，可是好像都會出現上面Build的錯誤。&lt;/p&gt;
&lt;p&gt;另外，按照SWIG的邏輯，萬一使用者的Python版本比它還低，它會修改編譯語法嗎？覺得在編譯時的錯誤可能是3.4到3.5之間的衝突。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;今天上網找資料的時候，發現了ctype，可以讓python直接讀取DLL的文件，好像是SWIG之後的產物，只是Python本身必須加裝模組。&lt;/p&gt;</summary><category term="SWIG"></category></entry><entry><title>40323218日誌 - 105/07/11</title><link href="http://project.mde.tw/blog/40323218ri-zhi-1050711.html" rel="alternate"></link><published>2016-07-11T20:37:00+08:00</published><updated>2016-07-11T20:37:00+08:00</updated><author><name>40323218</name></author><id>tag:project.mde.tw,2016-07-11:blog/40323218ri-zhi-1050711.html</id><summary type="html">&lt;p&gt;V-rep&lt;/p&gt;


&lt;h4&gt;嘗試四連桿機構&lt;/h4&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h1&gt;&lt;h3&gt;理想狀態：&lt;/h3&gt;&lt;/h1&gt;
&lt;h1&gt;&lt;br&gt;&lt;/h1&gt;
&lt;h3&gt;前期嘗試：&lt;/h3&gt;

&lt;p&gt;&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/before.gif" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;前期階級排列：&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step10.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;查詢資料：&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step11.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;(在兩個dynamic item之間不能有static item)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;修改後：&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step12.png" weight=600 &gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/after.gif" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;未來嘗試：製作搖擺機構&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;參考網站：http://www.coppeliarobotics.com/helpFiles/en/jointDescription.htm &lt;/h3&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323230練習 - 105/07/11</title><link href="http://project.mde.tw/blog/40323230lian-xi-1050711.html" rel="alternate"></link><published>2016-07-11T19:00:00+08:00</published><updated>2016-07-11T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-11:blog/40323230lian-xi-1050711.html</id><summary type="html">&lt;p&gt;使用2015cp範本練習".py"呼叫".pyd"。&lt;/p&gt;


&lt;h2&gt;編譯出Python的動態連結庫 :&lt;/h2&gt;

&lt;p&gt;從&lt;a href="https://github.com/coursemdetw/2015cp" title="coursemdetw/2015cp"&gt;https://github.com/coursemdetw/2015cp&lt;/a&gt;下載老師的範本練習。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0710_01.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;C程式的部分分成pymod和pyfun。&lt;/p&gt;
&lt;p&gt;這兩組底下都有3個Node，分別是編譯Python動態連結庫用的button、呼叫用的Python程式和一個C++編成的函式。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0710_02.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;button裡的內容如下：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
...
# compile
os.system("Z:/C/MinGW/bin/gcc.exe -c -g -IV:/IDE/Python33/include  -MMD -MP -MF build/"+target_name+".o.d -o build/"+target_name+".o "+filename)
# link 因為 .c 程式中起始為 PyInit_sum, 因此
os.system("Z:/C/MinGW/bin/gcc.exe -shared -o dist/"+module_name+".pyd build/"+target_name+".o V:/IDE/Python33/libs/libpython33.a")
g.es("done")
&lt;/pre&gt;

&lt;p&gt;在執行時顯然對應不到W:槽的MinGW和Python34，所以必須改一下它的指令。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
...
# compile
os.system("gcc -c -g -IW:/Python34/include  -MMD -MP -MF build/"+target_name+".o.d -o build/"+target_name+".o "+filename)
# link 因為 .c 程式中起始為 PyInit_sum, 因此
os.system("gcc -shared -o dist/"+module_name+".pyd build/"+target_name+".o W:/Python34/libs/python34.lib")
g.es("pymod done")
&lt;/pre&gt;

&lt;p&gt;而另一邊的pyfun同理。&lt;/p&gt;
&lt;p&gt;接著就能在\dist資料夾中編譯出sum.pyd和pyfun.pyd了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0710_03.jpg" /&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;使用mypy.py :&lt;/h2&gt;

&lt;p&gt;接著回到@edit programs/dist/mypy.py和mypy2.py的兩個Node，只要在.leo中存檔就能建立和編輯它們。&lt;/p&gt;
&lt;p&gt;mypy.py中導入sum，並使用它裡面的函式sum()。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
print(sum.sum(1, 30))
&lt;/pre&gt;

&lt;p&gt;在sum.pyd中，函式sum()是sum2()在sum.pyd中被定義的外部名稱，由以下可知。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
// 定義內部運算的函式內容
int sum2(int a, int b)
{
    return a+b;
}

// sum 函式的 interface
static PyObject* mod_sum(PyObject *self, PyObject *args)
{
    int a;
    int b;
    int s;
    // ii 表示兩個輸入變數都是整數
    if (!PyArg_ParseTuple(args,"ii",&amp;a,&amp;b))
       return NULL;
    // 這裡的 sum2 則是內部的函式定義, 與外部呼叫模組或函式名稱沒有直接關係
    s = sum2(a,b);
    // i 表示 s 為整數
    return Py_BuildValue("i",s);
}

// 這裡的 sum 是外部模組的呼叫名稱, 而 mod_sum 則是內部的呼叫名稱 (即 interface function)
// Mod_Methods 為函式 (方法) 結構定義
static struct PyMethodDef Mod_Methods[] = {
    {"sum", mod_sum, METH_VARARGS, "Description.."},
    {NULL,NULL,0,NULL}
};
&lt;/pre&gt;

&lt;p&gt;sum2()函式回傳的是兩個輸入值（pyd內部名為a和b），所以mypy.py收到後會顯示在畫面上。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0710_04.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;另一邊的mypy2.py是使用pyfun.pyd，不過有兩個檔案太麻煩了，乾脆讓mypy.py導入兩個pyd就好了。&lt;/p&gt;
&lt;p&gt;這次是加入一段字串。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
print(pyfun.pyfun("我的字串"))
&lt;/pre&gt;

&lt;p&gt;在pyfun.pyd中，pyfun()的外部名稱和它同名，在它的函式中，建立了一個指標to_who，偵測使用動態連結庫的對象，並把輸入進來的字串傳回。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
pyfun(PyObject *self,PyObject *args)
{
    const char *to_who;
    if(!PyArg_ParseTuple(args,"s",&amp;to_who))
        return NULL;
     // pyfun 函式會將輸入字串變數傳回
    return PyUnicode_FromString(to_who);
}
&lt;/pre&gt;

&lt;p&gt;執行後的結果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0710_05.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;不過這兩個pyd的結尾不太一樣。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;sum.pyd&lt;/em&gt;&lt;/p&gt;
&lt;pre class="brush: c"&gt;
// 模組啟始, PyInit_ 後必須使用"名稱".pyd 中的模組名稱, 以便啟動
// 換言之, 若編譯連結後的動態模組名稱為 sum.pyd, 則此地的起始函式名稱必須為 PyInit_sum
PyMODINIT_FUNC
PyInit_sum(void)
{
    // 建立模組的起始, 輸入為模組結構名稱之 address
    (void) PyModule_Create(&amp;ModMethods);
}
&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;pyfun.pyd&lt;/em&gt;&lt;/p&gt;
&lt;pre class="brush: c"&gt;
// 此 pyd 必須命名為 pyfun.pyd, 因為必須與 PyInit_後的名稱相同
PyInit_pyfun(void)
{
    PyObject *m;
    m = PyModule_Create(&amp;moduledef);
    return m;
}
&lt;/pre&gt;

&lt;p&gt;意思似乎是一樣的，不過pyfun.pyd將PyModule_Create當作回傳值回傳了，不知道用意為何。&lt;/p&gt;
&lt;p&gt;若要瞭解Python的函式用法，應該要查閱Python.h或是相關說明才能明白。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;延伸應用 :&lt;/h2&gt;

&lt;p&gt;只使用既定的範本實在是太簡略了，所以試著在pyd中加一些自己寫的函式。&lt;/p&gt;
&lt;p&gt;在sum中加入新的函式sum3，並讓它的傳回值設定為a和b相加後開平方根，再乘上10。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0710_06.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;添加了下列指令：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
//導入
#include "math.h"
//宣告
int sum3(int a, int b);
//副程式sum3
int sum3(int a, int b)
{
    return sqrt(a+b)*10;
}
//定義輸入值和sum3的外部名稱score
static PyObject* mod_score(PyObject *self, PyObject *args)
{
    int a;
    int b;
    int t;
    if (!PyArg_ParseTuple(args,"ii",&amp;a,&amp;b))
       return NULL;
    t = sum3(a,b);
    return Py_BuildValue("i",t);
}
&lt;/pre&gt;

&lt;p&gt;並在PyMethodDef Mod_Methods[]中再新增一串：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
{"score", mod_score, METH_VARARGS, "Description.."},
&lt;/pre&gt;

&lt;p&gt;接著在mypy.py中呼叫sum.score()就行了。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;Leo的搜尋功能和復原功能真的不太實在。常常搜尋時就跳到其他Node去，搜尋目標也要每次都重新調整；復原直接還原到存檔前的樣子，所以用它來編譯程式真的滿吃力的。&lt;/p&gt;
&lt;p&gt;這次使用的是Python，所以SciTE和只能寫C語言的NetBeans幫不上忙，因為無法呼叫Python.h。說不定設定環境係數可以奏效？&lt;/p&gt;
&lt;p&gt;不然只靠Leo編輯，它的函式分類也不是很清楚，常常不知道Python.h中的函式原型用法是甚麼，不像NetBeans可以連進去查看stdio.h或是windows.h所引用的函式。&lt;/p&gt;</summary><category term="CDemo"></category></entry><entry><title>40323230練習 - 105/07/10</title><link href="http://project.mde.tw/blog/40323230lian-xi-1050710.html" rel="alternate"></link><published>2016-07-10T19:00:00+08:00</published><updated>2016-07-10T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-10:blog/40323230lian-xi-1050710.html</id><summary type="html">&lt;p&gt;由於不熟悉動態連結庫的運作方式，先練習C語言呼叫動態連結庫，之後再研究python的方式。&lt;/p&gt;


&lt;h2&gt;編譯出C的動態連結庫 :&lt;/h2&gt;

&lt;p&gt;找到了一個別人學校的DLL簡單範例。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pws.niu.edu.tw/~ttlee/sp.100.2/dll/" title="niu.edu.tw"&gt;http://pws.niu.edu.tw/~ttlee/sp.100.2/dll/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;雖然NetBeans在截圖時很容易閃退，但是Visual Studio的專案又會把檔案搞得太複雜，所以就將就點使用NetBeans了。&lt;/p&gt;
&lt;p&gt;使用NetBeans建立了一個C/C++ Dynamic Library。&lt;/p&gt;
&lt;p&gt;若沒有預設Make file，也不是二進位資料，又需要動態連結庫的話，這個類別的專案是項很好的選擇。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/vLbLF1a.jpg" &gt;&lt;/p&gt;
&lt;p&gt;新建完成後，Projects的欄位就會幫使用者分類：&lt;/p&gt;
&lt;p&gt;Header Files, Resource Files, Source Files, Test Files.&lt;/p&gt;
&lt;p&gt;這些分類預設是空的，而在NetBeans中沒有分類的檔案是不能編譯的。&lt;/p&gt;
&lt;p&gt;如果要讓既有的檔案歸類，在想添加的目錄上按下右鍵，選擇"Add Existing Item..."，再選擇想加入的檔案就行了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/K1LuZ3T.jpg" &gt;&lt;/p&gt;
&lt;p&gt;按照範例先在SciTE中寫好了三個檔案。&lt;/p&gt;
&lt;p&gt;編譯成DLL文件的是dllmain.c和dll.h，編譯成執行檔的是call DLL.c，在標頭檔dll.h中有相關紀錄。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/acz9z6v.jpg" &gt;&lt;/p&gt;
&lt;p&gt;DLL中的Add函式中輸入三個類型分別是char、int、int的值，會回傳一串文字，類型是char。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
DLLIMPORT char* Add(char*str, int a, int b)
{
    printf("This is your ID(8):\n");
    printf("Your ID: %s\n", str);
    printf("%d+%d=%d:\n", a, b, a+b);
    return "OK";
}
&lt;/pre&gt;

&lt;p&gt;標頭檔中也有這一段匯入，供可執行檔呼叫。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
DLLIMPORT char* Add(char*, int, int);
&lt;/pre&gt;

&lt;p&gt;這時候先編譯動態連結庫，在專案上按右鍵，選擇Properties。&lt;/p&gt;
&lt;p&gt;在Build的設定中，Configuration Type的選項選擇Dynamic Library，設定好後按下Build鈕。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/B5driZY.jpg" &gt;&lt;/p&gt;
&lt;p&gt;這時候會顯示成功，並在\dist\Debug\MinGW的資料中編譯出dll檔，動態連結庫就算是成功了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/L3U9skL.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;編譯出C的可執行檔 :&lt;/h2&gt;

&lt;p&gt;這時再把call DLL.c加入Source File中。&lt;/p&gt;
&lt;p&gt;call DLL.exe主要就是接受使用者輸入的三個值，並讓動態連結庫處理完顯示值後，再把顯示值回傳，顯示給使用者看。&lt;/p&gt;
&lt;p&gt;call DLL.c的主程式如下：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
int main(void)
{
    int i1, i2;
    char str1[9];
    printf("Key in:\n");
    scanf("%s,%d,%d", &amp;str1, i1, i2);
    printf("\n");

    HMODULE hInst=LoadLibrary("DLLtest.dll");
    if(hInst==NULL){
        printf("Can't load library.\n");
        system("PAUSE");
        return 1;
    }
    char* (*CallDll)(char*, int, int);
    (FARPROC*)(CallDll)=GetProcAddress(hInst, "Add");
    if(CallDll==NULL){
        printf("NO Value.\n");
        system("PAUSE");
        return 2;
    }
    printf("Result: %s\n", CallDll(str1, i1,i2));
    FreeLibrary(hInst);
    system("PAUSE");
    return 0;
}
&lt;/pre&gt;

&lt;p&gt;然而在編譯時，NetBeans卻顯示了下列訊息：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/JjwIcXD.jpg" &gt;&lt;/p&gt;
&lt;p&gt;顯示是在這段出了問題：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
(FARPROC*)(CallDll)=GetProcAddress(hInst, "Add");
&lt;/pre&gt;

&lt;p&gt;這裡的問題是定義項和被定義項的關係錯誤。&lt;/p&gt;
&lt;p&gt;上網查了一些資料，使用的語法都試過了，但是問題仍然無法解決。&lt;/p&gt;
&lt;p&gt;由於是內建函式，所以不太了解其格式甚麼的。&lt;/p&gt;
&lt;p&gt;於是回去觀察Solvespace的標頭檔，發現CDemo是直接使用這段：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
DLL void Slvs_Solve(Slvs_System *sys, Slvs_hGroup hg);
&lt;/pre&gt;

&lt;p&gt;完全不用呼叫dll名稱什麼的。&lt;/p&gt;
&lt;p&gt;因為在slvs.h中，所有的格式在開始就寫得清清楚楚，所以若要使用，必須將需要的數值按照規定的格式填入，然後由最高層的"Slvs_"指派計算。&lt;/p&gt;
&lt;p&gt;編譯後，動態連結庫取代了標頭檔的功能，包裝各項副程式後，在同個目錄下，可以供其他想使用函式的可執行檔使用。&lt;/p&gt;
&lt;p&gt;至於工程師規定的格式在slvs.h的註解中有所說明。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;雖然這次編譯基礎程式時失敗了，但是瞭解這些引用功能的方式，仍然是有所收穫。&lt;/p&gt;
&lt;p&gt;下次應該是模仿CDemo寫題目給libslvs.dll求解，不過若之後是要使用python的話還需要再研究一下SWIG的功能。&lt;/p&gt;</summary><category term="CDemo"></category></entry><entry><title>40323230紀錄 - 瞭解SWIG &amp; CDemo的資源</title><link href="http://project.mde.tw/blog/40323230ji-lu-liao-jie-swig-cdemode-zi-yuan.html" rel="alternate"></link><published>2016-07-09T19:00:00+08:00</published><updated>2016-07-09T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-09:blog/40323230ji-lu-liao-jie-swig-cdemode-zi-yuan.html</id><summary type="html">&lt;p&gt;安裝SWIG&lt;/p&gt;
&lt;p&gt;並檢視下列檔案：&lt;/p&gt;
&lt;p&gt;CDemo.exe&lt;/p&gt;
&lt;p&gt;CDemo.c&lt;/p&gt;


&lt;h2&gt;安裝工具 :&lt;/h2&gt;

&lt;p&gt;除了英文的資料，另外還讀了一下關於SWIG的相關中文資料：&lt;/p&gt;
&lt;p&gt;1.Python的資料庫形式&lt;/p&gt;
&lt;p&gt;&lt;a href="https://read01.com/PnGeDg.html" title="read01.com"&gt;https://read01.com/PnGeDg.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.Python在Windows中用SWIG呼叫C/C++的函式（VC）&lt;/p&gt;
&lt;p&gt;&lt;a href="http://falldog7.blogspot.tw/2013/07/python-swig-c-function.html" title="falldog7.blogspot.tw"&gt;http://falldog7.blogspot.tw/2013/07/python-swig-c-function.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.SWIG概念&lt;/p&gt;
&lt;p&gt;&lt;a href="http://user.frdm.info/ckhung/b/mi/swig.php" title="user.frdm.info"&gt;http://user.frdm.info/ckhung/b/mi/swig.php&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接著從&lt;a href="http://www.swig.org/download.html" title="swig.org"&gt;swig.org&lt;/a&gt;下載最新版的SWIG 3.0.10，將壓縮包解至W:內。&lt;/p&gt;
&lt;p&gt;SWIG能夠給Windows/Unix/MacOSX三個平台使用，所以壓縮檔的附檔名是三個平台都共通的".tar.gz"。&lt;/p&gt;
&lt;p&gt;解壓縮後，在Windows環境中有很多檔案是打不開的，不過說明檔是沒有附檔名的，隨便用任何一款文字編輯軟體都能查看。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0709-2_01.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;如果該步驟需要完整的流程，\Doc\Manual中有寫好的html網頁手冊，用網頁瀏覽器就能開啟。&lt;/p&gt;
&lt;p&gt;在閱讀\Doc\Manual\Windows.html的說明之後，手冊解釋SWIG並不是使用通常的Windows類型安裝程式。&lt;/p&gt;
&lt;p&gt;只要在編譯器中（手冊的範例是Visual Studio）設置環境變數就能使用其範例檔。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0709-2_02.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;手冊上也有說明能夠用MinGW和MSYS，Build出SWIG的可執行檔swig.exe。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0709-2_03.jpg" /&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;CDemo.exe :&lt;/h2&gt;

&lt;p&gt;CDemo.exe是由CDemo.c編譯出來的可執行檔，取用libslvs.dll的動態連結庫運作。&lt;/p&gt;
&lt;p&gt;在原本的\exposed資料夾中還有工程師留下的VbDemo.vb，Visual Basic或是Visual C#的專案文件，不過不使用這兩個編譯器的話就用不到。&lt;/p&gt;
&lt;p&gt;為此特別將CDemo.exe和libslvs.dll拿出來放在獨立的資料夾中。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0709-2_04.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;由CMD進入資料夾中執行CDemo.exe，會發現CDemo是直接顯示了結果。&lt;/p&gt;
&lt;p&gt;顯然CDemo.exe原先已經設定好題目，於是打開CDemo.c看看工程師的註解怎麼說。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0709-2_05.jpg" /&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;CDemo.c :&lt;/h2&gt;

&lt;p&gt;由於NetBeans和Windows的截圖程式似乎有衝突，會常常截完圖後自動閃退，所以改用簡便的SciTE。&lt;/p&gt;
&lt;p&gt;用SciTE開啟CDemo.c，可以發現CDemo的原始碼。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0709-2_06.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;而為了方便，將它部分的原始碼貼在下面：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
/*---------------------------
 * Some sample code for slvs.dll. We draw some geometric entities, provide
 * initial guesses for their positions, and then constrain them. The solver
 * calculates their new positions, in order to satisfy the constraints.
 *
 * Copyright 2008-2013 Jonathan Westhues.
 *-------------------------*/
#ifdef HAVE_CONFIG_H
...
#endif
#ifdef WIN32
...
#endif
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#ifdef HAVE_STDINT_H
...
#endif

#include &lt;slvs.h&gt;

static Slvs_System sys;

static void *CheckMalloc(size_t n)
{
    void *r = malloc(n);
    if(!r) {
        printf("out of memory!\n");
        exit(-1);
    }
    return r;
}

/*---------------------------
 * An example of a constraint in 3d. We create a single group, with some
 * entities and constraints.
 *-------------------------*/
void Example3d()
{
...
}

/*---------------------------
 * An example of a constraint in 2d. In our first group, we create a workplane
 * along the reference frame's xy plane. In a second group, we create some
 * entities in that group and dimension them.
 *-------------------------*/
void Example2d()
{
...
}

int main()
{
    sys.param      = CheckMalloc(50*sizeof(sys.param[0]));
    sys.entity     = CheckMalloc(50*sizeof(sys.entity[0]));
    sys.constraint = CheckMalloc(50*sizeof(sys.constraint[0]));

    sys.failed  = CheckMalloc(50*sizeof(sys.failed[0]));
    sys.faileds = 50;

    /*Example3d();*/
    for(;;) {
        Example2d();
        sys.params = sys.constraints = sys.entities = 0;
        break;
    }
    return 0;
}

&lt;/pre&gt;

&lt;p&gt;在CDemo.c的主程式中，最後執行Example3d()副程式的部分被註解掉了。&lt;/p&gt;
&lt;p&gt;所以程式的運行主要是跑Example2d()，就把它的程式碼抓出來看一下。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
void Example2d()
{
    Slvs_hGroup g;
    double qw, qx, qy, qz;

    g = 1;
    /* First, we create our workplane. Its origin corresponds to the origin
     * of our base frame (x y z) = (0 0 0) */
    sys.param[sys.params++] = Slvs_MakeParam(1, g, 0.0);
    sys.param[sys.params++] = Slvs_MakeParam(2, g, 0.0);
    sys.param[sys.params++] = Slvs_MakeParam(3, g, 0.0);
    sys.entity[sys.entities++] = Slvs_MakePoint3d(101, g, 1, 2, 3);
    /* and it is parallel to the xy plane, so it has basis vectors (1 0 0)
     * and (0 1 0). */
    Slvs_MakeQuaternion(1, 0, 0,
                        0, 1, 0, &amp;qw, &amp;qx, &amp;qy, &amp;qz);
    sys.param[sys.params++] = Slvs_MakeParam(4, g, qw);
    sys.param[sys.params++] = Slvs_MakeParam(5, g, qx);
    sys.param[sys.params++] = Slvs_MakeParam(6, g, qy);
    sys.param[sys.params++] = Slvs_MakeParam(7, g, qz);
    sys.entity[sys.entities++] = Slvs_MakeNormal3d(102, g, 4, 5, 6, 7);

    sys.entity[sys.entities++] = Slvs_MakeWorkplane(200, g, 101, 102);

    /* Now create a second group. We'll solve group 2, while leaving group 1
     * constant; so the workplane that we've created will be locked down,
     * and the solver can't move it. */
    g = 2;
    /* These points are represented by their coordinates (u v) within the
     * workplane, so they need only two parameters each. */
    sys.param[sys.params++] = Slvs_MakeParam(11, g, 10.0);
    sys.param[sys.params++] = Slvs_MakeParam(12, g, 20.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(301, g, 200, 11, 12);

    sys.param[sys.params++] = Slvs_MakeParam(13, g, 20.0);
    sys.param[sys.params++] = Slvs_MakeParam(14, g, 10.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(302, g, 200, 13, 14);

    /* And we create a line segment with those endpoints. */
    sys.entity[sys.entities++] = Slvs_MakeLineSegment(400, g,
                                        200, 301, 302);

    /* Now three more points. */
    sys.param[sys.params++] = Slvs_MakeParam(15, g, 100.0);
    sys.param[sys.params++] = Slvs_MakeParam(16, g, 120.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(303, g, 200, 15, 16);

    sys.param[sys.params++] = Slvs_MakeParam(17, g, 120.0);
    sys.param[sys.params++] = Slvs_MakeParam(18, g, 110.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(304, g, 200, 17, 18);

    sys.param[sys.params++] = Slvs_MakeParam(19, g, 115.0);
    sys.param[sys.params++] = Slvs_MakeParam(20, g, 115.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(305, g, 200, 19, 20);

    /* And arc, centered at point 303, starting at point 304, ending at
     * point 305. */
    sys.entity[sys.entities++] = Slvs_MakeArcOfCircle(401, g, 200, 102,
                                    303, 304, 305);

    /* Now one more point, and a distance */
    sys.param[sys.params++] = Slvs_MakeParam(21, g, 200.0);
    sys.param[sys.params++] = Slvs_MakeParam(22, g, 200.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(306, g, 200, 21, 22);

    sys.param[sys.params++] = Slvs_MakeParam(23, g, 30.0);
    sys.entity[sys.entities++] = Slvs_MakeDistance(307, g, 200, 23);

    /* And a complete circle, centered at point 306 with radius equal to
     * distance 307. The normal is 102, the same as our workplane. */
    sys.entity[sys.entities++] = Slvs_MakeCircle(402, g, 200,
                                    306, 102, 307);


    /* The length of our line segment is 30.0 units. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            1, g,
                                            SLVS_C_PT_PT_DISTANCE,
                                            200,
                                            30.0,
                                            301, 302, 0, 0);

    /* And the distance from our line segment to the origin is 10.0 units. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            2, g,
                                            SLVS_C_PT_LINE_DISTANCE,
                                            200,
                                            10.0,
                                            101, 0, 400, 0);
    /* And the line segment is vertical. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            3, g,
                                            SLVS_C_VERTICAL,
                                            200,
                                            0.0,
                                            0, 0, 400, 0);
    /* And the distance from one endpoint to the origin is 15.0 units. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            4, g,
                                            SLVS_C_PT_PT_DISTANCE,
                                            200,
                                            15.0,
                                            301, 101, 0, 0);
#if 0
    /* And same for the other endpoint; so if you add this constraint then
     * the sketch is overconstrained and will signal an error. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            5, g,
                                            SLVS_C_PT_PT_DISTANCE,
                                            200,
                                            18.0,
                                            302, 101, 0, 0);
#endif /* 0 */

    /* The arc and the circle have equal radius. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            6, g,
                                            SLVS_C_EQUAL_RADIUS,
                                            200,
                                            0.0,
                                            0, 0, 401, 402);
    /* The arc has radius 17.0 units. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            7, g,
                                            SLVS_C_DIAMETER,
                                            200,
                                            17.0*2,
                                            0, 0, 401, 0);

    /* If the solver fails, then ask it to report which constraints caused
     * the problem. */
    sys.calculateFaileds = 1;

    /* And solve. */
    Slvs_Solve(&amp;sys, g);

    if(sys.result == SLVS_RESULT_OKAY) {
        printf("solved okay\n");
        printf("line from (%.3f %.3f) to (%.3f %.3f)\n",
                sys.param[7].val, sys.param[8].val,
                sys.param[9].val, sys.param[10].val);

        printf("arc center (%.3f %.3f) start (%.3f %.3f) finish (%.3f %.3f)\n",
                sys.param[11].val, sys.param[12].val,
                sys.param[13].val, sys.param[14].val,
                sys.param[15].val, sys.param[16].val);

        printf("circle center (%.3f %.3f) radius %.3f\n",
                sys.param[17].val, sys.param[18].val,
                sys.param[19].val);
        printf("%d DOF\n", sys.dof);
    } else {
        int i;
        printf("solve failed: problematic constraints are:");
        for(i = 0; i &lt; sys.faileds; i++) {
            printf(" %d", sys.failed[i]);
        }
        printf("\n");
        if(sys.result == SLVS_RESULT_INCONSISTENT) {
            printf("system inconsistent\n");
        } else {
            printf("system nonconvergent\n");
        }
    }
}
&lt;/pre&gt;

&lt;p&gt;"Slvs_hGroup g"中的g能在群組編號中切換，離開後的群組會被鎖定。裡面的成員無法新增和編輯，不過可以被呼叫。&lt;/p&gt;
&lt;p&gt;之後便能用"sys.param[sys.params++]"或是"sys.entity[sys.entities++]"的指令在群組下建立工作物件（回傳值，物件格式是%.3f）和建立實體（檢查結果）。&lt;/p&gt;
&lt;p&gt;比較特別的是本程式建立座標的編號是從1開始的；建立工作點的編號是從101開始的；建立工作平面是從200開始的（這題只有一個工作平面）；建立點的編號是從301開始的（使用的座標和工作點相同層級）。之後層級越高編號都以100的倍數成長。&lt;/p&gt;
&lt;p&gt;畫完圖之後，最後解決的程式是使用Slvs_Solve(&amp;amp;sys, g);，取得程式結果和輸入群組編號。至於這個範疇就是libslvs.dll和其他Solvespace部件的工作了。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;閱讀完pyd檔案的作用後，大約知道它和dll的關聯性了。&lt;/p&gt;
&lt;p&gt;不過libslvs.dll究竟是從哪裡編譯出來的呢？是從主要的cpp檔還是標頭檔建立的？Build完之後多出了libslvs.dll.a和config.h。&lt;/p&gt;
&lt;p&gt;雖然一些簡單的dll可以直接打開編輯，不過libslvs.dll應該是不能這樣做。&lt;/p&gt;</summary><category term="Solvespace"></category><category term="CDemo"></category><category term="SWIG"></category></entry><entry><title>40323230練習 - 105/07/09</title><link href="http://project.mde.tw/blog/40323230lian-xi-1050709.html" rel="alternate"></link><published>2016-07-09T12:00:00+08:00</published><updated>2016-07-09T12:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-09:blog/40323230lian-xi-1050709.html</id><summary type="html">&lt;p&gt;嘗試用C語言解題&lt;/p&gt;


&lt;h2&gt;BUG fix :&lt;/h2&gt;

&lt;p&gt;W:槽的SciTE有點小問題，因為設定檔是從Y:複製來的，所以需要重新定義TinyC的位置。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="(https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0709_01.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;只要修改cpp.properties的路徑就可以了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="(https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0709_02.jpg" /&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;Nutcracker Solution :&lt;/h2&gt;

&lt;p&gt;上學期的&lt;a href="http://chiamingyen.github.io/kmolab/blog/2015-fall-cadp-w16.html" title="github.io"&gt;Nutcracker網誌內容&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="(https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0709_03.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;之前的python題目，稍微研究一下後轉成C語言。&lt;/p&gt;
&lt;p&gt;不過如果直接運行會跑很久。但是這裡可以練習一下小型演算法的模式。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="(https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0709_04.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;先做了兩個程式，不過第一是介面而已，第二個才是主要架構。&lt;/p&gt;
&lt;p&gt;撰寫的途中使用Solvespace研究，由於數學邏輯不太好，很多幾何的東西沒那麼直觀。&lt;/p&gt;
&lt;p&gt;有時候會偷吃步測試一些解法。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="(https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0709_05.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;第二支程式是從python的範例改來的，不過後來做了很多變化，只有解最小路徑最大角度。&lt;/p&gt;
&lt;p&gt;演算法概念：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="(https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0709_06.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;途中查了很多數學公式，無奈常常打錯又不知道正確性，重複試了很多次才成功。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int k=40;
int h=10;
int a=40;
int b=80;
double r=10;
double pi=M_PI;
int num=1000;

int main()
{
    double deg =pi/180;
    for (int j=45*num; j&lt;=180*num; j++){
        double num0=num;
        double th=j/num0*deg;
        double x1=a*cos(th);
        double y1=a*sin(th);
        double x2=x1+sqrt(b*b-y1*y1);
        double m=tan(th);
        double r1=abs((x2-x1)*(h-y1)-(0-y1)*(k/2-x1))/sqrt(y1*y1+(x2-x1)*(x2-x1));
        printf("%g\n", (int)(j/num0*100000+.5)/100000.);
        if(r1&lt;=r){
            printf("(%f,%f) (%f,0)\n%f\n%f r=%f\nm=%f\n", x1, y1, x2, th/deg, r, r1, m);
            break;
        }
    }
    return 0;
}
&lt;/pre&gt;

&lt;p&gt;第二支程式的最後成果。&lt;/p&gt;
&lt;p&gt;最後精確度還是沒有很高，不知道問題出在哪裡。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="(https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0709_07.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;第一支程式是剛開始寫輸入端介面，供使用者輸入自訂參數，後來再把第二支程式的模型搬回來用，並另外寫一個解最大路徑和最小角度的程式，所有例外狀況也是在這裡排除。&lt;/p&gt;
&lt;p&gt;後來還不知道怎麼讓副程式傳回double或其他浮點數，查一下才知道要在開始前宣告一次。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int a, b, k, h, r, lim;
double o, wp, thmin, thmax;
double pi=M_PI;
int num=1000;

double solve_minpath(int, int, int, int, int);
double solve_maxangle(int, int, int, int, int);
double solve_maxpath(int, int, int, int);
double solve_minangle(int, int, int, int);

int main()
{
    scanf("%d,%d,%d,%d,%d,%d", &amp;a, &amp;b, &amp;k, &amp;h, &amp;r, &amp;lim);
//強制正值
    a=abs(a);
    b=abs(b);
    h=abs(h);
    k=abs(k);
    r=abs(r);
    lim=abs(lim);
    printf("\n---\n");
    printf("Used pi= %f\n", pi);
    printf("---\n");
    printf("Connecting Rod:\n");
    printf("a= %d b= %d\n", a, b);
    printf("Rod radius= %d\n", r);
    printf("Rod width= %d\n", r*2);
    printf("Space Usage:\n");
    printf("h= %d k= %d\n", h, k);
    printf("Work Path= %d\n", lim);
    printf("---\n\n");
//相關參數代入副程式解題
    o=solve_minpath(k, h, a, b, r);
    wp=solve_maxpath(lim, a, b, r)-o;
    thmin=solve_minangle(lim, a, b, r);
    thmax=solve_maxangle(k, h, a, b, r);
    if(a*b*lim==0){
        printf("---ERRO---\nSome value can't be zero.\n");
        return 1;
    }
    else{
        if(o+r&gt;lim){
            printf("---ERRO---\nSpace is not enough.\n");
            return 2;
        }
        else{
            printf("\n---\n---Result---\n");
            printf("Distance:\n");
            printf("Offset distance:\n");
            printf("o= %f\n", o);
            printf("Work distance:\n");
            printf("wp= %f\n", wp);
            printf("Angle(Degree):\n");
            printf("min= %f max= %f\n---\n", thmin, thmax);
            return 0;
        }
    }
}

double solve_minpath(int k, int h, int a, int b, int r)
{
    double deg =pi/180;
    for (int j=45*num; 180*num&gt;=j; j++){
        double num0=num;
        double th=j/num0*deg;
        double x1=a*cos(th);
        double y1=a*sin(th);
        double x2=x1+sqrt(b*b-y1*y1);
        double m=tan(th);
        double r1=abs((x2-x1)*(h-y1)-(0-y1)*(k/2-x1))/sqrt(y1*y1+(x2-x1)*(x2-x1));
        if(r&gt;=r1){
            printf("(%f,%f) (%f,0)\n%f\n%f r=%f\nm=%f\n", x1, y1, x2, th/deg, r, r1, m);
            return x2;
            break;
        }
    }
    return 0;
}

double solve_maxangle(int k, int h, int a, int b, int r)
{
    double deg =pi/180;
    for (int j=45*num; 180*num&gt;=j; j++){
        double num0=num;
        double th=j/num0*deg;
        double x1=a*cos(th);
        double y1=a*sin(th);
        double x2=x1+sqrt(b*b-y1*y1);
        double m=tan(th);
        double r1=abs((x2-x1)*(h-y1)-(0-y1)*(k/2-x1))/sqrt(y1*y1+(x2-x1)*(x2-x1));
        if(r&gt;=r1){
            printf("(%f,%f) (%f,0)\n%f\n%f r=%f\nm=%f\n", x1, y1, x2, th/deg, r, r1, m);
            return th/deg;
            break;
        }
    }
    return 0;
}

double solve_maxpath(int lim, int a, int b, int r)
{
    double n;
    double th;
    if (lim&gt;a+b+r){
        n=a+b;
        th=0;
    }
    else{
        n=lim-r;
        th=acos((a*a+n*n-b*b)/2*a*n);
    }
    return n;
}

double solve_minangle(int lim, int a, int b, int r)
{
    double n;
    double th;
    if (lim&gt;a+b+r){
        n=a+b;
        th=0;
    }
    else{
        n=lim-r;
        th=acos((a*a+n*n-b*b)/(2*a*n));
    }
    return th;
}

&lt;/pre&gt;

&lt;p&gt;最後執行的結果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0709_08.jpg" /&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;剛開始還以為是用公式推導座標點的結果，後來回去看網誌才知道用演算法計算。電腦演算時如果一邊列出結果，會拖慢速度，所以在最後的程式碼中只留檢查用的結果。&lt;/p&gt;
&lt;p&gt;後來也有上網看其他人使用基因演算法的案例，未能完全了解，還有很多要學習的地方。這次解題複習了一些C語言的概念，希望在往後利用上能夠駕輕就熟。&lt;/p&gt;</summary><category term="Solvespace"></category></entry><entry><title>40323230紀錄 - 編譯Solvespace流程</title><link href="http://project.mde.tw/blog/40323230ji-lu-bian-yi-solvespaceliu-cheng.html" rel="alternate"></link><published>2016-07-07T19:00:00+08:00</published><updated>2016-07-07T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-07:blog/40323230ji-lu-bian-yi-solvespaceliu-cheng.html</id><summary type="html">&lt;p&gt;由原始碼編譯出Solvespace和CDemo的執行檔&lt;/p&gt;


&lt;h2&gt;安裝工具 :&lt;/h2&gt;

&lt;p&gt;必須存放於可攜式環境內的工具，可以協助我們建立Solvespace和CDemo的執行檔。&lt;/p&gt;
&lt;p&gt;連結為下載處。&lt;/p&gt;
&lt;p&gt;1.MinGW (Not official version), &lt;a href="https://nuwen.net/mingw.html" title="nuwen.net"&gt;https://nuwen.net/mingw.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.msys (Official version), &lt;a href="http://www.mingw.org/wiki/msys" title="mingw.org"&gt;http://www.mingw.org/wiki/msys&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.CMake  (Official version), &lt;a href="https://cmake.org/download/" title="cmake.org"&gt;https://cmake.org/download/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.NetBeans (Our storage), &lt;a href="http://140.130.17.17/public/Netbeans/" title="140.130.17.17/public/"&gt;http://140.130.17.17/public/Netbeans/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;存放位置除了CMake之外皆為W:內，CMake存於W:\app資料夾中。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0707_01.jpg" /&gt;&lt;/p&gt;
&lt;h2&gt;下載Solvespace原始碼 :&lt;/h2&gt;

&lt;p&gt;從&lt;a href="https://github.com/whitequark/solvespace/tree/master" title="github.com"&gt;Whitequark的倉儲&lt;/a&gt;git clone最新的原始碼到W:\tmp資料夾內，並執行git submodule update --init命令以從相關倉儲下載submodule的原始碼。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0707_02.jpg" /&gt;&lt;/p&gt;
&lt;h2&gt;NetBeans設定 :&lt;/h2&gt;

&lt;p&gt;從\NetBeans\bin執行NetBeans，亦可編輯start.bat和stop.bat後，在啟動時呼叫和關閉它。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0707_03.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;在Tools-&amp;gt;Options的C/C++中新增編譯工具，選擇GNU MinGW，並填入MinGW的存放位置。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0707_04.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;大部分的程式位置會自動填入，不過還要指定msys的make.exe和cmake的位置。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0707_05.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;若有必要可以為NetBeans安裝CMake的附加元件。&lt;/p&gt;
&lt;p&gt;在Tools-&amp;gt;Plugins的Available Plugins中搜尋cmake就能找到，勾選後按下Install鈕就能夠安裝。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0707_06.jpg" /&gt;&lt;/p&gt;
&lt;h2&gt;執行Build :&lt;/h2&gt;

&lt;p&gt;接著按下New Project...新增專案。&lt;/p&gt;
&lt;p&gt;選擇Project with Existing Sources繼續。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0707_07.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;然後選擇Whitequark的Solvespace原始碼目錄。&lt;/p&gt;
&lt;p&gt;並使用Automatic讓cmake自動清理專案，直接按完成就會開始Clean和嘗試Build。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0707_08.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;這時在Build時會出現錯誤，顯示一串類似undefined reference to `BZ2_bzDecompressEnd'的訊息，是因為沒有加入bz2的程式庫連結所致。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0707_09.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;這時開啟專案內的\src\CMakeLists.txt，找到target_link_libraries這一行，並將bz2加到最後的括弧內，就可以繼續完成Build。&lt;/p&gt;
&lt;p&gt;註：如果不是填在最後一項會有讀取順序錯誤的問題。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0707_10.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;修改CMake的清單後，就能順利建立solvespace.exe和CDemo.exe，分別存放在\src和\exposed資料夾下。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0707_11.jpg" /&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;接下來就是研究如何應用CDemo的解題程式協助解開範例，最後再修改供Python3呼叫和取用其動態連結庫。&lt;/p&gt;</summary><category term="Solvespace"></category><category term="CDemo"></category></entry><entry><title>40323230紀錄 - Solvespace</title><link href="http://project.mde.tw/blog/40323230ji-lu-solvespace.html" rel="alternate"></link><published>2016-07-06T19:00:00+08:00</published><updated>2016-07-06T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-06:blog/40323230ji-lu-solvespace.html</id><summary type="html">&lt;p&gt;找到的Solvespace原始碼版本&lt;/p&gt;


&lt;h2&gt;目前可攜式環境內存放的Solvespace原始碼 :&lt;/h2&gt;

&lt;h3&gt;超連結為下載處。&lt;/h3&gt;

&lt;p&gt;1.&lt;a href="https://github.com/whitequark/solvespace/tree/master" title="github.com"&gt;Whitequark的倉儲&lt;/a&gt;：非官方人員開發的原始碼。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0706_01.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href="http://solvespace.com/download.pl" title="solvespace.com"&gt;Solvespace 2.0&lt;/a&gt;：官方舊版2.0的原始碼。結構很簡單，沒有cmake建置的檔案。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0706_02.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;a href="https://github.com/solvespace/solvespace/releases/tag/v2.1" title="github.com"&gt;Solvespace 2.1&lt;/a&gt;：官方最新穩定的版本。結構類似現在開發中的樣式。但是用NetBeans建置時會顯示\extlib資料夾中很多資料夾是空的錯誤，2.0版沒有這些資料夾，這些空的資料夾似乎和&lt;a href="https://github.com/solvespace/libdxfrw" title="github.com"&gt;solvespace/libdxfrw&lt;/a&gt;有關聯。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0706_03.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;4.&lt;a href="https://github.com/solvespace/solvespace/tree/2.x" title="github.com"&gt;Solvespace的倉儲&lt;/a&gt;：官方開發中的2.2版。好像不能clone下來，只能載zip檔。也有2.1那些空資料夾。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0706_04.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;相關連結：版本差異紀錄-&lt;a href="https://github.com/solvespace/solvespace/blob/2.x/CHANGELOG.md" title="github.com"&gt;Solvespace的倉儲&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;NetBeans方面，同樣使用C/C++ Project with Existing Sources建置檔案，官方的版本都會因為libdxfrw、libfreetype、libpng、zlib沒東西而顯示建置錯誤。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0706_05.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0706_06.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;點開記錄錯誤的視窗：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0706_07.jpg" /&gt;&lt;/p&gt;</summary><category term="Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/05</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050705.html" rel="alternate"></link><published>2016-07-05T19:00:00+08:00</published><updated>2016-07-05T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-05:blog/40323230ri-zhi-1050705.html</id><summary type="html">&lt;p&gt;NetBeans的相關探索-2&lt;/p&gt;
&lt;p&gt;註：發現目前最新的原始碼內好像很多錯誤，不知道該怎麼辦。&lt;/p&gt;


&lt;p&gt;目前NetBeans的&lt;a href="https://netbeans.org/kb/docs/intro-screencasts.html?utm_source=netbeans&amp;amp;utm_campaign=welcomepage" title="netbeans.org"&gt;官方網站&lt;/a&gt;並沒有很詳盡的介紹，只有放一些改版的導覽影片。&lt;/p&gt;
&lt;p&gt;基於如此就研究看看它跟其他編譯軟體有那些不一樣的地方。&lt;/p&gt;
&lt;h2&gt;NetBeans啟動 :&lt;/h2&gt;

&lt;p&gt;每次啟動可攜式環境，NetBeans portable都會保留之前的設定。&lt;/p&gt;
&lt;p&gt;只要上次編譯的專案沒有關閉或是刪除，NetBeans在啟動時都會自動載入，不需要重新導入專案。&lt;/p&gt;
&lt;p&gt;另外NetBeans需要連線的服務（ex.附加元件）也會在啟動時檢查更新。只要背景有程序執行，右下角的進度條就會提醒。&lt;/p&gt;
&lt;p&gt;不過NetBeans似乎有時載入太多東西或其他背景程式開太多，如果再對它下指令，會反應跟不上而閃退。也有可能是在可攜環境執行的關係，比較吃資源。&lt;/p&gt;
&lt;p&gt;設定start.bat在啟動後自動打開NetBeans。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0705_01.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;NetBeans在啟動時載入專案的提示。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0705_02.jpg" /&gt;&lt;/p&gt;
&lt;h2&gt;NetBeans介面 :&lt;/h2&gt;

&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0705_03.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;跟大部分的文字編譯軟體差不多的介面。&lt;/p&gt;
&lt;p&gt;在畫面中按住Ctrl鍵選取#include或import的檔案能直接在分頁中開啟它們；如果是物件，點擊後會移到宣告的地方；如果是副程式，會移到其開始位置。&lt;/p&gt;
&lt;p&gt;行號中會標記錯誤或警告提示，滑鼠移上去就會解說，並且按下Alt+Enter可以顯示更多提示。&lt;/p&gt;
&lt;p&gt;捲軸的旁邊會標記標籤，顯示整個檔案中哪些位置有警告或錯誤，直接點擊可以快速移到該處。&lt;/p&gt;
&lt;p&gt;NetBeans還有內建自動拼寫校正（註解處）。不過有時候讀取和偵錯反應比較慢。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0705_04.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;主工具列比較簡單。新建獨立檔案／專案、讀取專案、全部儲存、復原／重做之類的基本功能。&lt;/p&gt;
&lt;p&gt;另外還有選取專案設定檔、Build／Clean than Build的功能、執行／除錯的功能。&lt;/p&gt;
&lt;p&gt;上方的選單比較特殊的是Team的功能，似乎能管理版次和執行git的指令，但是嘗試了一些似乎沒反應？&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0705_05.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;Project的欄目可以快速選取開啟CMake的檔案，除此之外和File的檔案結構是一樣的。&lt;/p&gt;
&lt;p&gt;以下是File的檔案目錄和檔案總管顯示的比較。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0705_06.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0705_07.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;服務頁籤中會顯示一些工具，不過不知道怎麼使用。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0705_08.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;讀取檔案後會顯示第4個欄位Class，是拆解程式後的物件樹，點擊兩下會開啟程式碼。&lt;/p&gt;
&lt;p&gt;在物件上點擊兩下會移到該物件所在的檔案位置。&lt;/p&gt;
&lt;p&gt;在物件上打關鍵字並使用上下鍵移動能夠搜尋檔案中的物件。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0705_09.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0705_10.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;工具列的功能說明：&lt;/p&gt;
&lt;p&gt;1：Source-切換至編輯原始碼模式。&lt;/p&gt;
&lt;p&gt;2：History-切換至編輯記錄模式。&lt;/p&gt;
&lt;p&gt;3：Last Edit-回到上次編輯（插入／刪除）過的位置。&lt;/p&gt;
&lt;p&gt;4：Go back to-上一個瀏覽過的檔案。&lt;/p&gt;
&lt;p&gt;5：Forward-下一個瀏覽過的檔案。&lt;/p&gt;
&lt;p&gt;6：Find Selection-在本檔案搜尋框選的文字。&lt;/p&gt;
&lt;p&gt;7：Find Previous Occurrence-尋找前一個關鍵字。&lt;/p&gt;
&lt;p&gt;8：Find Next Occurrence-尋找後一個關鍵字。&lt;/p&gt;
&lt;p&gt;9：Toggle Highlight Search-切換高亮度標示。&lt;/p&gt;
&lt;p&gt;10：Toggle Rectangular Selection-切換矩形框選模式。&lt;/p&gt;
&lt;p&gt;11：Previous Bookmark-前一個書籤。&lt;/p&gt;
&lt;p&gt;12：Next Bookmark-下一個書籤。&lt;/p&gt;
&lt;p&gt;13：Toggle Bookmark-切換書籤。&lt;/p&gt;
&lt;p&gt;14：Shift Line Left-往左縮排。&lt;/p&gt;
&lt;p&gt;15：Shift Line Right-往右縮排。&lt;/p&gt;
&lt;p&gt;16：Start Macro Recording-開始巨集（腳本）錄製。&lt;/p&gt;
&lt;p&gt;17：Stop Macro Recording-停止巨集錄製。&lt;/p&gt;
&lt;p&gt;18：Comment-註解。&lt;/p&gt;
&lt;p&gt;19：UNcomment-刪掉註解。&lt;/p&gt;
&lt;p&gt;20：Go to Header/Source-開啟源頭檔。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;使用一款未接觸過的軟體，都會先研究它的介面和基本操作方式還有額外的設定，不過有些專業用詞不知道影響的關聯性。&lt;/p&gt;
&lt;p&gt;以前只用過Visual Studio撰寫和測試一些簡單的程式，對這種大型的架構瞭解較少，應該會再找些相關資訊學習。&lt;/p&gt;</summary><category term="Solvespace"></category></entry><entry><title>40323218日誌 - 105/07/04</title><link href="http://project.mde.tw/blog/40323218ri-zhi-1050704.html" rel="alternate"></link><published>2016-07-04T20:37:00+08:00</published><updated>2016-07-04T20:37:00+08:00</updated><author><name>40323218</name></author><id>tag:project.mde.tw,2016-07-04:blog/40323218ri-zhi-1050704.html</id><summary type="html">&lt;p&gt;V-rep&lt;/p&gt;


&lt;h3&gt;熟悉 V-Rep 基本操作&lt;/h3&gt;

&lt;p&gt;&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/introduce1.PNG"&gt;
&lt;br&gt;
&lt;h3&gt;1. 2D移動&lt;br&gt;
2. 3D旋轉&lt;br&gt;
3. 遠近&lt;br&gt;
4. 移動畫面至物體&lt;br&gt;
5. 物體定位(x,y,z)&lt;br&gt;
6. 物體旋轉(x,y,z)&lt;br&gt;
7. 開始模擬&lt;br&gt;
8. 暫停模擬&lt;br&gt;
9. 結束模擬&lt;br&gt;
10. 慢速&lt;br&gt;
11. 加速&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;嘗試製作 one_link_robot&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step1.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;File→import→Mesh...(從資料夾中輸入 stl檔)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;選擇單位和方向&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step3.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;點選物體使用"object shift"調整Z軸距離&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;點選物體 右鍵→Edit→Grouping/Merging→Divide selected shapes(使物體解體)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;右鍵→Add→Joint→Revolute(增加旋轉軸)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;連點兩下Revolute icon 打開 Scene Object Properties , 下面 Visual properties修改旋轉軸的長和直徑&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;接著點下面 Show dynamic properties dialog , 打勾Motor enabled 和 Lock motor ...
&lt;br&gt;
&lt;h3&gt;再來點旋轉軸 , Ctrl+左鍵點圓柱 , 使用"object shift"在XYZ都點Apply to selection , 在"Orientation/Rotations"也點 Apply , 使兩軸重疊&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step6.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;點選圓柱 icon , 點最下面Show dynamic properties dialog , 打勾Body is dynamic(使物體可作動)
&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step7.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;
使圓柱降階成為旋轉軸的Child&lt;br&gt;
使旋轉物降階成為圓柱的Child&lt;br&gt;
使旋轉軸降階成為底座的Child&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step8.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;按左側"Script" →Insert new script→Script type 選擇 Child script (threaded) , 下方 Associated object 選擇底座.&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step9.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;double - click the child script,  在最下面加上SimExtRemoteApiStart(19999)(參考老師範例研究中) &lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/Round.gif" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;點選"Start simulation" 啟動模擬 , 用SciTE 開啟老師的檔案 one_link_robot_remoteAPI.py , F5執行就會轉囉~~&lt;/h3&gt;&lt;/p&gt;
&lt;h3&gt;製作影片：&lt;/h3&gt;

&lt;iframe src="https://player.vimeo.com/video/173321561" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/173321561"&gt;V-Rep one_link_robot&lt;/a&gt; from &lt;a href="https://vimeo.com/user44943624"&gt;Li Steven&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323230日誌 - 105/07/04-2</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050704-2.html" rel="alternate"></link><published>2016-07-04T19:00:00+08:00</published><updated>2016-07-04T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-04:blog/40323230ri-zhi-1050704-2.html</id><summary type="html">&lt;p&gt;NetBeans的相關探索&lt;/p&gt;


&lt;h2&gt;NetBeans設定 :&lt;/h2&gt;

&lt;p&gt;從&lt;a href="https://nuwen.net/mingw.html" title="nuwen.net"&gt;MinGW Distro - nuwen.net&lt;/a&gt;下載了新版配有gcc 6.1.0和Boost 1.61.0的MinGW，原本可攜式環境的MinGW是用gcc 4.9.3，暫且在名稱加上.old不使用。&lt;/p&gt;
&lt;p&gt;下圖是新版和舊版的比對。新版的資料夾有附一個README_STL.txt文件說明內含的附加元件版本。&lt;/p&gt;
&lt;p&gt;這個MinGW裡還配有一個比較簡單的git工具。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0704-2_01.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;NetBeans的版本是8.1，存放於根目錄W:，已經是最新版。&lt;/p&gt;
&lt;p&gt;先在Option裡設定C語言用的Build Tool，在新增工具的下拉選單設定使用MinGW，並指定到MinGW的目錄。成功新增Tool後，NetBeans會自己抓到gcc.exe、g++.exe、as.exe、gdb.exe，最下方則是有QMake和CMake的選項，將CMake指定到存放的位置。&lt;/p&gt;
&lt;p&gt;設定裡所有的位置都是指定於可攜式環境內，沒用到任何外部資料夾。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0704-2_02.jpg" /&gt;&lt;/p&gt;
&lt;h2&gt;NetBeans專案 :&lt;/h2&gt;

&lt;p&gt;之後新建專案，選擇C語言已有源代碼的專案。&lt;/p&gt;
&lt;p&gt;選擇模式部分選擇Solvespace的目錄。工具只有剛才設定的MinGW，並選擇自訂查看一下。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0704-2_03.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;基本上是使用Predefined Command，使用的是CMake的gui設定，也就是Solvespace目錄存放的CMakeLists.txt檔。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0704-2_04.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;接下來是清理和建置指令，就和打在CMD視窗裡的一樣。&lt;/p&gt;
&lt;p&gt;幾乎每個環節都會詢問工作環境，但是Solvespace沒特別區分的話就是原本目錄內，所以直接按下一步。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0704-2_05.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;按下完成鈕後會花個幾秒載入。然後就會在左側讀入原始碼資料夾和檔案的結構。&lt;/p&gt;
&lt;p&gt;下面則會執行並顯示CMake和Clean指令輸出的訊息，最後完成後就完成編譯環境了。&lt;/p&gt;
&lt;p&gt;左側的欄位分成Project、Files和Services。只要在Project或Files的檔案樹點兩下就能在中央開啟文件編輯。Services則可以呼叫MinGW的附加元件來用（包含gcc）。&lt;/p&gt;
&lt;p&gt;左下的導航欄似乎能執行CMake的指令。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0704-2_06.jpg" /&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;這次也是使用之前備份並更新過的Solvespace原始碼操作，免得被之前的檔案影響。&lt;/p&gt;
&lt;p&gt;雖然和SciTE一樣是文字編譯軟體，但是NetBeans能夠隨時呼叫需要使用的工具來支援。與Visual Studio相比還能夠在可攜環境中保存設定檔，更為方便。&lt;/p&gt;</summary><category term="Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/04</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050704.html" rel="alternate"></link><published>2016-07-04T12:00:00+08:00</published><updated>2016-07-04T12:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-04:blog/40323230ri-zhi-1050704.html</id><summary type="html">&lt;p&gt;改用CMD設定CMake&lt;/p&gt;


&lt;h2&gt;CMD命令cmake連接Solvespace原始碼 :&lt;/h2&gt;

&lt;h3&gt;Readme的Command-line build&lt;/h3&gt;

&lt;p&gt;使用可攜式環境的Command Prompt到外部呼叫Visual Studio的vcvarsall.bat。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0704_01.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;然後為cmake的bin資料夾設定啟動位置(Path4)，可以正常呼叫。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0704_02.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;到CMD中下Readme中提供的指令。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0704_03.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;接著下nmake的指令。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0704_04.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;但是在最後出現一些錯誤，不知道原因為何。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0704_05.jpg" /&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;與此同時可以用Visual Studio的相關功能。CMake也算是設定完成了。&lt;/p&gt;
&lt;p&gt;如果要改用NetBeans，就不用下nmake的指令。&lt;/p&gt;
&lt;hr&gt;

&lt;h3&gt;Readme的MSVC build&lt;/h3&gt;

&lt;p&gt;這次也把MinGW的bin設定進啟動位置(Path5)，可以正常呼叫。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0704_06.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;接著同樣按照Readme的說明用CMD下指令。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0704_07.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;不過後面的make指令會說無法讀取makefile檔。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;Readme中說可以使用MinGW，只要確保git和MinGW的gcc在作業環境內就行了。至於gcc的功能繁多，還需要研究一下。&lt;/p&gt;</summary><category term="Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/03-2</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050703-2.html" rel="alternate"></link><published>2016-07-03T19:00:00+08:00</published><updated>2016-07-03T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-03:blog/40323230ri-zhi-1050703-2.html</id><summary type="html">&lt;p&gt;關於編譯 Solvespace(更新)&lt;/p&gt;


&lt;h2&gt;使用CMake連接Solvespace原始碼 :&lt;/h2&gt;

&lt;h3&gt;Readme的GUI build&lt;/h3&gt;

&lt;p&gt;下載了放在140.130.17.17/public/Netbeans/的可攜式環境git2016，該環境使用的是W:磁碟機，不會和撰寫網誌的Y:環境衝突，可以同時開啟；但是其一關閉時會把所有cmd關掉。之後放入了Netbeans套件，不過還尚未使用。&lt;/p&gt;
&lt;p&gt;在新的可攜式環境中存入了從GitHub下載的Solvespace的原始碼，並依照其Readme的方式，用git submodule update --init指令更新模組，並存了一個備份檔。&lt;/p&gt;
&lt;p&gt;CMake的方面使用可攜版的Zip檔，而非Msi安裝。將CMake放在W:的根目錄下。相較於使用指令，因為可攜式環境沒辦法呼叫外部程式支援，所以用cmake-gui.exe圖形介面來設定相關環境。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0703-2_01.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;一開始對cmake-gui.exe的兩個位置指向不太清楚，所以嘗試了很多次。&lt;/p&gt;
&lt;p&gt;要在Solvespace的目錄中建立一個/build資料夾，以存放binaries。&lt;/p&gt;
&lt;p&gt;Source code的部分是填程式專案的目錄，binaries的地方填/build資料夾，再按Configure鈕設定編譯器，完成後會設置CMake的檔案。&lt;/p&gt;
&lt;p&gt;雖然之前的目錄已經有檔案了，但是如果binaries直接設目錄內，貌似會衝突產生問題，也無法復原設定檔，幸好有先備份資料能復原。&lt;/p&gt;
&lt;p&gt;Configure的部分嘗試選擇MinGW的選項。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0703-2_02.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;下面則選Specify native compilers來自訂編譯器位置，這時執行出現一個錯誤，無法執行MinGW。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0703-2_03.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;上網尋找似乎要修改系統環境參數到MinGW的bin資料夾才找的到原本就存在的libgmp-10.dll，不知道可攜式環境有沒有其他解法。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;暫時用Visual Studio的設定，但是結果似乎不理想。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0703-2_04.jpg" /&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;參考資料：&lt;/p&gt;
&lt;p&gt;1.&lt;a href="https://www.youtube.com/watch?v=gYmgbqGfv-8" title="youtube.com"&gt;教學影片-Visual Studio&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href="https://www.youtube.com/watch?v=2A-iRgOhL8A" title="youtube.com"&gt;教學影片-Mingw&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前還不會使用MinGW或Netbeans套件，所以暫時先放在可攜環境git2016中，之後會找資料學習如何編譯Solvespace的功能。&lt;/p&gt;</summary><category term="Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/03</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050703.html" rel="alternate"></link><published>2016-07-03T12:00:00+08:00</published><updated>2016-07-03T12:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-03:blog/40323230ri-zhi-1050703.html</id><summary type="html">&lt;p&gt;關於編譯 Solvespace&lt;/p&gt;


&lt;h2&gt;編譯 Solvespace 前的準備 :&lt;/h2&gt;

&lt;p&gt;從&lt;a href="http://www.activestate.com/activeperl/downloads" title="activestate.com"&gt;Active State&lt;/a&gt;下載了 ActivePerl，使用的是5.24.0／x64版。&lt;/p&gt;
&lt;p&gt;從&lt;a href="https://www.visualstudio.com/downloads/download-visual-studio-vs" title="visualstudio.com"&gt;Microsoft&lt;/a&gt;下載並安裝了Visual Studio Professional 2015，安裝好像無法選擇C:以外的磁碟。&lt;/p&gt;
&lt;p&gt;從&lt;a href="https://github.com/whitequark/solvespace" title="github.com"&gt;GitHub&lt;/a&gt;下載Solvespace的原始碼，另外在&lt;a href="http://solvespace.com/download.pl" title="solvespace.com"&gt;Solvespace&lt;/a&gt;提供下載的頁面中也有一個較舊版的原始碼。&lt;/p&gt;
&lt;p&gt;裝完之後用Developer Command Prompt切換至專案目錄執行nmake，就能下相關指令了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0703_01.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;用CMD從安裝目錄的\VC\bin啟動vcvars32.bat，執行nmake好像也可以，不知道其差異性。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0703_02.jpg" /&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;關於NMAKE的使用方法，找了幾個中國的網站介紹：&lt;/p&gt;
&lt;p&gt;1.&lt;a href="http://www.cnblogs.com/kekec/archive/2013/04/21/3007277.html" title="cnblogs.com"&gt;NMAKE的指令&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href="http://blog.csdn.net/cneaglelee/article/details/11714803" title="csdn.net"&gt;NMAKE的開發環境設置&lt;/a&gt;&lt;/p&gt;</summary><category term="Solvespace"></category></entry><entry><title>40323230紀錄</title><link href="http://project.mde.tw/blog/40323230ji-lu.html" rel="alternate"></link><published>2016-07-02T19:00:00+08:00</published><updated>2016-07-02T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-02:blog/40323230ji-lu.html</id><summary type="html">&lt;p&gt;V-REP從範本學得的一些紀錄&lt;/p&gt;


&lt;h2&gt;V-REP Example Learning Reviews&lt;/h2&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h4&gt;嘗試用英文說明&lt;/h4&gt;
&lt;/br&gt;
&lt;h2&gt;Notes :&lt;/h2&gt;
&lt;/br&gt;
&lt;h3&gt;The "Scene hierarchy" panel can show whole of outward and entity in a tree.&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;
&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#SceneHierarchy" title="coppeliarobotics.com"&gt;Scene hierarchy&lt;/a&gt; Description page
&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/cqIHtFn.jpg" &gt;
&lt;/br&gt;
&lt;h3&gt;In this case, a group of parts will in the same level. they are outward, entity and joint parts. Maybe some sensor parts will put into this group.&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;Any parts can insert a script to control them.&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;"Dummy" parts is a calculation module. They are collidable, measurable and detectable like the entity. But now we are't clearly known it's application.&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;
&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/dummies.htm" title="coppeliarobotics.com"&gt;Dummy&lt;/a&gt; Description page
&lt;/h3&gt;
&lt;/br&gt;&lt;hr&gt;&lt;/br&gt;
&lt;h3&gt;組裝上可以使用「滑塊主動噴頭連動」或「噴頭主動滑塊連動」的方式，但是在從屬關係上必須顛倒，程式寫法也不一樣。「滑塊主動噴頭連動」的方式較符合3D印表機的物理運作。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/caU2SLx.jpg" &gt;
&lt;/br&gt;&lt;hr&gt;&lt;/br&gt;
&lt;h3&gt;目前整理完幾何部件的檔案。存於\users\g2_files\VREP_Simulation.ttt中。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/jNvEHRc.jpg" &gt;&lt;/p&gt;</summary><category term="V-rep"></category></entry><entry><title>40323250日誌 - 105/06/29</title><link href="http://project.mde.tw/blog/40323250ri-zhi-1050629.html" rel="alternate"></link><published>2016-06-29T21:37:00+08:00</published><updated>2016-06-29T21:37:00+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2016-06-29:blog/40323250ri-zhi-1050629.html</id><summary type="html">&lt;p&gt;暑期第一個禮拜的 星期三&lt;/p&gt;


&lt;h3&gt;進度&lt;/h3&gt;

&lt;h4&gt;目前組了兩個版本，一個是簡易版，沒有多餘零件，另一個是完整版，有畫的零件都組上去了，如圖:&lt;/h4&gt;

&lt;p&gt;&lt;/br&gt;
&lt;img src="http://i.imgur.com/OCcfYur.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;以下是零件&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/64Qlmfm.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;以下是v-rep拆解後的截圖&lt;/h3&gt;
&lt;/br&gt;
&lt;h4&gt;簡易版&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/1C9EKl2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h4&gt;完整版&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/I7q77aX.png"&gt;
&lt;/br&gt;
&lt;h3&gt;明天應該就可以開始測試模擬了。&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;Onshape零件及兩個stl檔案都放在users/g2_files目錄下，歡迎取用。&lt;/h3&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>40323250日誌 - 105/06/28</title><link href="http://project.mde.tw/blog/40323250ri-zhi-1050628.html" rel="alternate"></link><published>2016-06-28T20:48:00+08:00</published><updated>2016-06-28T20:48:00+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2016-06-28:blog/40323250ri-zhi-1050628.html</id><summary type="html">&lt;p&gt;暑期第一個禮拜的 星期二&lt;/p&gt;


&lt;h3&gt;目前組合進度&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;img src="http://i.imgur.com/D2k3uqk.gif"&gt;
&lt;/br&gt;
&lt;h3&gt;目前遇到的狀況&lt;/h3&gt;
&lt;h4&gt;我把滑塊設定為slider，能在滑軌上做相對移動，但是在拉到一半的時候，Onshape整個圖形就消失了，然後點選左方的zoom to section還是能顯示，但呈現以下狀態&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/W3N5pkC.png"&gt;
&lt;/br&gt;
&lt;h4&gt;滑鼠選轉及縮放也跟著出問題，點選右方試圖方塊圖又會不見，只能重新再組一次。&lt;/h4&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>Summer Plan</title><link href="http://project.mde.tw/blog/summer-plan.html" rel="alternate"></link><published>2016-06-23T17:10:00+08:00</published><updated>2016-06-23T17:10:00+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2016-06-23:blog/summer-plan.html</id><summary type="html">&lt;p&gt;Summer project&lt;/p&gt;


&lt;p&gt;1.畫3D Printer (V-rep ,Onshape)&lt;/p&gt;

&lt;p&gt;2.實驗室網站介面&lt;/p&gt;

&lt;p&gt;3.Octopi ,機械手臂&lt;/p&gt;

&lt;p&gt;4.OpenCV &lt;/p&gt;

&lt;p&gt;5.RGA演算&lt;/p&gt;

&lt;p&gt;6.認證主機(Virtual Box)&lt;/p&gt;

&lt;p&gt;7.Proxy&lt;/p&gt;

&lt;p&gt;8.報告(拍照 ,內容整理)&lt;/p&gt;

&lt;p&gt;9.找碩班教授&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;
&lt;p&gt;暑期人數 : &lt;/p&gt;
&lt;p&gt;七月:第一組3人 ,第二組4人&lt;/p&gt;
&lt;p&gt;八月:第一組3人 ,第二組4人 ,第三組1人&lt;/p&gt;
&lt;p&gt;&lt;font size="5" face="Arial"&gt;&lt;marquee border="0" scrollamount="50" behavior="alternate"&gt;You can't see me&lt;/marquee&gt;&lt;/font&gt;&lt;/p&gt;&lt;/p&gt;</summary><category term="Kmol"></category></entry><entry><title>OpenCv範例執行</title><link href="http://project.mde.tw/blog/opencvfan-li-zhi-xing.html" rel="alternate"></link><published>2016-06-10T17:50:00+08:00</published><updated>2016-06-10T17:50:00+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2016-06-10:blog/opencvfan-li-zhi-xing.html</id><summary type="html">&lt;p&gt;OpenCv example with python test&lt;/p&gt;


&lt;h3&gt;實作系統Ubuntu 14.04 以及 老師整合的檔案&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;p&gt;&lt;a href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_image_display/py_image_display.html#display-image"&gt;範例網址1.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/picture/messi.jpg"&gt;使用到的圖片&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;程式碼&lt;/h4&gt;
&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2
img = cv2.imread('messi.jpg',0)
cv2.imshow('image',img)
k = cv2.waitKey(0)
if k == 27:         # wait for ESC key to exit
    cv2.destroyAllWindows()
elif k == ord('s'): # wait for 's' key to save and exit
    cv2.imwrite('messigray.png',img)
    cv2.destroyAllWindows()
&lt;/pre&gt;
&lt;h3&gt;執行結果&lt;/h3&gt;
&lt;img src="http://i.imgur.com/tI55TDf.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;p&gt;&lt;a href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_video_display/py_video_display.html#display-video"&gt;範例網址2.&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;程式碼&lt;/h4&gt;
&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2
cap = cv2.VideoCapture(0)
while(True):
    # Capture frame-by-frame
    ret, frame = cap.read()
    # Our operations on the frame come here
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    # Display the resulting frame
    cv2.imshow('frame',gray)
    if cv2.waitKey(1) &amp;amp; 0xFF == ord('q'):
        break&lt;/p&gt;
&lt;h1&gt;When everything done, release the capture&lt;/h1&gt;
&lt;p&gt;cap.release()
cv2.destroyAllWindows()
&lt;/pre&gt;
&lt;h3&gt;執行結果&lt;/h3&gt;
&lt;img src="http://i.imgur.com/MOL03LL.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;p&gt;範例網址3.(同上)&lt;/p&gt;
&lt;h4&gt;程式碼&lt;/h4&gt;
&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2
cap = cv2.VideoCapture(0)&lt;/p&gt;
&lt;h1&gt;Define the codec and create VideoWriter object&lt;/h1&gt;
&lt;p&gt;fourcc = cv2.VideoWriter_fourcc(*'XVID')
out = cv2.VideoWriter('output.avi',fourcc, 20.0, (640,480))
while(cap.isOpened()):
    ret, frame = cap.read()
    if ret==True:
        frame = cv2.flip(frame,1)
        # write the flipped frame
        out.write(frame)
        cv2.imshow('frame',frame)
        if cv2.waitKey(1) &amp;amp; 0xFF == ord('q'):
            break
    else:
        break&lt;/p&gt;
&lt;h1&gt;Release everything if job is finished&lt;/h1&gt;
&lt;p&gt;cap.release()
out.release()
cv2.destroyAllWindows()
&lt;/pre&gt;
&lt;h3&gt;執行結果&lt;/h3&gt;
&lt;h4&gt;得到檔案名稱為output的avi影片檔&lt;/h4&gt;&lt;/p&gt;</summary><category term="OpenCv"></category></entry></feed>